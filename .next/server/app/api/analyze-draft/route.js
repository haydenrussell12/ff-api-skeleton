"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/analyze-draft/route";
exports.ids = ["app/api/analyze-draft/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_kanikameister_Documents_ff_api_skeleton_app_api_analyze_draft_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/analyze-draft/route.ts */ \"(rsc)/./app/api/analyze-draft/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/analyze-draft/route\",\n        pathname: \"/api/analyze-draft\",\n        filename: \"route\",\n        bundlePath: \"app/api/analyze-draft/route\"\n    },\n    resolvedPagePath: \"/Users/kanikameister/Documents/ff_api_skeleton/app/api/analyze-draft/route.ts\",\n    nextConfigOutput,\n    userland: _Users_kanikameister_Documents_ff_api_skeleton_app_api_analyze_draft_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/analyze-draft/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZhbmFseXplLWRyYWZ0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZhbmFseXplLWRyYWZ0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYW5hbHl6ZS1kcmFmdCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmthbmlrYW1laXN0ZXIlMkZEb2N1bWVudHMlMkZmZl9hcGlfc2tlbGV0b24lMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGa2FuaWthbWVpc3RlciUyRkRvY3VtZW50cyUyRmZmX2FwaV9za2VsZXRvbiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDNkI7QUFDMUc7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mZl9hcGlfc2tlbGV0b24vP2QxZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2thbmlrYW1laXN0ZXIvRG9jdW1lbnRzL2ZmX2FwaV9za2VsZXRvbi9hcHAvYXBpL2FuYWx5emUtZHJhZnQvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2FuYWx5emUtZHJhZnQvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9hbmFseXplLWRyYWZ0XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9hbmFseXplLWRyYWZ0L3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2thbmlrYW1laXN0ZXIvRG9jdW1lbnRzL2ZmX2FwaV9za2VsZXRvbi9hcHAvYXBpL2FuYWx5emUtZHJhZnQvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2FuYWx5emUtZHJhZnQvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/analyze-draft/route.ts":
/*!****************************************!*\
  !*** ./app/api/analyze-draft/route.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_optimal_lineup_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/optimal-lineup-engine */ \"(rsc)/./app/lib/optimal-lineup-engine.ts\");\n/* harmony import */ var _lib_position_grade_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/position-grade-engine */ \"(rsc)/./app/lib/position-grade-engine.ts\");\nconst runtime = \"nodejs\";\n\n\n\n// Draft Analyzer class converted for Next.js\nclass DraftAnalyzer {\n    async initialize() {\n        try {\n            console.log(\"\\uD83D\\uDE80 Initializing Draft Analyzer...\");\n            // Load consolidated player data via imports so Vercel bundles them\n            const [masterPlayersModule, nameLookupModule, vorpDataModule, adpDataModule] = await Promise.all([\n                __webpack_require__.e(/*! import() */ \"_rsc_data_consolidated_master-players_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! data/consolidated/master-players.json */ \"(rsc)/./data/consolidated/master-players.json\", 19)),\n                __webpack_require__.e(/*! import() */ \"_rsc_data_consolidated_name-lookup-index_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! data/consolidated/name-lookup-index.json */ \"(rsc)/./data/consolidated/name-lookup-index.json\", 19)),\n                __webpack_require__.e(/*! import() */ \"_rsc_data_consolidated_player-vorp-scores_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! data/consolidated/player-vorp-scores.json */ \"(rsc)/./data/consolidated/player-vorp-scores.json\", 19)),\n                __webpack_require__.e(/*! import() */ \"_rsc_adp_data_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../../adp_data.json */ \"(rsc)/./adp_data.json\", 19))\n            ]);\n            console.log(\"\\uD83D\\uDD0D Loaded modules:\", {\n                masterPlayers: !!masterPlayersModule,\n                nameLookup: !!nameLookupModule,\n                vorpData: !!vorpDataModule,\n                adpData: !!adpDataModule\n            });\n            // Create lookup by player name (case-insensitive)\n            const masterPlayers = masterPlayersModule.default.players;\n            console.log(\"\\uD83D\\uDD0D Master players structure:\", {\n                hasDefault: !!masterPlayersModule.default,\n                hasPlayers: !!masterPlayers,\n                playerCount: masterPlayers?.length || 0,\n                samplePlayer: masterPlayers?.[0]\n            });\n            this.consolidatedData = {};\n            masterPlayers.forEach((player)=>{\n                if (player.full_name) {\n                    // Store by both full_name and player_id for flexibility\n                    this.consolidatedData[player.full_name.toLowerCase()] = player;\n                    if (player.player_id) {\n                        this.consolidatedData[player.player_id.toLowerCase()] = player;\n                    }\n                }\n            });\n            this.nameLookupIndex = nameLookupModule.default;\n            this.vorpData = vorpDataModule.default.vorpScores || vorpDataModule.default;\n            // Create ADP lookup by player name - adp_data.json has players array\n            this.adpData = {};\n            const adpPlayers = adpDataModule.default.players || [];\n            console.log(\"\\uD83D\\uDD0D ADP data structure:\", {\n                hasDefault: !!adpDataModule.default,\n                hasPlayers: !!adpPlayers,\n                playerCount: adpPlayers?.length || 0,\n                samplePlayer: adpPlayers?.[0]\n            });\n            adpPlayers.forEach((player)=>{\n                if (player.full_name) {\n                    this.adpData[player.full_name.toLowerCase()] = player;\n                }\n            });\n            console.log(`‚úÖ Draft Analyzer initialized with ${Object.keys(this.consolidatedData).length} players and ${Object.keys(this.adpData).length} ADP records.`);\n            console.log(`üîç Sample consolidated players:`, Object.keys(this.consolidatedData).slice(0, 5));\n            console.log(`üîç Sample ADP players:`, Object.keys(this.adpData).slice(0, 5));\n        } catch (error) {\n            console.error(\"‚ùå Failed to initialize Draft Analyzer:\", error);\n            throw new Error(\"Failed to load necessary data for analysis.\");\n        }\n    }\n    async fetchSleeperApi(url) {\n        console.log(`üîç Fetching from Sleeper API: ${url}`);\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch from Sleeper API: ${response.statusText}`);\n        }\n        const data = await response.json();\n        console.log(`‚úÖ Sleeper API response:`, {\n            url,\n            status: response.status,\n            dataType: Array.isArray(data) ? \"array\" : \"object\",\n            dataLength: Array.isArray(data) ? data.length : Object.keys(data).length,\n            sampleData: Array.isArray(data) ? data.slice(0, 2) : Object.keys(data).slice(0, 5)\n        });\n        return data;\n    }\n    parseSleeperDraftUrl(url) {\n        // Support both sleeper.com and sleeper.app domains and alphanumeric draft IDs\n        const regex = /sleeper\\.(?:com|app)\\/draft\\/nfl\\/([a-zA-Z0-9]+)/;\n        const match = url.match(regex);\n        if (!match || !match[1]) {\n            throw new Error(\"Invalid Sleeper mock draft URL format. Expected format: https://sleeper.app/draft/nfl/{draft_id}\");\n        }\n        return match[1];\n    }\n    normalizePlayerName(name) {\n        if (!name) return \"\";\n        // Remove common suffixes and normalize\n        return name.toLowerCase().replace(/\\s+(jr\\.?|sr\\.?|ii|iii|iv|v|vi|vii|viii|ix|x)\\s*$/i, \"\") // Remove suffixes\n        .replace(/\\s+/g, \" \") // Normalize whitespace\n        .trim();\n    }\n    findPlayerByName(playerName, position) {\n        if (!playerName) return null;\n        const normalizedName = this.normalizePlayerName(playerName);\n        console.log(`üîç Looking for player: \"${playerName}\" -> normalized: \"${normalizedName}\"`);\n        // First try exact match with normalized name\n        let player = this.consolidatedData[normalizedName];\n        if (player) {\n            console.log(`‚úÖ Found exact match: ${playerName}`);\n            return player;\n        }\n        // Try exact match with original name (case-insensitive)\n        player = this.consolidatedData[playerName.toLowerCase()];\n        if (player) {\n            console.log(`‚úÖ Found exact match with original name: ${playerName}`);\n            return player;\n        }\n        // Try fuzzy matching by removing suffixes and checking partial matches\n        const nameParts = normalizedName.split(\" \");\n        if (nameParts.length >= 2) {\n            const firstName = nameParts[0];\n            const lastName = nameParts[nameParts.length - 1];\n            console.log(`üîç Trying fuzzy match: firstName=\"${firstName}\", lastName=\"${lastName}\"`);\n            // Look for players with matching first and last name\n            for (const [key, data] of Object.entries(this.consolidatedData)){\n                const keyParts = key.split(\" \");\n                if (keyParts.length >= 2) {\n                    const keyFirstName = keyParts[0];\n                    const keyLastName = keyParts[keyParts.length - 1];\n                    if (keyFirstName === firstName && keyLastName === lastName) {\n                        console.log(`‚úÖ Found fuzzy match: \"${playerName}\" -> \"${key}\"`);\n                        return data;\n                    }\n                }\n            }\n        }\n        // Last resort: try to find any player whose name contains the search name\n        for (const [key, data] of Object.entries(this.consolidatedData)){\n            if (key.includes(normalizedName) || normalizedName.includes(key)) {\n                console.log(`‚úÖ Found partial match: \"${playerName}\" -> \"${key}\"`);\n                return data;\n            }\n        }\n        console.log(`‚ùå No match found for: ${playerName}`);\n        console.log(`üîç Available players starting with similar names:`, Object.keys(this.consolidatedData).filter((k)=>k.includes(normalizedName.split(\" \")[0])).slice(0, 5));\n        return null;\n    }\n    getPlayerProjectedPoints(playerName, position) {\n        const player = this.findPlayerByName(playerName, position);\n        if (!player || !player.projections) {\n            console.log(`‚ö†Ô∏è No player or projections found for: ${playerName} (${position})`);\n            return 0;\n        }\n        const posKey = position?.toLowerCase();\n        console.log(`üîç Looking for projections for ${playerName} at position: ${posKey}`);\n        console.log(`üîç Available projection keys:`, Object.keys(player.projections));\n        let fpts = 0;\n        // Handle defense projections - try multiple approaches\n        if (posKey === \"def\" || posKey === \"defense\") {\n            console.log(`üõ°Ô∏è Processing DEFENSE player: ${playerName}`);\n            // Method 1: Try exact position keys\n            const defenseKeys = [\n                \"def\",\n                \"DEF\",\n                \"defense\",\n                \"Defense\",\n                \"DEFENSE\"\n            ];\n            for (const key of defenseKeys){\n                if (player.projections[key]?.fpts) {\n                    fpts = player.projections[key].fpts;\n                    console.log(`‚úÖ Found defense projections using key: ${key} = ${fpts}`);\n                    break;\n                }\n            }\n            // Method 2: Try partial key matching\n            if (!fpts) {\n                for (const key of Object.keys(player.projections)){\n                    if (key.toLowerCase().includes(\"def\")) {\n                        fpts = player.projections[key].fpts;\n                        console.log(`‚úÖ Found defense projections using partial key: ${key} = ${fpts}`);\n                        break;\n                    }\n                }\n            }\n            // Method 3: Look for any numeric projection value\n            if (!fpts) {\n                for (const key of Object.keys(player.projections)){\n                    const projection = player.projections[key];\n                    if (projection && typeof projection === \"object\" && projection.fpts) {\n                        fpts = projection.fpts;\n                        console.log(`‚úÖ Found defense projections using generic key: ${key} = ${fpts}`);\n                        break;\n                    }\n                }\n            }\n            // Method 4: Look for any numeric value in projections\n            if (!fpts) {\n                for (const key of Object.keys(player.projections)){\n                    const value = player.projections[key];\n                    if (typeof value === \"number\" && value > 0) {\n                        fpts = value;\n                        console.log(`‚úÖ Found defense projections using numeric key: ${key} = ${fpts}`);\n                        break;\n                    }\n                }\n            }\n            // Method 5: Check if projections is just a number (some defenses have this)\n            if (!fpts && typeof player.projections === \"number\" && player.projections > 0) {\n                fpts = player.projections;\n                console.log(`‚úÖ Found defense projections as direct number: ${fpts}`);\n            }\n        } else {\n            // Non-defense players - try standard approach\n            fpts = player.projections[posKey]?.fpts;\n        }\n        if (fpts) {\n            console.log(`‚úÖ Projected points for ${playerName}: ${fpts}`);\n            return typeof fpts === \"number\" ? fpts : parseFloat(fpts);\n        } else {\n            console.log(`‚ùå No projected points found for ${playerName} at position ${posKey}`);\n            console.log(`üîç Player projections structure:`, player.projections);\n            return 0;\n        }\n    }\n    getPlayerAdp(playerName) {\n        const player = this.findPlayerByName(playerName, \"\");\n        if (!player) return 0;\n        // Try to find in ADP data with normalized name\n        const normalizedName = this.normalizePlayerName(playerName);\n        let adpPlayer = this.adpData[normalizedName];\n        if (!adpPlayer) {\n            // Try fuzzy matching for ADP too\n            const nameParts = normalizedName.split(\" \");\n            if (nameParts.length >= 2) {\n                const firstName = nameParts[0];\n                const lastName = nameParts[nameParts.length - 1];\n                for (const [key, data] of Object.entries(this.adpData)){\n                    const keyParts = key.split(\" \");\n                    if (keyParts.length >= 2) {\n                        const keyFirstName = keyParts[0];\n                        const keyLastName = keyParts[keyParts.length - 1];\n                        if (keyFirstName === firstName && keyLastName === lastName) {\n                            adpPlayer = data;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        const adp = adpPlayer?.adp_value;\n        return adp ? parseFloat(adp) : 0;\n    }\n    getPlayerVorp(playerName) {\n        const normalizedName = this.normalizePlayerName(playerName);\n        if (!normalizedName) return 0;\n        const direct = Array.isArray(this.vorpData) ? this.vorpData.find((p)=>{\n            const pName = this.normalizePlayerName(p.playerName || \"\");\n            return pName === normalizedName;\n        }) : undefined;\n        return direct?.vorp_score || direct?.vorpScore ? parseFloat(direct.vorp_score || direct.vorpScore) : 0;\n    }\n    async analyzeDraft(draftUrl, leagueType = \"standard\") {\n        await this.initialize();\n        console.log(\"\\uD83D\\uDD0D Fetching draft data from Sleeper...\");\n        const draftId = this.parseSleeperDraftUrl(draftUrl);\n        // Fetch draft data\n        const draftData = await this.fetchSleeperApi(`https://api.sleeper.app/v1/draft/${draftId}`);\n        const draftPicks = await this.fetchSleeperApi(`https://api.sleeper.app/v1/draft/${draftId}/picks?limit=1000`);\n        console.log(\"\\uD83D\\uDCCA Draft data fetched:\", {\n            draftName: draftData.name,\n            teams: draftData.teams?.length || 0,\n            rounds: draftData.settings?.rounds || 0,\n            picks: draftPicks?.length || 0,\n            expectedPicks: (draftData.teams?.length || 0) * (draftData.settings?.rounds || 0)\n        });\n        // Process draft picks and build team rosters\n        const teams = await this.buildTeamRosters(draftData, draftPicks);\n        // Calculate optimal lineups and grades\n        const result = this.analyzeTeams(teams, leagueType);\n        return {\n            draftInfo: {\n                name: draftData.name,\n                teams: draftData.teams?.length || 0,\n                rounds: draftData.settings?.rounds || 0,\n                totalPicks: draftPicks?.length || 0\n            },\n            ...result\n        };\n    }\n    analyzeTeams(teams, leagueType = \"standard\") {\n        const lineupEngine = new _lib_optimal_lineup_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        const gradeEngine = new _lib_position_grade_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        // Get actual draft dimensions from the teams data\n        const actualTeams = Object.keys(teams).length;\n        const actualRounds = Math.max(...Object.values(teams).map((team)=>Math.max(...(team.roster || []).map((p)=>p.round || 0))), 16);\n        console.log(\"\\uD83D\\uDCCA Draft dimensions:\", {\n            actualTeams,\n            actualRounds\n        });\n        // First calculate optimal lineups for all teams\n        const analysisTeams = Object.entries(teams).map(([id, team])=>{\n            const lineup = lineupEngine.calculateOptimalLineup(team.roster, {\n                leagueType,\n                scoring: \"ppr\",\n                teams: actualTeams,\n                rounds: actualRounds\n            });\n            // Calculate average ADP\n            const adpValues = team.roster.map((p)=>p.adpValue || 0).filter((v)=>v !== 0);\n            const averageAdpValue = adpValues.length > 0 ? adpValues.reduce((s, v)=>s + v, 0) / adpValues.length : 0;\n            // Calculate average VORP\n            const vorpValues = team.roster.map((p)=>p.vorpScore || 0).filter((v)=>v !== 0);\n            const averageVorpScore = vorpValues.length > 0 ? vorpValues.reduce((s, v)=>s + v, 0) / vorpValues.length : 0;\n            // Calculate optimal lineup points\n            const optimalLineupPoints = lineupEngine.calculateTotalProjectedPoints(lineup);\n            // Get bench players and points\n            const benchPlayers = lineupEngine.getBenchPlayers(team.roster, lineup);\n            const benchPoints = lineupEngine.calculateTotalProjectedPoints(benchPlayers);\n            // Get lineup analysis\n            const lineupAnalysis = lineupEngine.analyzeLineup(lineup, {\n                leagueType,\n                scoring: \"ppr\",\n                teams: Object.keys(teams).length\n            });\n            return {\n                teamId: id,\n                teamName: team.teamName,\n                draftSlot: team.draftSlot,\n                roster: team.roster,\n                optimalLineup: lineup,\n                optimalLineupPoints,\n                benchPlayers,\n                benchPoints,\n                totalProjectedPoints: optimalLineupPoints + benchPoints,\n                averageAdpValue,\n                averageVorpScore,\n                lineupAnalysis\n            };\n        });\n        // Now calculate position grades using the teams with optimal lineups\n        const gradedTeams = gradeEngine.calculatePositionGrades(analysisTeams, {\n            leagueType,\n            scoring: \"ppr\",\n            teams: Object.keys(teams).length\n        });\n        // Map the graded teams back to the expected format for the frontend\n        const finalTeams = gradedTeams.map((gradedTeam)=>{\n            // Find the original analysis team data\n            const originalTeam = analysisTeams.find((t)=>t.teamId === gradedTeam.teamId);\n            return {\n                teamId: gradedTeam.teamId,\n                teamName: gradedTeam.teamName,\n                draftSlot: originalTeam?.draftSlot || 0,\n                optimalLineup: originalTeam?.optimalLineup || {},\n                optimalLineupPoints: originalTeam?.optimalLineupPoints || 0,\n                benchPlayers: originalTeam?.benchPlayers || [],\n                benchPoints: originalTeam?.benchPoints || 0,\n                positionGrades: gradedTeam.positionGrades || {},\n                overallGrade: gradedTeam.overallGrade || {\n                    grade: \"‚Äî\",\n                    score: 0\n                },\n                totalProjectedPoints: (originalTeam?.optimalLineupPoints || 0) + (originalTeam?.benchPoints || 0),\n                averageProjectedPoints: (()=>{\n                    if (!originalTeam?.roster?.length) return 0;\n                    return originalTeam.roster.reduce((sum, p)=>sum + (p.projectedPoints || 0), 0) / originalTeam.roster.length;\n                })(),\n                averageAdpValue: originalTeam?.averageAdpValue || 0,\n                averageVorpScore: originalTeam?.averageVorpScore || 0,\n                players: originalTeam?.roster || [],\n                roster: originalTeam?.roster || []\n            };\n        });\n        return {\n            analysis: {\n                teams: finalTeams\n            }\n        };\n    }\n    async buildTeamRosters(draftData, draftPicks) {\n        const slotToRosterId = draftData.slot_to_roster_id;\n        if (!slotToRosterId) {\n            throw new Error(\"No slot_to_roster_id found in draft data - this may not be a mock draft\");\n        }\n        const slotToName = {};\n        // SMART USERNAME DETECTION - Don't rely on failing endpoints\n        if (draftData.metadata?.draft_order_by_roster_id) {\n            // Use metadata if available\n            Object.entries(draftData.metadata.draft_order_by_roster_id).forEach(([rosterId, slot])=>{\n                slotToName[slot] = `Team ${parseInt(rosterId) + 1}`;\n            });\n        } else {\n            // Fallback to slot numbers\n            Object.keys(slotToRosterId).forEach((slot)=>{\n                slotToName[slot] = `Team ${parseInt(slot) + 1}`;\n            });\n        }\n        // Fetch NFL players data\n        const playersMap = await this.fetchSleeperApi(`https://api.sleeper.app/v1/players/nfl`);\n        const getSleeperPlayer = (id)=>playersMap?.[id];\n        const teams = {};\n        // Process each pick and build team rosters\n        draftPicks.forEach((pick)=>{\n            const slot = pick.pick_no.toString();\n            const rosterId = slotToRosterId[slot];\n            if (!rosterId) {\n                console.warn(`No roster ID found for slot ${slot}`);\n                return;\n            }\n            if (!teams[rosterId]) {\n                teams[rosterId] = {\n                    teamId: rosterId,\n                    teamName: slotToName[slot] || `Team ${rosterId}`,\n                    draftSlot: parseInt(slot),\n                    roster: []\n                };\n            }\n            // Get player data\n            const sleeperPlayer = getSleeperPlayer(pick.player_id);\n            if (!sleeperPlayer) {\n                console.warn(`No player data found for ID ${pick.player_id}`);\n                return;\n            }\n            // Enhance player data with projections and VORP\n            const enhancedPlayer = this.enhancePlayerData(sleeperPlayer, pick);\n            teams[rosterId].roster.push(enhancedPlayer);\n        });\n        return teams;\n    }\n    enhancePlayerData(sleeperPlayer, pick) {\n        const playerName = sleeperPlayer.full_name || `${sleeperPlayer.first_name || \"\"} ${sleeperPlayer.last_name || \"\"}`.trim();\n        const position = sleeperPlayer.position || pick.metadata?.position || \"\";\n        const projectedPoints = this.getPlayerProjectedPoints(playerName, position);\n        const adpValue = this.getPlayerAdp(playerName);\n        const vorpScore = this.getPlayerVorp(playerName);\n        // Calculate draft value: negative means player was drafted above ADP (good value)\n        const draftValue = adpValue > 0 ? adpValue - pick.draft_slot : 0;\n        return {\n            ...pick,\n            metadata: sleeperPlayer,\n            playerName,\n            position,\n            projectedPoints,\n            adpValue,\n            vorpScore,\n            draftValue,\n            playerId: pick.player_id\n        };\n    }\n    constructor(){\n        this.consolidatedData = {};\n        this.nameLookupIndex = {};\n        this.playerDetails = {};\n        this.vorpData = {};\n        this.adpData = {} // Added adpData property\n        ;\n    }\n}\nasync function POST(request) {\n    try {\n        const { draftUrl, leagueType = \"standard\" } = await request.json();\n        if (!draftUrl) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Draft URL is required\"\n            });\n        }\n        console.log(\"\\uD83D\\uDE80 Starting draft analysis...\");\n        console.log(\"\\uD83D\\uDD0D Draft URL:\", draftUrl);\n        console.log(\"\\uD83C\\uDFC8 League Type:\", leagueType);\n        const analyzer = new DraftAnalyzer();\n        await analyzer.initialize();\n        const result = await analyzer.analyzeDraft(draftUrl, leagueType);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data: result\n        });\n    } catch (error) {\n        console.error(\"‚ùå Error in draft analysis:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error instanceof Error ? error.message : \"Unknown error occurred\"\n        });\n    }\n}\nfunction GET() {\n    return new Response(\"Method Not Allowed\", {\n        status: 405,\n        headers: {\n            Allow: \"POST\"\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFpQjBGO1FBQzdCM0YsUUFBUUMsR0FBRyxDQUFDLDZCQUFtQjJGO1FBRS9CLE1BQU00RixXQUFXLElBQUkxTDtRQUNyQixNQUFNMEwsU0FBU3pMLFVBQVU7UUFFekIsTUFBTXdHLFNBQVMsTUFBTWlGLFNBQVM5RixZQUFZLENBQUNDLFVBQVVDO1FBRXJELE9BQU9qRyxxREFBWUEsQ0FBQzZDLElBQUksQ0FBQztZQUFFK0ksU0FBUztZQUFNaEosTUFBTWdFO1FBQU87SUFDM0QsRUFBRSxPQUFPeEUsT0FBTztRQUNaL0IsUUFBUStCLEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU9wQyxxREFBWUEsQ0FBQzZDLElBQUksQ0FBQztZQUNyQitJLFNBQVM7WUFDVHhKLE9BQU9BLGlCQUFpQkMsUUFBUUQsTUFBTTBKLE9BQU8sR0FBRztRQUNwRDtJQUNKO0FBQ0o7QUFFTyxTQUFTQztJQUNkLE9BQU8sSUFBSUMsU0FBUyxzQkFBc0I7UUFBRWxKLFFBQVE7UUFBS21KLFNBQVM7WUFBRUMsT0FBTztRQUFPO0lBQUU7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mZl9hcGlfc2tlbGV0b24vLi9hcHAvYXBpL2FuYWx5emUtZHJhZnQvcm91dGUudHM/MjY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgcnVudGltZSA9ICdub2RlanMnO1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvc2VydmVyXCI7XG5pbXBvcnQgT3B0aW1hbExpbmV1cEVuZ2luZSBmcm9tICcuLi8uLi9saWIvb3B0aW1hbC1saW5ldXAtZW5naW5lJztcbmltcG9ydCBQb3NpdGlvbkdyYWRlRW5naW5lIGZyb20gJy4uLy4uL2xpYi9wb3NpdGlvbi1ncmFkZS1lbmdpbmUnO1xuXG4vLyBEcmFmdCBBbmFseXplciBjbGFzcyBjb252ZXJ0ZWQgZm9yIE5leHQuanNcbmNsYXNzIERyYWZ0QW5hbHl6ZXIge1xuICAgIHByaXZhdGUgY29uc29saWRhdGVkRGF0YTogYW55ID0ge307XG4gICAgcHJpdmF0ZSBuYW1lTG9va3VwSW5kZXg6IGFueSA9IHt9O1xuICAgIHByaXZhdGUgcGxheWVyRGV0YWlsczogYW55ID0ge307XG4gICAgcHJpdmF0ZSB2b3JwRGF0YTogYW55ID0ge307XG4gICAgcHJpdmF0ZSBhZHBEYXRhOiBhbnkgPSB7fTsgLy8gQWRkZWQgYWRwRGF0YSBwcm9wZXJ0eVxuXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5qAIEluaXRpYWxpemluZyBEcmFmdCBBbmFseXplci4uLicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBMb2FkIGNvbnNvbGlkYXRlZCBwbGF5ZXIgZGF0YSB2aWEgaW1wb3J0cyBzbyBWZXJjZWwgYnVuZGxlcyB0aGVtXG4gICAgICAgICAgICBjb25zdCBbbWFzdGVyUGxheWVyc01vZHVsZSwgbmFtZUxvb2t1cE1vZHVsZSwgdm9ycERhdGFNb2R1bGUsIGFkcERhdGFNb2R1bGVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGltcG9ydCgnZGF0YS9jb25zb2xpZGF0ZWQvbWFzdGVyLXBsYXllcnMuanNvbicpLFxuICAgICAgICAgICAgICAgIGltcG9ydCgnZGF0YS9jb25zb2xpZGF0ZWQvbmFtZS1sb29rdXAtaW5kZXguanNvbicpLFxuICAgICAgICAgICAgICAgIGltcG9ydCgnZGF0YS9jb25zb2xpZGF0ZWQvcGxheWVyLXZvcnAtc2NvcmVzLmpzb24nKSxcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4uLy4uLy4uL2FkcF9kYXRhLmpzb24nKVxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIExvYWRlZCBtb2R1bGVzOicsIHtcbiAgICAgICAgICAgICAgICBtYXN0ZXJQbGF5ZXJzOiAhIW1hc3RlclBsYXllcnNNb2R1bGUsXG4gICAgICAgICAgICAgICAgbmFtZUxvb2t1cDogISFuYW1lTG9va3VwTW9kdWxlLFxuICAgICAgICAgICAgICAgIHZvcnBEYXRhOiAhIXZvcnBEYXRhTW9kdWxlLFxuICAgICAgICAgICAgICAgIGFkcERhdGE6ICEhYWRwRGF0YU1vZHVsZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBsb29rdXAgYnkgcGxheWVyIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmUpXG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJQbGF5ZXJzID0gKG1hc3RlclBsYXllcnNNb2R1bGUgYXMgYW55KS5kZWZhdWx0LnBsYXllcnM7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBNYXN0ZXIgcGxheWVycyBzdHJ1Y3R1cmU6Jywge1xuICAgICAgICAgICAgICAgIGhhc0RlZmF1bHQ6ICEhKG1hc3RlclBsYXllcnNNb2R1bGUgYXMgYW55KS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIGhhc1BsYXllcnM6ICEhbWFzdGVyUGxheWVycyxcbiAgICAgICAgICAgICAgICBwbGF5ZXJDb3VudDogbWFzdGVyUGxheWVycz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgc2FtcGxlUGxheWVyOiBtYXN0ZXJQbGF5ZXJzPy5bMF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmNvbnNvbGlkYXRlZERhdGEgPSB7fTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbWFzdGVyUGxheWVycy5mb3JFYWNoKChwbGF5ZXI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIuZnVsbF9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGJ5IGJvdGggZnVsbF9uYW1lIGFuZCBwbGF5ZXJfaWQgZm9yIGZsZXhpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc29saWRhdGVkRGF0YVtwbGF5ZXIuZnVsbF9uYW1lLnRvTG93ZXJDYXNlKCldID0gcGxheWVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyLnBsYXllcl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zb2xpZGF0ZWREYXRhW3BsYXllci5wbGF5ZXJfaWQudG9Mb3dlckNhc2UoKV0gPSBwbGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lTG9va3VwSW5kZXggPSAobmFtZUxvb2t1cE1vZHVsZSBhcyBhbnkpLmRlZmF1bHQ7XG4gICAgICAgICAgICB0aGlzLnZvcnBEYXRhID0gKHZvcnBEYXRhTW9kdWxlIGFzIGFueSkuZGVmYXVsdC52b3JwU2NvcmVzIHx8ICh2b3JwRGF0YU1vZHVsZSBhcyBhbnkpLmRlZmF1bHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSBBRFAgbG9va3VwIGJ5IHBsYXllciBuYW1lIC0gYWRwX2RhdGEuanNvbiBoYXMgcGxheWVycyBhcnJheVxuICAgICAgICAgICAgdGhpcy5hZHBEYXRhID0ge307XG4gICAgICAgICAgICBjb25zdCBhZHBQbGF5ZXJzID0gKGFkcERhdGFNb2R1bGUgYXMgYW55KS5kZWZhdWx0LnBsYXllcnMgfHwgW107XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBBRFAgZGF0YSBzdHJ1Y3R1cmU6Jywge1xuICAgICAgICAgICAgICAgIGhhc0RlZmF1bHQ6ICEhKGFkcERhdGFNb2R1bGUgYXMgYW55KS5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIGhhc1BsYXllcnM6ICEhYWRwUGxheWVycyxcbiAgICAgICAgICAgICAgICBwbGF5ZXJDb3VudDogYWRwUGxheWVycz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgc2FtcGxlUGxheWVyOiBhZHBQbGF5ZXJzPy5bMF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhZHBQbGF5ZXJzLmZvckVhY2goKHBsYXllcjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBsYXllci5mdWxsX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHBEYXRhW3BsYXllci5mdWxsX25hbWUudG9Mb3dlckNhc2UoKV0gPSBwbGF5ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRHJhZnQgQW5hbHl6ZXIgaW5pdGlhbGl6ZWQgd2l0aCAke09iamVjdC5rZXlzKHRoaXMuY29uc29saWRhdGVkRGF0YSkubGVuZ3RofSBwbGF5ZXJzIGFuZCAke09iamVjdC5rZXlzKHRoaXMuYWRwRGF0YSkubGVuZ3RofSBBRFAgcmVjb3Jkcy5gKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNhbXBsZSBjb25zb2xpZGF0ZWQgcGxheWVyczpgLCBPYmplY3Qua2V5cyh0aGlzLmNvbnNvbGlkYXRlZERhdGEpLnNsaWNlKDAsIDUpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFNhbXBsZSBBRFAgcGxheWVyczpgLCBPYmplY3Qua2V5cyh0aGlzLmFkcERhdGEpLnNsaWNlKDAsIDUpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBEcmFmdCBBbmFseXplcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIG5lY2Vzc2FyeSBkYXRhIGZvciBhbmFseXNpcy4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZmV0Y2hTbGVlcGVyQXBpKHVybDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZldGNoaW5nIGZyb20gU2xlZXBlciBBUEk6ICR7dXJsfWApO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGZyb20gU2xlZXBlciBBUEk6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFNsZWVwZXIgQVBJIHJlc3BvbnNlOmAsIHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YVR5cGU6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyAnYXJyYXknIDogJ29iamVjdCcsXG4gICAgICAgICAgICBkYXRhTGVuZ3RoOiBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YS5sZW5ndGggOiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGgsXG4gICAgICAgICAgICBzYW1wbGVEYXRhOiBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YS5zbGljZSgwLCAyKSA6IE9iamVjdC5rZXlzKGRhdGEpLnNsaWNlKDAsIDUpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlU2xlZXBlckRyYWZ0VXJsKHVybDogc3RyaW5nKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgYm90aCBzbGVlcGVyLmNvbSBhbmQgc2xlZXBlci5hcHAgZG9tYWlucyBhbmQgYWxwaGFudW1lcmljIGRyYWZ0IElEc1xuICAgICAgICBjb25zdCByZWdleCA9IC9zbGVlcGVyXFwuKD86Y29tfGFwcClcXC9kcmFmdFxcL25mbFxcLyhbYS16QS1aMC05XSspLztcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaFsxXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNsZWVwZXIgbW9jayBkcmFmdCBVUkwgZm9ybWF0LiBFeHBlY3RlZCBmb3JtYXQ6IGh0dHBzOi8vc2xlZXBlci5hcHAvZHJhZnQvbmZsL3tkcmFmdF9pZH0nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBub3JtYWxpemVQbGF5ZXJOYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1vbiBzdWZmaXhlcyBhbmQgbm9ybWFsaXplXG4gICAgICAgIHJldHVybiBuYW1lXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccysoanJcXC4/fHNyXFwuP3xpaXxpaWl8aXZ8dnx2aXx2aWl8dmlpaXxpeHx4KVxccyokL2ksICcnKSAvLyBSZW1vdmUgc3VmZml4ZXNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gTm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIC50cmltKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmaW5kUGxheWVyQnlOYW1lKHBsYXllck5hbWU6IHN0cmluZywgcG9zaXRpb246IHN0cmluZykge1xuICAgICAgICBpZiAoIXBsYXllck5hbWUpIHJldHVybiBudWxsO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSB0aGlzLm5vcm1hbGl6ZVBsYXllck5hbWUocGxheWVyTmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIExvb2tpbmcgZm9yIHBsYXllcjogXCIke3BsYXllck5hbWV9XCIgLT4gbm9ybWFsaXplZDogXCIke25vcm1hbGl6ZWROYW1lfVwiYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaXJzdCB0cnkgZXhhY3QgbWF0Y2ggd2l0aCBub3JtYWxpemVkIG5hbWVcbiAgICAgICAgbGV0IHBsYXllciA9IHRoaXMuY29uc29saWRhdGVkRGF0YVtub3JtYWxpemVkTmFtZV07XG4gICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZXhhY3QgbWF0Y2g6ICR7cGxheWVyTmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBleGFjdCBtYXRjaCB3aXRoIG9yaWdpbmFsIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmUpXG4gICAgICAgIHBsYXllciA9IHRoaXMuY29uc29saWRhdGVkRGF0YVtwbGF5ZXJOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGV4YWN0IG1hdGNoIHdpdGggb3JpZ2luYWwgbmFtZTogJHtwbGF5ZXJOYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IGZ1enp5IG1hdGNoaW5nIGJ5IHJlbW92aW5nIHN1ZmZpeGVzIGFuZCBjaGVja2luZyBwYXJ0aWFsIG1hdGNoZXNcbiAgICAgICAgY29uc3QgbmFtZVBhcnRzID0gbm9ybWFsaXplZE5hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgaWYgKG5hbWVQYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgY29uc3QgZmlyc3ROYW1lID0gbmFtZVBhcnRzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBuYW1lUGFydHNbbmFtZVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBUcnlpbmcgZnV6enkgbWF0Y2g6IGZpcnN0TmFtZT1cIiR7Zmlyc3ROYW1lfVwiLCBsYXN0TmFtZT1cIiR7bGFzdE5hbWV9XCJgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9vayBmb3IgcGxheWVycyB3aXRoIG1hdGNoaW5nIGZpcnN0IGFuZCBsYXN0IG5hbWVcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb25zb2xpZGF0ZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVBhcnRzID0ga2V5LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGtleVBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUZpcnN0TmFtZSA9IGtleVBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlMYXN0TmFtZSA9IGtleVBhcnRzW2tleVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleUZpcnN0TmFtZSA9PT0gZmlyc3ROYW1lICYmIGtleUxhc3ROYW1lID09PSBsYXN0TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBmdXp6eSBtYXRjaDogXCIke3BsYXllck5hbWV9XCIgLT4gXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExhc3QgcmVzb3J0OiB0cnkgdG8gZmluZCBhbnkgcGxheWVyIHdob3NlIG5hbWUgY29udGFpbnMgdGhlIHNlYXJjaCBuYW1lXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb25zb2xpZGF0ZWREYXRhKSkge1xuICAgICAgICAgICAgaWYgKGtleS5pbmNsdWRlcyhub3JtYWxpemVkTmFtZSkgfHwgbm9ybWFsaXplZE5hbWUuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgcGFydGlhbCBtYXRjaDogXCIke3BsYXllck5hbWV9XCIgLT4gXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE5vIG1hdGNoIGZvdW5kIGZvcjogJHtwbGF5ZXJOYW1lfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBBdmFpbGFibGUgcGxheWVycyBzdGFydGluZyB3aXRoIHNpbWlsYXIgbmFtZXM6YCwgXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbnNvbGlkYXRlZERhdGEpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihrID0+IGsuaW5jbHVkZXMobm9ybWFsaXplZE5hbWUuc3BsaXQoJyAnKVswXSkpXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIDUpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UGxheWVyUHJvamVjdGVkUG9pbnRzKHBsYXllck5hbWU6IHN0cmluZywgcG9zaXRpb246IHN0cmluZykge1xuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmZpbmRQbGF5ZXJCeU5hbWUocGxheWVyTmFtZSwgcG9zaXRpb24pO1xuICAgICAgICBpZiAoIXBsYXllciB8fCAhcGxheWVyLnByb2plY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIE5vIHBsYXllciBvciBwcm9qZWN0aW9ucyBmb3VuZCBmb3I6ICR7cGxheWVyTmFtZX0gKCR7cG9zaXRpb259KWApO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb3NLZXkgPSBwb3NpdGlvbj8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gTG9va2luZyBmb3IgcHJvamVjdGlvbnMgZm9yICR7cGxheWVyTmFtZX0gYXQgcG9zaXRpb246ICR7cG9zS2V5fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBBdmFpbGFibGUgcHJvamVjdGlvbiBrZXlzOmAsIE9iamVjdC5rZXlzKHBsYXllci5wcm9qZWN0aW9ucykpO1xuICAgICAgICBcbiAgICAgICAgbGV0IGZwdHMgPSAwO1xuICAgICAgICBcbiAgICAgICAgLy8gSGFuZGxlIGRlZmVuc2UgcHJvamVjdGlvbnMgLSB0cnkgbXVsdGlwbGUgYXBwcm9hY2hlc1xuICAgICAgICBpZiAocG9zS2V5ID09PSAnZGVmJyB8fCBwb3NLZXkgPT09ICdkZWZlbnNlJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfm6HvuI8gUHJvY2Vzc2luZyBERUZFTlNFIHBsYXllcjogJHtwbGF5ZXJOYW1lfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNZXRob2QgMTogVHJ5IGV4YWN0IHBvc2l0aW9uIGtleXNcbiAgICAgICAgICAgIGNvbnN0IGRlZmVuc2VLZXlzID0gWydkZWYnLCAnREVGJywgJ2RlZmVuc2UnLCAnRGVmZW5zZScsICdERUZFTlNFJ107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWZlbnNlS2V5cykge1xuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucHJvamVjdGlvbnNba2V5XT8uZnB0cykge1xuICAgICAgICAgICAgICAgICAgICBmcHRzID0gcGxheWVyLnByb2plY3Rpb25zW2tleV0uZnB0cztcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBkZWZlbnNlIHByb2plY3Rpb25zIHVzaW5nIGtleTogJHtrZXl9ID0gJHtmcHRzfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1ldGhvZCAyOiBUcnkgcGFydGlhbCBrZXkgbWF0Y2hpbmdcbiAgICAgICAgICAgIGlmICghZnB0cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBsYXllci5wcm9qZWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdkZWYnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnB0cyA9IHBsYXllci5wcm9qZWN0aW9uc1trZXldLmZwdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGRlZmVuc2UgcHJvamVjdGlvbnMgdXNpbmcgcGFydGlhbCBrZXk6ICR7a2V5fSA9ICR7ZnB0c31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNZXRob2QgMzogTG9vayBmb3IgYW55IG51bWVyaWMgcHJvamVjdGlvbiB2YWx1ZVxuICAgICAgICAgICAgaWYgKCFmcHRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGxheWVyLnByb2plY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gcGxheWVyLnByb2plY3Rpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uICYmIHR5cGVvZiBwcm9qZWN0aW9uID09PSAnb2JqZWN0JyAmJiBwcm9qZWN0aW9uLmZwdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZwdHMgPSBwcm9qZWN0aW9uLmZwdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGRlZmVuc2UgcHJvamVjdGlvbnMgdXNpbmcgZ2VuZXJpYyBrZXk6ICR7a2V5fSA9ICR7ZnB0c31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNZXRob2QgNDogTG9vayBmb3IgYW55IG51bWVyaWMgdmFsdWUgaW4gcHJvamVjdGlvbnNcbiAgICAgICAgICAgIGlmICghZnB0cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBsYXllci5wcm9qZWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwbGF5ZXIucHJvamVjdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcHRzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGRlZmVuc2UgcHJvamVjdGlvbnMgdXNpbmcgbnVtZXJpYyBrZXk6ICR7a2V5fSA9ICR7ZnB0c31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNZXRob2QgNTogQ2hlY2sgaWYgcHJvamVjdGlvbnMgaXMganVzdCBhIG51bWJlciAoc29tZSBkZWZlbnNlcyBoYXZlIHRoaXMpXG4gICAgICAgICAgICBpZiAoIWZwdHMgJiYgdHlwZW9mIHBsYXllci5wcm9qZWN0aW9ucyA9PT0gJ251bWJlcicgJiYgcGxheWVyLnByb2plY3Rpb25zID4gMCkge1xuICAgICAgICAgICAgICAgIGZwdHMgPSBwbGF5ZXIucHJvamVjdGlvbnM7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBkZWZlbnNlIHByb2plY3Rpb25zIGFzIGRpcmVjdCBudW1iZXI6ICR7ZnB0c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vbi1kZWZlbnNlIHBsYXllcnMgLSB0cnkgc3RhbmRhcmQgYXBwcm9hY2hcbiAgICAgICAgICAgIGZwdHMgPSBwbGF5ZXIucHJvamVjdGlvbnNbcG9zS2V5XT8uZnB0cztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGZwdHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUHJvamVjdGVkIHBvaW50cyBmb3IgJHtwbGF5ZXJOYW1lfTogJHtmcHRzfWApO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmcHRzID09PSAnbnVtYmVyJyA/IGZwdHMgOiBwYXJzZUZsb2F0KGZwdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKdjCBObyBwcm9qZWN0ZWQgcG9pbnRzIGZvdW5kIGZvciAke3BsYXllck5hbWV9IGF0IHBvc2l0aW9uICR7cG9zS2V5fWApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gUGxheWVyIHByb2plY3Rpb25zIHN0cnVjdHVyZTpgLCBwbGF5ZXIucHJvamVjdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFBsYXllckFkcChwbGF5ZXJOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5maW5kUGxheWVyQnlOYW1lKHBsYXllck5hbWUsICcnKTtcbiAgICAgICAgaWYgKCFwbGF5ZXIpIHJldHVybiAwO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgaW4gQURQIGRhdGEgd2l0aCBub3JtYWxpemVkIG5hbWVcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSB0aGlzLm5vcm1hbGl6ZVBsYXllck5hbWUocGxheWVyTmFtZSk7XG4gICAgICAgIGxldCBhZHBQbGF5ZXIgPSB0aGlzLmFkcERhdGFbbm9ybWFsaXplZE5hbWVdO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFhZHBQbGF5ZXIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBmdXp6eSBtYXRjaGluZyBmb3IgQURQIHRvb1xuICAgICAgICAgICAgY29uc3QgbmFtZVBhcnRzID0gbm9ybWFsaXplZE5hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGlmIChuYW1lUGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdE5hbWUgPSBuYW1lUGFydHNbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE5hbWUgPSBuYW1lUGFydHNbbmFtZVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5hZHBEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUZpcnN0TmFtZSA9IGtleVBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5TGFzdE5hbWUgPSBrZXlQYXJ0c1trZXlQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleUZpcnN0TmFtZSA9PT0gZmlyc3ROYW1lICYmIGtleUxhc3ROYW1lID09PSBsYXN0TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkcFBsYXllciA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFkcCA9IGFkcFBsYXllcj8uYWRwX3ZhbHVlO1xuICAgICAgICByZXR1cm4gYWRwID8gcGFyc2VGbG9hdChhZHApIDogMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFBsYXllclZvcnAocGxheWVyTmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gdGhpcy5ub3JtYWxpemVQbGF5ZXJOYW1lKHBsYXllck5hbWUpO1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWROYW1lKSByZXR1cm4gMDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRpcmVjdCA9IEFycmF5LmlzQXJyYXkodGhpcy52b3JwRGF0YSlcbiAgICAgICAgICAgID8gKHRoaXMudm9ycERhdGEgYXMgYW55W10pLmZpbmQoKHA6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBOYW1lID0gdGhpcy5ub3JtYWxpemVQbGF5ZXJOYW1lKHAucGxheWVyTmFtZSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBOYW1lID09PSBub3JtYWxpemVkTmFtZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGRpcmVjdD8udm9ycF9zY29yZSB8fCBkaXJlY3Q/LnZvcnBTY29yZSA/IHBhcnNlRmxvYXQoZGlyZWN0LnZvcnBfc2NvcmUgfHwgZGlyZWN0LnZvcnBTY29yZSkgOiAwO1xuICAgIH1cblxuICAgIGFzeW5jIGFuYWx5emVEcmFmdChkcmFmdFVybDogc3RyaW5nLCBsZWFndWVUeXBlOiBzdHJpbmcgPSAnc3RhbmRhcmQnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRmV0Y2hpbmcgZHJhZnQgZGF0YSBmcm9tIFNsZWVwZXIuLi4nKTtcbiAgICAgICAgY29uc3QgZHJhZnRJZCA9IHRoaXMucGFyc2VTbGVlcGVyRHJhZnRVcmwoZHJhZnRVcmwpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmV0Y2ggZHJhZnQgZGF0YVxuICAgICAgICBjb25zdCBkcmFmdERhdGEgPSBhd2FpdCB0aGlzLmZldGNoU2xlZXBlckFwaShgaHR0cHM6Ly9hcGkuc2xlZXBlci5hcHAvdjEvZHJhZnQvJHtkcmFmdElkfWApO1xuICAgICAgICBjb25zdCBkcmFmdFBpY2tzID0gYXdhaXQgdGhpcy5mZXRjaFNsZWVwZXJBcGkoYGh0dHBzOi8vYXBpLnNsZWVwZXIuYXBwL3YxL2RyYWZ0LyR7ZHJhZnRJZH0vcGlja3M/bGltaXQ9MTAwMGApO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogRHJhZnQgZGF0YSBmZXRjaGVkOicsIHtcbiAgICAgICAgICAgIGRyYWZ0TmFtZTogZHJhZnREYXRhLm5hbWUsXG4gICAgICAgICAgICB0ZWFtczogZHJhZnREYXRhLnRlYW1zPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIHJvdW5kczogZHJhZnREYXRhLnNldHRpbmdzPy5yb3VuZHMgfHwgMCxcbiAgICAgICAgICAgIHBpY2tzOiBkcmFmdFBpY2tzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGV4cGVjdGVkUGlja3M6IChkcmFmdERhdGEudGVhbXM/Lmxlbmd0aCB8fCAwKSAqIChkcmFmdERhdGEuc2V0dGluZ3M/LnJvdW5kcyB8fCAwKVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3MgZHJhZnQgcGlja3MgYW5kIGJ1aWxkIHRlYW0gcm9zdGVyc1xuICAgICAgICBjb25zdCB0ZWFtcyA9IGF3YWl0IHRoaXMuYnVpbGRUZWFtUm9zdGVycyhkcmFmdERhdGEsIGRyYWZ0UGlja3MpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9wdGltYWwgbGluZXVwcyBhbmQgZ3JhZGVzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYW5hbHl6ZVRlYW1zKHRlYW1zLCBsZWFndWVUeXBlKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkcmFmdEluZm86IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBkcmFmdERhdGEubmFtZSxcbiAgICAgICAgICAgICAgICB0ZWFtczogZHJhZnREYXRhLnRlYW1zPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgICByb3VuZHM6IGRyYWZ0RGF0YS5zZXR0aW5ncz8ucm91bmRzIHx8IDAsXG4gICAgICAgICAgICAgICAgdG90YWxQaWNrczogZHJhZnRQaWNrcz8ubGVuZ3RoIHx8IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5yZXN1bHRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFuYWx5emVUZWFtcyh0ZWFtczogYW55LCBsZWFndWVUeXBlOiBzdHJpbmcgPSAnc3RhbmRhcmQnKSB7XG4gICAgICAgIGNvbnN0IGxpbmV1cEVuZ2luZSA9IG5ldyBPcHRpbWFsTGluZXVwRW5naW5lKCk7XG4gICAgICAgIGNvbnN0IGdyYWRlRW5naW5lID0gbmV3IFBvc2l0aW9uR3JhZGVFbmdpbmUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBhY3R1YWwgZHJhZnQgZGltZW5zaW9ucyBmcm9tIHRoZSB0ZWFtcyBkYXRhXG4gICAgICAgIGNvbnN0IGFjdHVhbFRlYW1zID0gT2JqZWN0LmtleXModGVhbXMpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYWN0dWFsUm91bmRzID0gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyh0ZWFtcykubWFwKCh0ZWFtOiBhbnkpID0+IFxuICAgICAgICAgICAgTWF0aC5tYXgoLi4uKHRlYW0ucm9zdGVyIHx8IFtdKS5tYXAoKHA6IGFueSkgPT4gcC5yb3VuZCB8fCAwKSlcbiAgICAgICAgKSwgMTYpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogRHJhZnQgZGltZW5zaW9uczonLCB7IGFjdHVhbFRlYW1zLCBhY3R1YWxSb3VuZHMgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaXJzdCBjYWxjdWxhdGUgb3B0aW1hbCBsaW5ldXBzIGZvciBhbGwgdGVhbXNcbiAgICAgICAgY29uc3QgYW5hbHlzaXNUZWFtcyA9IE9iamVjdC5lbnRyaWVzKHRlYW1zKS5tYXAoKFtpZCwgdGVhbV06IFtzdHJpbmcsIGFueV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmV1cCA9IGxpbmV1cEVuZ2luZS5jYWxjdWxhdGVPcHRpbWFsTGluZXVwKHRlYW0ucm9zdGVyLCB7IFxuICAgICAgICAgICAgICAgIGxlYWd1ZVR5cGUsIFxuICAgICAgICAgICAgICAgIHNjb3Jpbmc6ICdwcHInLFxuICAgICAgICAgICAgICAgIHRlYW1zOiBhY3R1YWxUZWFtcyxcbiAgICAgICAgICAgICAgICByb3VuZHM6IGFjdHVhbFJvdW5kc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIEFEUFxuICAgICAgICAgICAgY29uc3QgYWRwVmFsdWVzID0gdGVhbS5yb3N0ZXIubWFwKChwOiBhbnkpID0+IHAuYWRwVmFsdWUgfHwgMCkuZmlsdGVyKCh2OiBudW1iZXIpID0+IHYgIT09IDApO1xuICAgICAgICAgICAgY29uc3QgYXZlcmFnZUFkcFZhbHVlID0gYWRwVmFsdWVzLmxlbmd0aCA+IDAgPyBhZHBWYWx1ZXMucmVkdWNlKChzOiBudW1iZXIsIHY6IG51bWJlcikgPT4gcyArIHYsIDApIC8gYWRwVmFsdWVzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIFZPUlBcbiAgICAgICAgICAgIGNvbnN0IHZvcnBWYWx1ZXMgPSB0ZWFtLnJvc3Rlci5tYXAoKHA6IGFueSkgPT4gcC52b3JwU2NvcmUgfHwgMCkuZmlsdGVyKCh2OiBudW1iZXIpID0+IHYgIT09IDApO1xuICAgICAgICAgICAgY29uc3QgYXZlcmFnZVZvcnBTY29yZSA9IHZvcnBWYWx1ZXMubGVuZ3RoID4gMCA/IHZvcnBWYWx1ZXMucmVkdWNlKChzOiBudW1iZXIsIHY6IG51bWJlcikgPT4gcyArIHYsIDApIC8gdm9ycFZhbHVlcy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgb3B0aW1hbCBsaW5ldXAgcG9pbnRzXG4gICAgICAgICAgICBjb25zdCBvcHRpbWFsTGluZXVwUG9pbnRzID0gbGluZXVwRW5naW5lLmNhbGN1bGF0ZVRvdGFsUHJvamVjdGVkUG9pbnRzKGxpbmV1cCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdldCBiZW5jaCBwbGF5ZXJzIGFuZCBwb2ludHNcbiAgICAgICAgICAgIGNvbnN0IGJlbmNoUGxheWVycyA9IGxpbmV1cEVuZ2luZS5nZXRCZW5jaFBsYXllcnModGVhbS5yb3N0ZXIsIGxpbmV1cCk7XG4gICAgICAgICAgICBjb25zdCBiZW5jaFBvaW50cyA9IGxpbmV1cEVuZ2luZS5jYWxjdWxhdGVUb3RhbFByb2plY3RlZFBvaW50cyhiZW5jaFBsYXllcnMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZXQgbGluZXVwIGFuYWx5c2lzXG4gICAgICAgICAgICBjb25zdCBsaW5ldXBBbmFseXNpcyA9IGxpbmV1cEVuZ2luZS5hbmFseXplTGluZXVwKGxpbmV1cCwgeyBcbiAgICAgICAgICAgICAgICBsZWFndWVUeXBlLCBcbiAgICAgICAgICAgICAgICBzY29yaW5nOiAncHByJyxcbiAgICAgICAgICAgICAgICB0ZWFtczogT2JqZWN0LmtleXModGVhbXMpLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBpZCxcbiAgICAgICAgICAgICAgICB0ZWFtTmFtZTogdGVhbS50ZWFtTmFtZSxcbiAgICAgICAgICAgICAgICBkcmFmdFNsb3Q6IHRlYW0uZHJhZnRTbG90LFxuICAgICAgICAgICAgICAgIHJvc3RlcjogdGVhbS5yb3N0ZXIsXG4gICAgICAgICAgICAgICAgb3B0aW1hbExpbmV1cDogbGluZXVwLFxuICAgICAgICAgICAgICAgIG9wdGltYWxMaW5ldXBQb2ludHMsXG4gICAgICAgICAgICAgICAgYmVuY2hQbGF5ZXJzLFxuICAgICAgICAgICAgICAgIGJlbmNoUG9pbnRzLFxuICAgICAgICAgICAgICAgIHRvdGFsUHJvamVjdGVkUG9pbnRzOiBvcHRpbWFsTGluZXVwUG9pbnRzICsgYmVuY2hQb2ludHMsXG4gICAgICAgICAgICAgICAgYXZlcmFnZUFkcFZhbHVlLFxuICAgICAgICAgICAgICAgIGF2ZXJhZ2VWb3JwU2NvcmUsXG4gICAgICAgICAgICAgICAgbGluZXVwQW5hbHlzaXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5vdyBjYWxjdWxhdGUgcG9zaXRpb24gZ3JhZGVzIHVzaW5nIHRoZSB0ZWFtcyB3aXRoIG9wdGltYWwgbGluZXVwc1xuICAgICAgICBjb25zdCBncmFkZWRUZWFtcyA9IGdyYWRlRW5naW5lLmNhbGN1bGF0ZVBvc2l0aW9uR3JhZGVzKGFuYWx5c2lzVGVhbXMsIHsgXG4gICAgICAgICAgICBsZWFndWVUeXBlLCBcbiAgICAgICAgICAgIHNjb3Jpbmc6ICdwcHInLFxuICAgICAgICAgICAgdGVhbXM6IE9iamVjdC5rZXlzKHRlYW1zKS5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTWFwIHRoZSBncmFkZWQgdGVhbXMgYmFjayB0byB0aGUgZXhwZWN0ZWQgZm9ybWF0IGZvciB0aGUgZnJvbnRlbmRcbiAgICAgICAgY29uc3QgZmluYWxUZWFtcyA9IGdyYWRlZFRlYW1zLm1hcChncmFkZWRUZWFtID0+IHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG9yaWdpbmFsIGFuYWx5c2lzIHRlYW0gZGF0YVxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUZWFtID0gYW5hbHlzaXNUZWFtcy5maW5kKHQgPT4gdC50ZWFtSWQgPT09IGdyYWRlZFRlYW0udGVhbUlkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IGdyYWRlZFRlYW0udGVhbUlkLFxuICAgICAgICAgICAgICAgIHRlYW1OYW1lOiBncmFkZWRUZWFtLnRlYW1OYW1lLFxuICAgICAgICAgICAgICAgIGRyYWZ0U2xvdDogb3JpZ2luYWxUZWFtPy5kcmFmdFNsb3QgfHwgMCxcbiAgICAgICAgICAgICAgICBvcHRpbWFsTGluZXVwOiBvcmlnaW5hbFRlYW0/Lm9wdGltYWxMaW5ldXAgfHwge30sXG4gICAgICAgICAgICAgICAgb3B0aW1hbExpbmV1cFBvaW50czogb3JpZ2luYWxUZWFtPy5vcHRpbWFsTGluZXVwUG9pbnRzIHx8IDAsXG4gICAgICAgICAgICAgICAgYmVuY2hQbGF5ZXJzOiBvcmlnaW5hbFRlYW0/LmJlbmNoUGxheWVycyB8fCBbXSxcbiAgICAgICAgICAgICAgICBiZW5jaFBvaW50czogb3JpZ2luYWxUZWFtPy5iZW5jaFBvaW50cyB8fCAwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uR3JhZGVzOiBncmFkZWRUZWFtLnBvc2l0aW9uR3JhZGVzIHx8IHt9LFxuICAgICAgICAgICAgICAgIG92ZXJhbGxHcmFkZTogZ3JhZGVkVGVhbS5vdmVyYWxsR3JhZGUgfHwgeyBncmFkZTogJ+KAlCcsIHNjb3JlOiAwIH0sXG4gICAgICAgICAgICAgICAgdG90YWxQcm9qZWN0ZWRQb2ludHM6IChvcmlnaW5hbFRlYW0/Lm9wdGltYWxMaW5ldXBQb2ludHMgfHwgMCkgKyAob3JpZ2luYWxUZWFtPy5iZW5jaFBvaW50cyB8fCAwKSxcbiAgICAgICAgICAgICAgICBhdmVyYWdlUHJvamVjdGVkUG9pbnRzOiAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsVGVhbT8ucm9zdGVyPy5sZW5ndGgpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxUZWFtLnJvc3Rlci5yZWR1Y2UoKHN1bTogbnVtYmVyLCBwOiBhbnkpID0+IHN1bSArIChwLnByb2plY3RlZFBvaW50cyB8fCAwKSwgMCkgLyBvcmlnaW5hbFRlYW0ucm9zdGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgICAgIGF2ZXJhZ2VBZHBWYWx1ZTogb3JpZ2luYWxUZWFtPy5hdmVyYWdlQWRwVmFsdWUgfHwgMCxcbiAgICAgICAgICAgICAgICBhdmVyYWdlVm9ycFNjb3JlOiBvcmlnaW5hbFRlYW0/LmF2ZXJhZ2VWb3JwU2NvcmUgfHwgMCxcbiAgICAgICAgICAgICAgICBwbGF5ZXJzOiBvcmlnaW5hbFRlYW0/LnJvc3RlciB8fCBbXSxcbiAgICAgICAgICAgICAgICByb3N0ZXI6IG9yaWdpbmFsVGVhbT8ucm9zdGVyIHx8IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5hbHlzaXM6IHtcbiAgICAgICAgICAgICAgICB0ZWFtczogZmluYWxUZWFtcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBidWlsZFRlYW1Sb3N0ZXJzKGRyYWZ0RGF0YTogYW55LCBkcmFmdFBpY2tzOiBhbnkpIHtcbiAgICAgICAgY29uc3Qgc2xvdFRvUm9zdGVySWQgPSBkcmFmdERhdGEuc2xvdF90b19yb3N0ZXJfaWQgYXMgeyBbc2xvdDogc3RyaW5nXTogbnVtYmVyIH07XG4gICAgICAgIGlmICghc2xvdFRvUm9zdGVySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2xvdF90b19yb3N0ZXJfaWQgZm91bmQgaW4gZHJhZnQgZGF0YSAtIHRoaXMgbWF5IG5vdCBiZSBhIG1vY2sgZHJhZnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNsb3RUb05hbWU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNNQVJUIFVTRVJOQU1FIERFVEVDVElPTiAtIERvbid0IHJlbHkgb24gZmFpbGluZyBlbmRwb2ludHNcbiAgICAgICAgaWYgKGRyYWZ0RGF0YS5tZXRhZGF0YT8uZHJhZnRfb3JkZXJfYnlfcm9zdGVyX2lkKSB7XG4gICAgICAgICAgICAvLyBVc2UgbWV0YWRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkcmFmdERhdGEubWV0YWRhdGEuZHJhZnRfb3JkZXJfYnlfcm9zdGVyX2lkKS5mb3JFYWNoKChbcm9zdGVySWQsIHNsb3RdOiBbc3RyaW5nLCBhbnldKSA9PiB7XG4gICAgICAgICAgICAgICAgc2xvdFRvTmFtZVtzbG90XSA9IGBUZWFtICR7cGFyc2VJbnQocm9zdGVySWQpICsgMX1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzbG90IG51bWJlcnNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNsb3RUb1Jvc3RlcklkKS5mb3JFYWNoKHNsb3QgPT4ge1xuICAgICAgICAgICAgICAgIHNsb3RUb05hbWVbc2xvdF0gPSBgVGVhbSAke3BhcnNlSW50KHNsb3QpICsgMX1gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGZXRjaCBORkwgcGxheWVycyBkYXRhXG4gICAgICAgIGNvbnN0IHBsYXllcnNNYXA6IGFueSA9IGF3YWl0IHRoaXMuZmV0Y2hTbGVlcGVyQXBpKGBodHRwczovL2FwaS5zbGVlcGVyLmFwcC92MS9wbGF5ZXJzL25mbGApO1xuICAgICAgICBjb25zdCBnZXRTbGVlcGVyUGxheWVyID0gKGlkOiBzdHJpbmcpID0+IHBsYXllcnNNYXA/LltpZF07XG5cbiAgICAgICAgY29uc3QgdGVhbXM6IHsgW3Jvc3RlcklkOiBudW1iZXJdOiBhbnkgfSA9IHt9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBwaWNrIGFuZCBidWlsZCB0ZWFtIHJvc3RlcnNcbiAgICAgICAgZHJhZnRQaWNrcy5mb3JFYWNoKChwaWNrOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBwaWNrLnBpY2tfbm8udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHJvc3RlcklkID0gc2xvdFRvUm9zdGVySWRbc2xvdF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcm9zdGVySWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYE5vIHJvc3RlciBJRCBmb3VuZCBmb3Igc2xvdCAke3Nsb3R9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRlYW1zW3Jvc3RlcklkXSkge1xuICAgICAgICAgICAgICAgIHRlYW1zW3Jvc3RlcklkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGVhbUlkOiByb3N0ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgdGVhbU5hbWU6IHNsb3RUb05hbWVbc2xvdF0gfHwgYFRlYW0gJHtyb3N0ZXJJZH1gLFxuICAgICAgICAgICAgICAgICAgICBkcmFmdFNsb3Q6IHBhcnNlSW50KHNsb3QpLFxuICAgICAgICAgICAgICAgICAgICByb3N0ZXI6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IHBsYXllciBkYXRhXG4gICAgICAgICAgICBjb25zdCBzbGVlcGVyUGxheWVyID0gZ2V0U2xlZXBlclBsYXllcihwaWNrLnBsYXllcl9pZCk7XG4gICAgICAgICAgICBpZiAoIXNsZWVwZXJQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYE5vIHBsYXllciBkYXRhIGZvdW5kIGZvciBJRCAke3BpY2sucGxheWVyX2lkfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRW5oYW5jZSBwbGF5ZXIgZGF0YSB3aXRoIHByb2plY3Rpb25zIGFuZCBWT1JQXG4gICAgICAgICAgICBjb25zdCBlbmhhbmNlZFBsYXllciA9IHRoaXMuZW5oYW5jZVBsYXllckRhdGEoc2xlZXBlclBsYXllciwgcGljayk7XG4gICAgICAgICAgICB0ZWFtc1tyb3N0ZXJJZF0ucm9zdGVyLnB1c2goZW5oYW5jZWRQbGF5ZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGVhbXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbmhhbmNlUGxheWVyRGF0YShzbGVlcGVyUGxheWVyOiBhbnksIHBpY2s6IGFueSkge1xuICAgICAgICBjb25zdCBwbGF5ZXJOYW1lOiBzdHJpbmcgPSBzbGVlcGVyUGxheWVyLmZ1bGxfbmFtZSB8fCBgJHtzbGVlcGVyUGxheWVyLmZpcnN0X25hbWUgfHwgJyd9ICR7c2xlZXBlclBsYXllci5sYXN0X25hbWUgfHwgJyd9YC50cmltKCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uOiBzdHJpbmcgPSBzbGVlcGVyUGxheWVyLnBvc2l0aW9uIHx8IHBpY2subWV0YWRhdGE/LnBvc2l0aW9uIHx8ICcnO1xuXG4gICAgICAgIGNvbnN0IHByb2plY3RlZFBvaW50cyA9IHRoaXMuZ2V0UGxheWVyUHJvamVjdGVkUG9pbnRzKHBsYXllck5hbWUsIHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgYWRwVmFsdWUgPSB0aGlzLmdldFBsYXllckFkcChwbGF5ZXJOYW1lKTtcbiAgICAgICAgY29uc3Qgdm9ycFNjb3JlID0gdGhpcy5nZXRQbGF5ZXJWb3JwKHBsYXllck5hbWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRyYWZ0IHZhbHVlOiBuZWdhdGl2ZSBtZWFucyBwbGF5ZXIgd2FzIGRyYWZ0ZWQgYWJvdmUgQURQIChnb29kIHZhbHVlKVxuICAgICAgICBjb25zdCBkcmFmdFZhbHVlID0gYWRwVmFsdWUgPiAwID8gKGFkcFZhbHVlIC0gcGljay5kcmFmdF9zbG90KSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBpY2ssXG4gICAgICAgICAgICBtZXRhZGF0YTogc2xlZXBlclBsYXllcixcbiAgICAgICAgICAgIHBsYXllck5hbWUsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50cyxcbiAgICAgICAgICAgIGFkcFZhbHVlLFxuICAgICAgICAgICAgdm9ycFNjb3JlLFxuICAgICAgICAgICAgZHJhZnRWYWx1ZSxcbiAgICAgICAgICAgIHBsYXllcklkOiBwaWNrLnBsYXllcl9pZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IFJlcXVlc3QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRyYWZ0VXJsLCBsZWFndWVUeXBlID0gJ3N0YW5kYXJkJyB9ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWRyYWZ0VXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdEcmFmdCBVUkwgaXMgcmVxdWlyZWQnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/CfmoAgU3RhcnRpbmcgZHJhZnQgYW5hbHlzaXMuLi4nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRHJhZnQgVVJMOicsIGRyYWZ0VXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfj4ggTGVhZ3VlIFR5cGU6JywgbGVhZ3VlVHlwZSk7XG5cbiAgICAgICAgY29uc3QgYW5hbHl6ZXIgPSBuZXcgRHJhZnRBbmFseXplcigpO1xuICAgICAgICBhd2FpdCBhbmFseXplci5pbml0aWFsaXplKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplRHJhZnQoZHJhZnRVcmwsIGxlYWd1ZVR5cGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBkcmFmdCBhbmFseXNpczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnIFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBHRVQoKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXCJNZXRob2QgTm90IEFsbG93ZWRcIiwgeyBzdGF0dXM6IDQwNSwgaGVhZGVyczogeyBBbGxvdzogXCJQT1NUXCIgfSB9KTtcbn0gIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJOZXh0UmVzcG9uc2UiLCJPcHRpbWFsTGluZXVwRW5naW5lIiwiUG9zaXRpb25HcmFkZUVuZ2luZSIsIkRyYWZ0QW5hbHl6ZXIiLCJpbml0aWFsaXplIiwiY29uc29sZSIsImxvZyIsIm1hc3RlclBsYXllcnNNb2R1bGUiLCJuYW1lTG9va3VwTW9kdWxlIiwidm9ycERhdGFNb2R1bGUiLCJhZHBEYXRhTW9kdWxlIiwiUHJvbWlzZSIsImFsbCIsIm1hc3RlclBsYXllcnMiLCJuYW1lTG9va3VwIiwidm9ycERhdGEiLCJhZHBEYXRhIiwiZGVmYXVsdCIsInBsYXllcnMiLCJoYXNEZWZhdWx0IiwiaGFzUGxheWVycyIsInBsYXllckNvdW50IiwibGVuZ3RoIiwic2FtcGxlUGxheWVyIiwiY29uc29saWRhdGVkRGF0YSIsImZvckVhY2giLCJwbGF5ZXIiLCJmdWxsX25hbWUiLCJ0b0xvd2VyQ2FzZSIsInBsYXllcl9pZCIsIm5hbWVMb29rdXBJbmRleCIsInZvcnBTY29yZXMiLCJhZHBQbGF5ZXJzIiwiT2JqZWN0Iiwia2V5cyIsInNsaWNlIiwiZXJyb3IiLCJFcnJvciIsImZldGNoU2xlZXBlckFwaSIsInVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsInN0YXR1cyIsImRhdGFUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiZGF0YUxlbmd0aCIsInNhbXBsZURhdGEiLCJwYXJzZVNsZWVwZXJEcmFmdFVybCIsInJlZ2V4IiwibWF0Y2giLCJub3JtYWxpemVQbGF5ZXJOYW1lIiwibmFtZSIsInJlcGxhY2UiLCJ0cmltIiwiZmluZFBsYXllckJ5TmFtZSIsInBsYXllck5hbWUiLCJwb3NpdGlvbiIsIm5vcm1hbGl6ZWROYW1lIiwibmFtZVBhcnRzIiwic3BsaXQiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImtleSIsImVudHJpZXMiLCJrZXlQYXJ0cyIsImtleUZpcnN0TmFtZSIsImtleUxhc3ROYW1lIiwiaW5jbHVkZXMiLCJmaWx0ZXIiLCJrIiwiZ2V0UGxheWVyUHJvamVjdGVkUG9pbnRzIiwicHJvamVjdGlvbnMiLCJwb3NLZXkiLCJmcHRzIiwiZGVmZW5zZUtleXMiLCJwcm9qZWN0aW9uIiwidmFsdWUiLCJwYXJzZUZsb2F0IiwiZ2V0UGxheWVyQWRwIiwiYWRwUGxheWVyIiwiYWRwIiwiYWRwX3ZhbHVlIiwiZ2V0UGxheWVyVm9ycCIsImRpcmVjdCIsImZpbmQiLCJwIiwicE5hbWUiLCJ1bmRlZmluZWQiLCJ2b3JwX3Njb3JlIiwidm9ycFNjb3JlIiwiYW5hbHl6ZURyYWZ0IiwiZHJhZnRVcmwiLCJsZWFndWVUeXBlIiwiZHJhZnRJZCIsImRyYWZ0RGF0YSIsImRyYWZ0UGlja3MiLCJkcmFmdE5hbWUiLCJ0ZWFtcyIsInJvdW5kcyIsInNldHRpbmdzIiwicGlja3MiLCJleHBlY3RlZFBpY2tzIiwiYnVpbGRUZWFtUm9zdGVycyIsInJlc3VsdCIsImFuYWx5emVUZWFtcyIsImRyYWZ0SW5mbyIsInRvdGFsUGlja3MiLCJsaW5ldXBFbmdpbmUiLCJncmFkZUVuZ2luZSIsImFjdHVhbFRlYW1zIiwiYWN0dWFsUm91bmRzIiwiTWF0aCIsIm1heCIsInZhbHVlcyIsIm1hcCIsInRlYW0iLCJyb3N0ZXIiLCJyb3VuZCIsImFuYWx5c2lzVGVhbXMiLCJpZCIsImxpbmV1cCIsImNhbGN1bGF0ZU9wdGltYWxMaW5ldXAiLCJzY29yaW5nIiwiYWRwVmFsdWVzIiwiYWRwVmFsdWUiLCJ2IiwiYXZlcmFnZUFkcFZhbHVlIiwicmVkdWNlIiwicyIsInZvcnBWYWx1ZXMiLCJhdmVyYWdlVm9ycFNjb3JlIiwib3B0aW1hbExpbmV1cFBvaW50cyIsImNhbGN1bGF0ZVRvdGFsUHJvamVjdGVkUG9pbnRzIiwiYmVuY2hQbGF5ZXJzIiwiZ2V0QmVuY2hQbGF5ZXJzIiwiYmVuY2hQb2ludHMiLCJsaW5ldXBBbmFseXNpcyIsImFuYWx5emVMaW5ldXAiLCJ0ZWFtSWQiLCJ0ZWFtTmFtZSIsImRyYWZ0U2xvdCIsIm9wdGltYWxMaW5ldXAiLCJ0b3RhbFByb2plY3RlZFBvaW50cyIsImdyYWRlZFRlYW1zIiwiY2FsY3VsYXRlUG9zaXRpb25HcmFkZXMiLCJmaW5hbFRlYW1zIiwiZ3JhZGVkVGVhbSIsIm9yaWdpbmFsVGVhbSIsInQiLCJwb3NpdGlvbkdyYWRlcyIsIm92ZXJhbGxHcmFkZSIsImdyYWRlIiwic2NvcmUiLCJhdmVyYWdlUHJvamVjdGVkUG9pbnRzIiwic3VtIiwicHJvamVjdGVkUG9pbnRzIiwiYW5hbHlzaXMiLCJzbG90VG9Sb3N0ZXJJZCIsInNsb3RfdG9fcm9zdGVyX2lkIiwic2xvdFRvTmFtZSIsIm1ldGFkYXRhIiwiZHJhZnRfb3JkZXJfYnlfcm9zdGVyX2lkIiwicm9zdGVySWQiLCJzbG90IiwicGFyc2VJbnQiLCJwbGF5ZXJzTWFwIiwiZ2V0U2xlZXBlclBsYXllciIsInBpY2siLCJwaWNrX25vIiwidG9TdHJpbmciLCJ3YXJuIiwic2xlZXBlclBsYXllciIsImVuaGFuY2VkUGxheWVyIiwiZW5oYW5jZVBsYXllckRhdGEiLCJwdXNoIiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImRyYWZ0VmFsdWUiLCJkcmFmdF9zbG90IiwicGxheWVySWQiLCJwbGF5ZXJEZXRhaWxzIiwiUE9TVCIsInJlcXVlc3QiLCJzdWNjZXNzIiwiYW5hbHl6ZXIiLCJtZXNzYWdlIiwiR0VUIiwiUmVzcG9uc2UiLCJoZWFkZXJzIiwiQWxsb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/analyze-draft/route.ts\n");

/***/ }),

/***/ "(rsc)/./app/lib/optimal-lineup-engine.ts":
/*!******************************************!*\
  !*** ./app/lib/optimal-lineup-engine.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OptimalLineupEngine)\n/* harmony export */ });\nclass OptimalLineupEngine {\n    getRosterRequirements(leagueType = \"standard\", actualTeams = 12, actualRounds = 16) {\n        // Fixed starter requirements - bench size scales with rounds, not starters\n        const baseRequirements = {\n            standard: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            superflex: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"QB\",\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2qb\": {\n                QB: 2,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2flex\": {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 2,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            }\n        };\n        const requirements = baseRequirements[leagueType] || baseRequirements.standard;\n        // Calculate total starters (fixed, doesn't change with rounds)\n        const totalStarters = Object.entries(requirements).filter(([key])=>![\n                \"flexPositions\",\n                \"superflexPositions\"\n            ].includes(key)).reduce((sum, [_, count])=>sum + (typeof count === \"number\" ? count : 0), 0);\n        return {\n            ...requirements,\n            totalStarters,\n            // Add metadata about the dynamic calculation\n            _metadata: {\n                actualTeams,\n                actualRounds,\n                leagueType,\n                calculatedAt: new Date().toISOString()\n            }\n        };\n    }\n    calculateOptimalLineup(roster, settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const actualTeams = settings.teams || 12;\n        const actualRounds = settings.rounds || 16; // Get actual rounds from settings\n        // Calculate roster requirements based on actual draft data\n        const requirements = this.getRosterRequirements(leagueType, actualTeams, actualRounds);\n        console.log(\"\\uD83D\\uDD0D Calculating optimal lineup:\", {\n            leagueType,\n            actualTeams,\n            actualRounds,\n            requirements: {\n                ...requirements,\n                _metadata: requirements._metadata\n            }\n        });\n        // Group players by position\n        const positionGroups = this.groupPlayersByPosition(roster);\n        // Start building optimal lineup\n        const optimalLineup = {};\n        const usedPlayers = new Set();\n        console.log(\"\\uD83D\\uDD0D Filling required positions...\");\n        // Fill required positions first (excluding special positions)\n        Object.entries(requirements).forEach(([position, count])=>{\n            if (position === \"totalStarters\" || position === \"flexPositions\" || position === \"superflexPositions\") return;\n            console.log(`üîç Processing position: ${position}, count: ${count}`);\n            if (typeof count === \"number\" && count > 0) {\n                optimalLineup[position] = [];\n                // Get best players for this position\n                const availablePlayers = positionGroups[position] || [];\n                console.log(`üîç Available players for ${position}:`, availablePlayers);\n                const sortedPlayers = availablePlayers.filter((p)=>!usedPlayers.has(p.playerId || p.playerName)).sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0)).slice(0, count);\n                console.log(`üîç Selected players for ${position}:`, sortedPlayers);\n                optimalLineup[position] = sortedPlayers;\n                sortedPlayers.forEach((p)=>usedPlayers.add(p.playerId || p.playerName));\n            }\n        });\n        // Handle FLEX position\n        if (requirements.flexPositions) {\n            const flexPlayers = requirements.flexPositions.flatMap((pos)=>(positionGroups[pos] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName)));\n            if (flexPlayers.length > 0) {\n                const bestFlexPlayer = flexPlayers.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n                if (bestFlexPlayer) {\n                    optimalLineup.FLEX = [\n                        bestFlexPlayer\n                    ];\n                    usedPlayers.add(bestFlexPlayer.playerId || bestFlexPlayer.playerName);\n                    // Log which type of flex this is\n                    if (leagueType === \"superflex\") {\n                        console.log(`ü¶∏ Superflex FLEX: Selected ${bestFlexPlayer.position} ${bestFlexPlayer.playerName} with ${bestFlexPlayer.projectedPoints} points`);\n                    } else {\n                        console.log(`üîÑ Standard FLEX: Selected ${bestFlexPlayer.position} ${bestFlexPlayer.playerName} with ${bestFlexPlayer.projectedPoints} points`);\n                    }\n                }\n            }\n        }\n        // Handle 2 FLEX positions (if applicable)\n        if (leagueType === \"2flex\" && requirements.FLEX === 2) {\n            optimalLineup.FLEX = [];\n            // Fill first flex spot\n            const bestFlexPlayer1 = this.findBestFlexPlayer(positionGroups, usedPlayers);\n            if (bestFlexPlayer1) {\n                optimalLineup.FLEX.push(bestFlexPlayer1);\n                usedPlayers.add(bestFlexPlayer1.playerId || bestFlexPlayer1.playerName);\n                console.log(`üîÑ FLEX 1: Selected ${bestFlexPlayer1.position} ${bestFlexPlayer1.playerName} with ${bestFlexPlayer1.projectedPoints} points`);\n            }\n            // Fill second flex spot\n            const bestFlexPlayer2 = this.findBestFlexPlayer(positionGroups, usedPlayers);\n            if (bestFlexPlayer2) {\n                optimalLineup.FLEX.push(bestFlexPlayer2);\n                usedPlayers.add(bestFlexPlayer2.playerId || bestFlexPlayer2.playerName);\n                console.log(`üîÑ FLEX 2: Selected ${bestFlexPlayer2.position} ${bestFlexPlayer2.playerName} with ${bestFlexPlayer2.projectedPoints} points`);\n            }\n        }\n        // Ensure all required positions have at least an empty array\n        Object.entries(requirements).forEach(([position, count])=>{\n            if (position === \"totalStarters\" || position === \"flexPositions\" || position === \"superflexPositions\") return;\n            if (typeof count === \"number\" && count > 0 && !optimalLineup[position]) {\n                optimalLineup[position] = [];\n            }\n        });\n        return optimalLineup;\n    }\n    findBestSuperflexPlayer(positionGroups, usedPlayers) {\n        // Get all available superflex eligible players\n        const availableQBs = (positionGroups[\"QB\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableRBs = (positionGroups[\"RB\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableWRs = (positionGroups[\"WR\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableTEs = (positionGroups[\"TE\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        // In superflex, QBs are extremely valuable - give them priority\n        let bestSuperflexPlayer = null;\n        // First priority: Best available QB (QBs score much higher than other positions)\n        if (availableQBs.length > 0) {\n            const bestQB = availableQBs.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            bestSuperflexPlayer = bestQB;\n        }\n        // If no QBs available, select best RB/WR/TE\n        if (!bestSuperflexPlayer) {\n            const otherPlayers = [\n                ...availableRBs,\n                ...availableWRs,\n                ...availableTEs\n            ];\n            if (otherPlayers.length > 0) {\n                bestSuperflexPlayer = otherPlayers.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            }\n        }\n        return bestSuperflexPlayer;\n    }\n    findBestFlexPlayer(positionGroups, usedPlayers) {\n        // Get all available flex eligible players\n        const availableRBs = (positionGroups[\"RB\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableWRs = (positionGroups[\"WR\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableTEs = (positionGroups[\"TE\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        // In flex, RB/WR/TE are all valuable - give them priority\n        let bestFlexPlayer = null;\n        // First priority: Best available RB\n        if (availableRBs.length > 0) {\n            const bestRB = availableRBs.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            bestFlexPlayer = bestRB;\n        }\n        // If no RBs available, select best WR/TE\n        if (!bestFlexPlayer) {\n            const otherPlayers = [\n                ...availableWRs,\n                ...availableTEs\n            ];\n            if (otherPlayers.length > 0) {\n                bestFlexPlayer = otherPlayers.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            }\n        }\n        return bestFlexPlayer;\n    }\n    groupPlayersByPosition(roster) {\n        const groups = {};\n        console.log(\"\\uD83D\\uDD0D Grouping players by position. Roster:\", roster);\n        roster.forEach((player)=>{\n            const position = (player.position || \"\").toUpperCase();\n            console.log(`üîç Player: ${player.playerName}, Position: ${position}, Raw position: ${player.position}`);\n            if (!position) {\n                console.log(`‚ö†Ô∏è Skipping player ${player.playerName} - no position`);\n                return;\n            }\n            if (!groups[position]) {\n                groups[position] = [];\n            }\n            groups[position].push(player);\n        });\n        console.log(\"\\uD83D\\uDD0D Grouped players:\", groups);\n        return groups;\n    }\n    getBenchPlayers(roster, optimalLineup) {\n        const usedPlayers = new Set();\n        // Collect all players used in optimal lineup\n        Object.values(optimalLineup).forEach((players)=>{\n            if (Array.isArray(players)) {\n                players.forEach((p)=>{\n                    usedPlayers.add(p.playerId || p.playerName);\n                });\n            }\n        });\n        // Return players not used in optimal lineup\n        return roster.filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n    }\n    calculateTotalProjectedPoints(players) {\n        if (Array.isArray(players)) {\n            return players.reduce((total, player)=>total + (player.projectedPoints || 0), 0);\n        }\n        // Handle object format\n        let total = 0;\n        Object.values(players).forEach((positionPlayers)=>{\n            if (Array.isArray(positionPlayers)) {\n                total += positionPlayers.reduce((sum, p)=>sum + (p.projectedPoints || 0), 0);\n            }\n        });\n        return total;\n    }\n    analyzeLineup(optimalLineup, settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const superflexSlots = settings.superflexSlots || 0;\n        const actualTeams = settings.teams || 12;\n        const actualRounds = 16; // Default to 16 rounds for dynamic calculation\n        const requirements = this.getRosterRequirements(leagueType, actualTeams, actualRounds);\n        return {\n            totalStarters: requirements.totalStarters,\n            leagueType,\n            superflexSlots: requirements.superflexPositions ? requirements.superflexPositions.length : 0,\n            requirements,\n            positionCounts: Object.entries(requirements).filter(([key])=>![\n                    \"totalStarters\",\n                    \"flexPositions\",\n                    \"superflexPositions\"\n                ].includes(key)).reduce((acc, [pos, count])=>({\n                    ...acc,\n                    [pos]: count\n                }), {})\n        };\n    }\n    // Calculate replacement baselines for VORP calculations\n    calculateReplacementBaselines(settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const superflexSlots = settings.superflexSlots || 0;\n        const actualTeams = settings.teams || 12;\n        const actualRounds = 16; // Default to 16 rounds for dynamic calculation\n        const baselines = {\n            QB: actualTeams * (1 + superflexSlots),\n            RB: actualTeams * 2,\n            WR: actualTeams * 2,\n            TE: actualTeams * 1,\n            K: actualTeams * 1,\n            DEF: actualTeams * 1\n        };\n        return baselines;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvbGliL29wdGltYWwtbGluZXVwLWVuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBUWUsTUFBTUE7SUFDWEMsc0JBQXNCQyxhQUFxQixVQUFVLEVBQUVDLGNBQXNCLEVBQUUsRUFBRUMsZUFBdUIsRUFBRSxFQUFFO1FBQ2xILDJFQUEyRTtRQUMzRSxNQUFNQyxtQkFBbUI7WUFDdkJDLFVBQVU7Z0JBQ1JDLElBQUk7Z0JBQUdDLElBQUk7Z0JBQUdDLElBQUk7Z0JBQUdDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQUdDLEtBQUs7Z0JBQUdDLEdBQUc7Z0JBQ2hEQyxlQUFlO29CQUFDO29CQUFNO29CQUFNO2lCQUFLO2dCQUNqQ0Msb0JBQW9CLEVBQUU7WUFDeEI7WUFDQUMsV0FBVztnQkFDVFQsSUFBSTtnQkFBR0MsSUFBSTtnQkFBR0MsSUFBSTtnQkFBR0MsSUFBSTtnQkFBR0MsTUFBTTtnQkFBR0MsS0FBSztnQkFBR0MsR0FBRztnQkFDaERDLGVBQWU7b0JBQUM7b0JBQU07b0JBQU07b0JBQU07aUJBQUs7Z0JBQ3ZDQyxvQkFBb0IsRUFBRTtZQUN4QjtZQUNBLE9BQU87Z0JBQ0xSLElBQUk7Z0JBQUdDLElBQUk7Z0JBQUdDLElBQUk7Z0JBQUdDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQUdDLEtBQUs7Z0JBQUdDLEdBQUc7Z0JBQ2hEQyxlQUFlO29CQUFDO29CQUFNO29CQUFNO2lCQUFLO2dCQUNqQ0Msb0JBQW9CLEVBQUU7WUFDeEI7WUFDQSxTQUFTO2dCQUNQUixJQUFJO2dCQUFHQyxJQUFJO2dCQUFHQyxJQUFJO2dCQUFHQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFHQyxLQUFLO2dCQUFHQyxHQUFHO2dCQUNoREMsZUFBZTtvQkFBQztvQkFBTTtvQkFBTTtpQkFBSztnQkFDakNDLG9CQUFvQixFQUFFO1lBQ3hCO1FBQ0Y7UUFFQSxNQUFNRSxlQUFlWixnQkFBZ0IsQ0FBQ0gsV0FBNEMsSUFBSUcsaUJBQWlCQyxRQUFRO1FBRS9HLCtEQUErRDtRQUMv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QUM5QixJQUFJLEVBQUVqQztnQkFBTSxJQUFJLENBQUM7UUFDaEU7SUFDRjtJQUVBLHdEQUF3RDtJQUN4RGdFLDhCQUE4QnpELFdBQTJCLENBQUMsQ0FBQyxFQUFFO1FBQzNELE1BQU1oQyxhQUFhZ0MsU0FBU2hDLFVBQVUsSUFBSTtRQUMxQyxNQUFNc0YsaUJBQWlCdEQsU0FBU3NELGNBQWMsSUFBSTtRQUNsRCxNQUFNckYsY0FBYytCLFNBQVNDLEtBQUssSUFBSTtRQUN0QyxNQUFNL0IsZUFBZSxJQUFJLCtDQUErQztRQUV4RSxNQUFNd0YsWUFBWTtZQUNoQnJGLElBQUlKLGNBQWUsS0FBSXFGLGNBQWE7WUFDcENoRixJQUFJTCxjQUFjO1lBQ2xCTSxJQUFJTixjQUFjO1lBQ2xCTyxJQUFJUCxjQUFjO1lBQ2xCVSxHQUFHVixjQUFjO1lBQ2pCUyxLQUFLVCxjQUFjO1FBQ3JCO1FBRUEsT0FBT3lGO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZmX2FwaV9za2VsZXRvbi8uL2FwcC9saWIvb3B0aW1hbC1saW5ldXAtZW5naW5lLnRzPzZiM2QiXSwic291cmNlc0NvbnRlbnQiOlsidHlwZSBMZWFndWVTZXR0aW5ncyA9IHtcbiAgc2NvcmluZz86IHN0cmluZztcbiAgbGVhZ3VlVHlwZT86IHN0cmluZztcbiAgc3VwZXJmbGV4U2xvdHM/OiBudW1iZXI7XG4gIHRlYW1zPzogbnVtYmVyO1xuICByb3VuZHM/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpbWFsTGluZXVwRW5naW5lIHtcbiAgcHJpdmF0ZSBnZXRSb3N0ZXJSZXF1aXJlbWVudHMobGVhZ3VlVHlwZTogc3RyaW5nID0gJ3N0YW5kYXJkJywgYWN0dWFsVGVhbXM6IG51bWJlciA9IDEyLCBhY3R1YWxSb3VuZHM6IG51bWJlciA9IDE2KSB7XG4gICAgLy8gRml4ZWQgc3RhcnRlciByZXF1aXJlbWVudHMgLSBiZW5jaCBzaXplIHNjYWxlcyB3aXRoIHJvdW5kcywgbm90IHN0YXJ0ZXJzXG4gICAgY29uc3QgYmFzZVJlcXVpcmVtZW50cyA9IHtcbiAgICAgIHN0YW5kYXJkOiB7XG4gICAgICAgIFFCOiAxLCBSQjogMiwgV1I6IDIsIFRFOiAxLCBGTEVYOiAxLCBERUY6IDEsIEs6IDEsIC8vIDkgc3RhcnRlcnNcbiAgICAgICAgZmxleFBvc2l0aW9uczogWydSQicsICdXUicsICdURSddLFxuICAgICAgICBzdXBlcmZsZXhQb3NpdGlvbnM6IFtdXG4gICAgICB9LFxuICAgICAgc3VwZXJmbGV4OiB7XG4gICAgICAgIFFCOiAxLCBSQjogMiwgV1I6IDIsIFRFOiAxLCBGTEVYOiAxLCBERUY6IDEsIEs6IDEsIC8vIDkgc3RhcnRlcnMgKFFCIGVsaWdpYmxlIGluIGZsZXgpXG4gICAgICAgIGZsZXhQb3NpdGlvbnM6IFsnUUInLCAnUkInLCAnV1InLCAnVEUnXSwgLy8gUUIgZWxpZ2libGUgaW4gZmxleFxuICAgICAgICBzdXBlcmZsZXhQb3NpdGlvbnM6IFtdXG4gICAgICB9LFxuICAgICAgJzJxYic6IHtcbiAgICAgICAgUUI6IDIsIFJCOiAyLCBXUjogMiwgVEU6IDEsIEZMRVg6IDEsIERFRjogMSwgSzogMSwgLy8gMTAgc3RhcnRlcnNcbiAgICAgICAgZmxleFBvc2l0aW9uczogWydSQicsICdXUicsICdURSddLFxuICAgICAgICBzdXBlcmZsZXhQb3NpdGlvbnM6IFtdXG4gICAgICB9LFxuICAgICAgJzJmbGV4Jzoge1xuICAgICAgICBRQjogMSwgUkI6IDIsIFdSOiAyLCBURTogMSwgRkxFWDogMiwgREVGOiAxLCBLOiAxLCAvLyAxMCBzdGFydGVyc1xuICAgICAgICBmbGV4UG9zaXRpb25zOiBbJ1JCJywgJ1dSJywgJ1RFJ10sXG4gICAgICAgIHN1cGVyZmxleFBvc2l0aW9uczogW11cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gYmFzZVJlcXVpcmVtZW50c1tsZWFndWVUeXBlIGFzIGtleW9mIHR5cGVvZiBiYXNlUmVxdWlyZW1lbnRzXSB8fCBiYXNlUmVxdWlyZW1lbnRzLnN0YW5kYXJkO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBzdGFydGVycyAoZml4ZWQsIGRvZXNuJ3QgY2hhbmdlIHdpdGggcm91bmRzKVxuICAgIGNvbnN0IHRvdGFsU3RhcnRlcnMgPSBPYmplY3QuZW50cmllcyhyZXF1aXJlbWVudHMpXG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4gIVsnZmxleFBvc2l0aW9ucycsICdzdXBlcmZsZXhQb3NpdGlvbnMnXS5pbmNsdWRlcyhrZXkpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBbXywgY291bnRdKSA9PiBzdW0gKyAodHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyA/IGNvdW50IDogMCksIDApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcXVpcmVtZW50cyxcbiAgICAgIHRvdGFsU3RhcnRlcnMsXG4gICAgICAvLyBBZGQgbWV0YWRhdGEgYWJvdXQgdGhlIGR5bmFtaWMgY2FsY3VsYXRpb25cbiAgICAgIF9tZXRhZGF0YToge1xuICAgICAgICBhY3R1YWxUZWFtcyxcbiAgICAgICAgYWN0dWFsUm91bmRzLFxuICAgICAgICBsZWFndWVUeXBlLFxuICAgICAgICBjYWxjdWxhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVPcHRpbWFsTGluZXVwKHJvc3RlcjogYW55W10sIHNldHRpbmdzOiBMZWFndWVTZXR0aW5ncyA9IHt9KSB7XG4gICAgY29uc3QgbGVhZ3VlVHlwZSA9IHNldHRpbmdzLmxlYWd1ZVR5cGUgfHwgJ3N0YW5kYXJkJztcbiAgICBjb25zdCBhY3R1YWxUZWFtcyA9IHNldHRpbmdzLnRlYW1zIHx8IDEyO1xuICAgIGNvbnN0IGFjdHVhbFJvdW5kcyA9IHNldHRpbmdzLnJvdW5kcyB8fCAxNjsgLy8gR2V0IGFjdHVhbCByb3VuZHMgZnJvbSBzZXR0aW5nc1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSByb3N0ZXIgcmVxdWlyZW1lbnRzIGJhc2VkIG9uIGFjdHVhbCBkcmFmdCBkYXRhXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gdGhpcy5nZXRSb3N0ZXJSZXF1aXJlbWVudHMobGVhZ3VlVHlwZSwgYWN0dWFsVGVhbXMsIGFjdHVhbFJvdW5kcyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gQ2FsY3VsYXRpbmcgb3B0aW1hbCBsaW5ldXA6JywgeyBcbiAgICAgIGxlYWd1ZVR5cGUsIFxuICAgICAgYWN0dWFsVGVhbXMsIFxuICAgICAgYWN0dWFsUm91bmRzLCBcbiAgICAgIHJlcXVpcmVtZW50czoge1xuICAgICAgICAuLi5yZXF1aXJlbWVudHMsXG4gICAgICAgIF9tZXRhZGF0YTogcmVxdWlyZW1lbnRzLl9tZXRhZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEdyb3VwIHBsYXllcnMgYnkgcG9zaXRpb25cbiAgICBjb25zdCBwb3NpdGlvbkdyb3VwcyA9IHRoaXMuZ3JvdXBQbGF5ZXJzQnlQb3NpdGlvbihyb3N0ZXIpO1xuICAgIFxuICAgIC8vIFN0YXJ0IGJ1aWxkaW5nIG9wdGltYWwgbGluZXVwXG4gICAgY29uc3Qgb3B0aW1hbExpbmV1cDogUmVjb3JkPHN0cmluZywgYW55W10+ID0ge307XG4gICAgY29uc3QgdXNlZFBsYXllcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gRmlsbGluZyByZXF1aXJlZCBwb3NpdGlvbnMuLi4nKTtcbiAgICBcbiAgICAvLyBGaWxsIHJlcXVpcmVkIHBvc2l0aW9ucyBmaXJzdCAoZXhjbHVkaW5nIHNwZWNpYWwgcG9zaXRpb25zKVxuICAgIE9iamVjdC5lbnRyaWVzKHJlcXVpcmVtZW50cykuZm9yRWFjaCgoW3Bvc2l0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvdGFsU3RhcnRlcnMnIHx8IHBvc2l0aW9uID09PSAnZmxleFBvc2l0aW9ucycgfHwgcG9zaXRpb24gPT09ICdzdXBlcmZsZXhQb3NpdGlvbnMnKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFByb2Nlc3NpbmcgcG9zaXRpb246ICR7cG9zaXRpb259LCBjb3VudDogJHtjb3VudH1gKTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiBjb3VudCA9PT0gJ251bWJlcicgJiYgY291bnQgPiAwKSB7XG4gICAgICAgIG9wdGltYWxMaW5ldXBbcG9zaXRpb25dID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgYmVzdCBwbGF5ZXJzIGZvciB0aGlzIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVBsYXllcnMgPSBwb3NpdGlvbkdyb3Vwc1twb3NpdGlvbl0gfHwgW107XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEF2YWlsYWJsZSBwbGF5ZXJzIGZvciAke3Bvc2l0aW9ufTpgLCBhdmFpbGFibGVQbGF5ZXJzKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNvcnRlZFBsYXllcnMgPSBhdmFpbGFibGVQbGF5ZXJzXG4gICAgICAgICAgLmZpbHRlcigocDogYW55KSA9PiAhdXNlZFBsYXllcnMuaGFzKHAucGxheWVySWQgfHwgcC5wbGF5ZXJOYW1lKSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gKGIucHJvamVjdGVkUG9pbnRzIHx8IDApIC0gKGEucHJvamVjdGVkUG9pbnRzIHx8IDApKVxuICAgICAgICAgIC5zbGljZSgwLCBjb3VudCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWxlY3RlZCBwbGF5ZXJzIGZvciAke3Bvc2l0aW9ufTpgLCBzb3J0ZWRQbGF5ZXJzKTtcbiAgICAgICAgXG4gICAgICAgIG9wdGltYWxMaW5ldXBbcG9zaXRpb25dID0gc29ydGVkUGxheWVycztcbiAgICAgICAgc29ydGVkUGxheWVycy5mb3JFYWNoKChwOiBhbnkpID0+IHVzZWRQbGF5ZXJzLmFkZChwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBGTEVYIHBvc2l0aW9uXG4gICAgaWYgKHJlcXVpcmVtZW50cy5mbGV4UG9zaXRpb25zKSB7XG4gICAgICBjb25zdCBmbGV4UGxheWVycyA9IHJlcXVpcmVtZW50cy5mbGV4UG9zaXRpb25zLmZsYXRNYXAocG9zID0+IFxuICAgICAgICAocG9zaXRpb25Hcm91cHNbcG9zXSB8fCBbXSkuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGZsZXhQbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYmVzdEZsZXhQbGF5ZXIgPSBmbGV4UGxheWVyc1xuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiAoYi5wcm9qZWN0ZWRQb2ludHMgfHwgMCkgLSAoYS5wcm9qZWN0ZWRQb2ludHMgfHwgMCkpWzBdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGJlc3RGbGV4UGxheWVyKSB7XG4gICAgICAgICAgb3B0aW1hbExpbmV1cC5GTEVYID0gW2Jlc3RGbGV4UGxheWVyXTtcbiAgICAgICAgICB1c2VkUGxheWVycy5hZGQoYmVzdEZsZXhQbGF5ZXIucGxheWVySWQgfHwgYmVzdEZsZXhQbGF5ZXIucGxheWVyTmFtZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9nIHdoaWNoIHR5cGUgb2YgZmxleCB0aGlzIGlzXG4gICAgICAgICAgaWYgKGxlYWd1ZVR5cGUgPT09ICdzdXBlcmZsZXgnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+muCBTdXBlcmZsZXggRkxFWDogU2VsZWN0ZWQgJHtiZXN0RmxleFBsYXllci5wb3NpdGlvbn0gJHtiZXN0RmxleFBsYXllci5wbGF5ZXJOYW1lfSB3aXRoICR7YmVzdEZsZXhQbGF5ZXIucHJvamVjdGVkUG9pbnRzfSBwb2ludHNgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgU3RhbmRhcmQgRkxFWDogU2VsZWN0ZWQgJHtiZXN0RmxleFBsYXllci5wb3NpdGlvbn0gJHtiZXN0RmxleFBsYXllci5wbGF5ZXJOYW1lfSB3aXRoICR7YmVzdEZsZXhQbGF5ZXIucHJvamVjdGVkUG9pbnRzfSBwb2ludHNgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIDIgRkxFWCBwb3NpdGlvbnMgKGlmIGFwcGxpY2FibGUpXG4gICAgaWYgKGxlYWd1ZVR5cGUgPT09ICcyZmxleCcgJiYgcmVxdWlyZW1lbnRzLkZMRVggPT09IDIpIHtcbiAgICAgIG9wdGltYWxMaW5ldXAuRkxFWCA9IFtdO1xuICAgICAgXG4gICAgICAvLyBGaWxsIGZpcnN0IGZsZXggc3BvdFxuICAgICAgY29uc3QgYmVzdEZsZXhQbGF5ZXIxID0gdGhpcy5maW5kQmVzdEZsZXhQbGF5ZXIocG9zaXRpb25Hcm91cHMsIHVzZWRQbGF5ZXJzKTtcbiAgICAgIGlmIChiZXN0RmxleFBsYXllcjEpIHtcbiAgICAgICAgb3B0aW1hbExpbmV1cC5GTEVYLnB1c2goYmVzdEZsZXhQbGF5ZXIxKTtcbiAgICAgICAgdXNlZFBsYXllcnMuYWRkKGJlc3RGbGV4UGxheWVyMS5wbGF5ZXJJZCB8fCBiZXN0RmxleFBsYXllcjEucGxheWVyTmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIEZMRVggMTogU2VsZWN0ZWQgJHtiZXN0RmxleFBsYXllcjEucG9zaXRpb259ICR7YmVzdEZsZXhQbGF5ZXIxLnBsYXllck5hbWV9IHdpdGggJHtiZXN0RmxleFBsYXllcjEucHJvamVjdGVkUG9pbnRzfSBwb2ludHNgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmlsbCBzZWNvbmQgZmxleCBzcG90XG4gICAgICBjb25zdCBiZXN0RmxleFBsYXllcjIgPSB0aGlzLmZpbmRCZXN0RmxleFBsYXllcihwb3NpdGlvbkdyb3VwcywgdXNlZFBsYXllcnMpO1xuICAgICAgaWYgKGJlc3RGbGV4UGxheWVyMikge1xuICAgICAgICBvcHRpbWFsTGluZXVwLkZMRVgucHVzaChiZXN0RmxleFBsYXllcjIpO1xuICAgICAgICB1c2VkUGxheWVycy5hZGQoYmVzdEZsZXhQbGF5ZXIyLnBsYXllcklkIHx8IGJlc3RGbGV4UGxheWVyMi5wbGF5ZXJOYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgRkxFWCAyOiBTZWxlY3RlZCAke2Jlc3RGbGV4UGxheWVyMi5wb3NpdGlvbn0gJHtiZXN0RmxleFBsYXllcjIucGxheWVyTmFtZX0gd2l0aCAke2Jlc3RGbGV4UGxheWVyMi5wcm9qZWN0ZWRQb2ludHN9IHBvaW50c2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgYWxsIHJlcXVpcmVkIHBvc2l0aW9ucyBoYXZlIGF0IGxlYXN0IGFuIGVtcHR5IGFycmF5XG4gICAgT2JqZWN0LmVudHJpZXMocmVxdWlyZW1lbnRzKS5mb3JFYWNoKChbcG9zaXRpb24sIGNvdW50XSkgPT4ge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAndG90YWxTdGFydGVycycgfHwgcG9zaXRpb24gPT09ICdmbGV4UG9zaXRpb25zJyB8fCBwb3NpdGlvbiA9PT0gJ3N1cGVyZmxleFBvc2l0aW9ucycpIHJldHVybjtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiBjb3VudCA9PT0gJ251bWJlcicgJiYgY291bnQgPiAwICYmICFvcHRpbWFsTGluZXVwW3Bvc2l0aW9uXSkge1xuICAgICAgICBvcHRpbWFsTGluZXVwW3Bvc2l0aW9uXSA9IFtdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBvcHRpbWFsTGluZXVwO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kQmVzdFN1cGVyZmxleFBsYXllcihwb3NpdGlvbkdyb3VwczogUmVjb3JkPHN0cmluZywgYW55W10+LCB1c2VkUGxheWVyczogU2V0PHN0cmluZyB8IHVua25vd24+KSB7XG4gICAgLy8gR2V0IGFsbCBhdmFpbGFibGUgc3VwZXJmbGV4IGVsaWdpYmxlIHBsYXllcnNcbiAgICBjb25zdCBhdmFpbGFibGVRQnMgPSAocG9zaXRpb25Hcm91cHNbJ1FCJ10gfHwgW10pLmZpbHRlcigocDogYW55KSA9PiAhdXNlZFBsYXllcnMuaGFzKHAucGxheWVySWQgfHwgcC5wbGF5ZXJOYW1lKSk7XG4gICAgY29uc3QgYXZhaWxhYmxlUkJzID0gKHBvc2l0aW9uR3JvdXBzWydSQiddIHx8IFtdKS5maWx0ZXIoKHA6IGFueSkgPT4gIXVzZWRQbGF5ZXJzLmhhcyhwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSkpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVdScyA9IChwb3NpdGlvbkdyb3Vwc1snV1InXSB8fCBbXSkuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKTtcbiAgICBjb25zdCBhdmFpbGFibGVURXMgPSAocG9zaXRpb25Hcm91cHNbJ1RFJ10gfHwgW10pLmZpbHRlcigocDogYW55KSA9PiAhdXNlZFBsYXllcnMuaGFzKHAucGxheWVySWQgfHwgcC5wbGF5ZXJOYW1lKSk7XG4gICAgXG4gICAgLy8gSW4gc3VwZXJmbGV4LCBRQnMgYXJlIGV4dHJlbWVseSB2YWx1YWJsZSAtIGdpdmUgdGhlbSBwcmlvcml0eVxuICAgIGxldCBiZXN0U3VwZXJmbGV4UGxheWVyID0gbnVsbDtcbiAgICBcbiAgICAvLyBGaXJzdCBwcmlvcml0eTogQmVzdCBhdmFpbGFibGUgUUIgKFFCcyBzY29yZSBtdWNoIGhpZ2hlciB0aGFuIG90aGVyIHBvc2l0aW9ucylcbiAgICBpZiAoYXZhaWxhYmxlUUJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJlc3RRQiA9IGF2YWlsYWJsZVFCcy5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gKGIucHJvamVjdGVkUG9pbnRzIHx8IDApIC0gKGEucHJvamVjdGVkUG9pbnRzIHx8IDApKVswXTtcbiAgICAgIGJlc3RTdXBlcmZsZXhQbGF5ZXIgPSBiZXN0UUI7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIG5vIFFCcyBhdmFpbGFibGUsIHNlbGVjdCBiZXN0IFJCL1dSL1RFXG4gICAgaWYgKCFiZXN0U3VwZXJmbGV4UGxheWVyKSB7XG4gICAgICBjb25zdCBvdGhlclBsYXllcnMgPSBbLi4uYXZhaWxhYmxlUkJzLCAuLi5hdmFpbGFibGVXUnMsIC4uLmF2YWlsYWJsZVRFc107XG4gICAgICBpZiAob3RoZXJQbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmVzdFN1cGVyZmxleFBsYXllciA9IG90aGVyUGxheWVycy5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gKGIucHJvamVjdGVkUG9pbnRzIHx8IDApIC0gKGEucHJvamVjdGVkUG9pbnRzIHx8IDApKVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGJlc3RTdXBlcmZsZXhQbGF5ZXI7XG4gIH1cblxuICBwcml2YXRlIGZpbmRCZXN0RmxleFBsYXllcihwb3NpdGlvbkdyb3VwczogUmVjb3JkPHN0cmluZywgYW55W10+LCB1c2VkUGxheWVyczogU2V0PHN0cmluZyB8IHVua25vd24+KSB7XG4gICAgLy8gR2V0IGFsbCBhdmFpbGFibGUgZmxleCBlbGlnaWJsZSBwbGF5ZXJzXG4gICAgY29uc3QgYXZhaWxhYmxlUkJzID0gKHBvc2l0aW9uR3JvdXBzWydSQiddIHx8IFtdKS5maWx0ZXIoKHA6IGFueSkgPT4gIXVzZWRQbGF5ZXJzLmhhcyhwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSkpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVdScyA9IChwb3NpdGlvbkdyb3Vwc1snV1InXSB8fCBbXSkuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKTtcbiAgICBjb25zdCBhdmFpbGFibGVURXMgPSAocG9zaXRpb25Hcm91cHNbJ1RFJ10gfHwgW10pLmZpbHRlcigocDogYW55KSA9PiAhdXNlZFBsYXllcnMuaGFzKHAucGxheWVySWQgfHwgcC5wbGF5ZXJOYW1lKSk7XG4gICAgXG4gICAgLy8gSW4gZmxleCwgUkIvV1IvVEUgYXJlIGFsbCB2YWx1YWJsZSAtIGdpdmUgdGhlbSBwcmlvcml0eVxuICAgIGxldCBiZXN0RmxleFBsYXllciA9IG51bGw7XG4gICAgXG4gICAgLy8gRmlyc3QgcHJpb3JpdHk6IEJlc3QgYXZhaWxhYmxlIFJCXG4gICAgaWYgKGF2YWlsYWJsZVJCcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBiZXN0UkIgPSBhdmFpbGFibGVSQnMuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IChiLnByb2plY3RlZFBvaW50cyB8fCAwKSAtIChhLnByb2plY3RlZFBvaW50cyB8fCAwKSlbMF07XG4gICAgICBiZXN0RmxleFBsYXllciA9IGJlc3RSQjtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gUkJzIGF2YWlsYWJsZSwgc2VsZWN0IGJlc3QgV1IvVEVcbiAgICBpZiAoIWJlc3RGbGV4UGxheWVyKSB7XG4gICAgICBjb25zdCBvdGhlclBsYXllcnMgPSBbLi4uYXZhaWxhYmxlV1JzLCAuLi5hdmFpbGFibGVURXNdO1xuICAgICAgaWYgKG90aGVyUGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJlc3RGbGV4UGxheWVyID0gb3RoZXJQbGF5ZXJzLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiAoYi5wcm9qZWN0ZWRQb2ludHMgfHwgMCkgLSAoYS5wcm9qZWN0ZWRQb2ludHMgfHwgMCkpWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYmVzdEZsZXhQbGF5ZXI7XG4gIH1cblxuICBwcml2YXRlIGdyb3VwUGxheWVyc0J5UG9zaXRpb24ocm9zdGVyOiBhbnlbXSkge1xuICAgIGNvbnN0IGdyb3VwczogUmVjb3JkPHN0cmluZywgYW55W10+ID0ge307XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gR3JvdXBpbmcgcGxheWVycyBieSBwb3NpdGlvbi4gUm9zdGVyOicsIHJvc3Rlcik7XG4gICAgXG4gICAgcm9zdGVyLmZvckVhY2goKHBsYXllcikgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSAocGxheWVyLnBvc2l0aW9uIHx8ICcnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgY29uc29sZS5sb2coYPCflI0gUGxheWVyOiAke3BsYXllci5wbGF5ZXJOYW1lfSwgUG9zaXRpb246ICR7cG9zaXRpb259LCBSYXcgcG9zaXRpb246ICR7cGxheWVyLnBvc2l0aW9ufWApO1xuICAgICAgXG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gU2tpcHBpbmcgcGxheWVyICR7cGxheWVyLnBsYXllck5hbWV9IC0gbm8gcG9zaXRpb25gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWdyb3Vwc1twb3NpdGlvbl0pIHtcbiAgICAgICAgZ3JvdXBzW3Bvc2l0aW9uXSA9IFtdO1xuICAgICAgfVxuICAgICAgZ3JvdXBzW3Bvc2l0aW9uXS5wdXNoKHBsYXllcik7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gR3JvdXBlZCBwbGF5ZXJzOicsIGdyb3Vwcyk7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIGdldEJlbmNoUGxheWVycyhyb3N0ZXI6IGFueVtdLCBvcHRpbWFsTGluZXVwOiBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4pOiBhbnlbXSB7XG4gICAgY29uc3QgdXNlZFBsYXllcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgLy8gQ29sbGVjdCBhbGwgcGxheWVycyB1c2VkIGluIG9wdGltYWwgbGluZXVwXG4gICAgT2JqZWN0LnZhbHVlcyhvcHRpbWFsTGluZXVwKS5mb3JFYWNoKChwbGF5ZXJzOiBhbnlbXSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGxheWVycykpIHtcbiAgICAgICAgcGxheWVycy5mb3JFYWNoKChwOiBhbnkpID0+IHtcbiAgICAgICAgICB1c2VkUGxheWVycy5hZGQocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBSZXR1cm4gcGxheWVycyBub3QgdXNlZCBpbiBvcHRpbWFsIGxpbmV1cFxuICAgIHJldHVybiByb3N0ZXIuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVRvdGFsUHJvamVjdGVkUG9pbnRzKHBsYXllcnM6IGFueVtdIHwgUmVjb3JkPHN0cmluZywgYW55W10+KTogbnVtYmVyIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJzKSkge1xuICAgICAgcmV0dXJuIHBsYXllcnMucmVkdWNlKCh0b3RhbCwgcGxheWVyKSA9PiB0b3RhbCArIChwbGF5ZXIucHJvamVjdGVkUG9pbnRzIHx8IDApLCAwKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIG9iamVjdCBmb3JtYXRcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIE9iamVjdC52YWx1ZXMocGxheWVycykuZm9yRWFjaCgocG9zaXRpb25QbGF5ZXJzOiBhbnkpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvc2l0aW9uUGxheWVycykpIHtcbiAgICAgICAgdG90YWwgKz0gcG9zaXRpb25QbGF5ZXJzLnJlZHVjZSgoc3VtOiBudW1iZXIsIHA6IGFueSkgPT4gc3VtICsgKHAucHJvamVjdGVkUG9pbnRzIHx8IDApLCAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICBhbmFseXplTGluZXVwKG9wdGltYWxMaW5ldXA6IFJlY29yZDxzdHJpbmcsIGFueVtdPiwgc2V0dGluZ3M6IExlYWd1ZVNldHRpbmdzID0ge30pIHtcbiAgICBjb25zdCBsZWFndWVUeXBlID0gc2V0dGluZ3MubGVhZ3VlVHlwZSB8fCAnc3RhbmRhcmQnO1xuICAgIGNvbnN0IHN1cGVyZmxleFNsb3RzID0gc2V0dGluZ3Muc3VwZXJmbGV4U2xvdHMgfHwgMDtcbiAgICBjb25zdCBhY3R1YWxUZWFtcyA9IHNldHRpbmdzLnRlYW1zIHx8IDEyO1xuICAgIGNvbnN0IGFjdHVhbFJvdW5kcyA9IDE2OyAvLyBEZWZhdWx0IHRvIDE2IHJvdW5kcyBmb3IgZHluYW1pYyBjYWxjdWxhdGlvblxuICAgIGNvbnN0IHJlcXVpcmVtZW50cyA9IHRoaXMuZ2V0Um9zdGVyUmVxdWlyZW1lbnRzKGxlYWd1ZVR5cGUsIGFjdHVhbFRlYW1zLCBhY3R1YWxSb3VuZHMpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFN0YXJ0ZXJzOiByZXF1aXJlbWVudHMudG90YWxTdGFydGVycyxcbiAgICAgIGxlYWd1ZVR5cGUsXG4gICAgICBzdXBlcmZsZXhTbG90czogcmVxdWlyZW1lbnRzLnN1cGVyZmxleFBvc2l0aW9ucyA/IHJlcXVpcmVtZW50cy5zdXBlcmZsZXhQb3NpdGlvbnMubGVuZ3RoIDogMCxcbiAgICAgIHJlcXVpcmVtZW50cyxcbiAgICAgIHBvc2l0aW9uQ291bnRzOiBPYmplY3QuZW50cmllcyhyZXF1aXJlbWVudHMpXG4gICAgICAgIC5maWx0ZXIoKFtrZXldKSA9PiAhWyd0b3RhbFN0YXJ0ZXJzJywgJ2ZsZXhQb3NpdGlvbnMnLCAnc3VwZXJmbGV4UG9zaXRpb25zJ10uaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBbcG9zLCBjb3VudF0pID0+ICh7IC4uLmFjYywgW3Bvc106IGNvdW50IH0pLCB7fSlcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHJlcGxhY2VtZW50IGJhc2VsaW5lcyBmb3IgVk9SUCBjYWxjdWxhdGlvbnNcbiAgY2FsY3VsYXRlUmVwbGFjZW1lbnRCYXNlbGluZXMoc2V0dGluZ3M6IExlYWd1ZVNldHRpbmdzID0ge30pIHtcbiAgICBjb25zdCBsZWFndWVUeXBlID0gc2V0dGluZ3MubGVhZ3VlVHlwZSB8fCAnc3RhbmRhcmQnO1xuICAgIGNvbnN0IHN1cGVyZmxleFNsb3RzID0gc2V0dGluZ3Muc3VwZXJmbGV4U2xvdHMgfHwgMDtcbiAgICBjb25zdCBhY3R1YWxUZWFtcyA9IHNldHRpbmdzLnRlYW1zIHx8IDEyO1xuICAgIGNvbnN0IGFjdHVhbFJvdW5kcyA9IDE2OyAvLyBEZWZhdWx0IHRvIDE2IHJvdW5kcyBmb3IgZHluYW1pYyBjYWxjdWxhdGlvblxuICAgIFxuICAgIGNvbnN0IGJhc2VsaW5lcyA9IHtcbiAgICAgIFFCOiBhY3R1YWxUZWFtcyAqICgxICsgc3VwZXJmbGV4U2xvdHMpLCAvLyBRQiBkZW1hbmQgaW5jcmVhc2VzIHdpdGggc3VwZXJmbGV4IHNsb3RzXG4gICAgICBSQjogYWN0dWFsVGVhbXMgKiAyLCAvLyBTdGFuZGFyZCBSQiBkZW1hbmRcbiAgICAgIFdSOiBhY3R1YWxUZWFtcyAqIDIsIC8vIFN0YW5kYXJkIFdSIGRlbWFuZCAgXG4gICAgICBURTogYWN0dWFsVGVhbXMgKiAxLCAvLyBTdGFuZGFyZCBURSBkZW1hbmRcbiAgICAgIEs6IGFjdHVhbFRlYW1zICogMSxcbiAgICAgIERFRjogYWN0dWFsVGVhbXMgKiAxXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gYmFzZWxpbmVzO1xuICB9XG59ICJdLCJuYW1lcyI6WyJPcHRpbWFsTGluZXVwRW5naW5lIiwiZ2V0Um9zdGVyUmVxdWlyZW1lbnRzIiwibGVhZ3VlVHlwZSIsImFjdHVhbFRlYW1zIiwiYWN0dWFsUm91bmRzIiwiYmFzZVJlcXVpcmVtZW50cyIsInN0YW5kYXJkIiwiUUIiLCJSQiIsIldSIiwiVEUiLCJGTEVYIiwiREVGIiwiSyIsImZsZXhQb3NpdGlvbnMiLCJzdXBlcmZsZXhQb3NpdGlvbnMiLCJzdXBlcmZsZXgiLCJyZXF1aXJlbWVudHMiLCJ0b3RhbFN0YXJ0ZXJzIiwiT2JqZWN0IiwiZW50cmllcyIsImZpbHRlciIsImtleSIsImluY2x1ZGVzIiwicmVkdWNlIiwic3VtIiwiXyIsImNvdW50IiwiX21ldGFkYXRhIiwiY2FsY3VsYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY2FsY3VsYXRlT3B0aW1hbExpbmV1cCIsInJvc3RlciIsInNldHRpbmdzIiwidGVhbXMiLCJyb3VuZHMiLCJjb25zb2xlIiwibG9nIiwicG9zaXRpb25Hcm91cHMiLCJncm91cFBsYXllcnNCeVBvc2l0aW9uIiwib3B0aW1hbExpbmV1cCIsInVzZWRQbGF5ZXJzIiwiU2V0IiwiZm9yRWFjaCIsInBvc2l0aW9uIiwiYXZhaWxhYmxlUGxheWVycyIsInNvcnRlZFBsYXllcnMiLCJwIiwiaGFzIiwicGxheWVySWQiLCJwbGF5ZXJOYW1lIiwic29ydCIsImEiLCJiIiwicHJvamVjdGVkUG9pbnRzIiwic2xpY2UiLCJhZGQiLCJmbGV4UGxheWVycyIsImZsYXRNYXAiLCJwb3MiLCJsZW5ndGgiLCJiZXN0RmxleFBsYXllciIsImJlc3RGbGV4UGxheWVyMSIsImZpbmRCZXN0RmxleFBsYXllciIsInB1c2giLCJiZXN0RmxleFBsYXllcjIiLCJmaW5kQmVzdFN1cGVyZmxleFBsYXllciIsImF2YWlsYWJsZVFCcyIsImF2YWlsYWJsZVJCcyIsImF2YWlsYWJsZVdScyIsImF2YWlsYWJsZVRFcyIsImJlc3RTdXBlcmZsZXhQbGF5ZXIiLCJiZXN0UUIiLCJvdGhlclBsYXllcnMiLCJiZXN0UkIiLCJncm91cHMiLCJwbGF5ZXIiLCJ0b1VwcGVyQ2FzZSIsImdldEJlbmNoUGxheWVycyIsInZhbHVlcyIsInBsYXllcnMiLCJBcnJheSIsImlzQXJyYXkiLCJjYWxjdWxhdGVUb3RhbFByb2plY3RlZFBvaW50cyIsInRvdGFsIiwicG9zaXRpb25QbGF5ZXJzIiwiYW5hbHl6ZUxpbmV1cCIsInN1cGVyZmxleFNsb3RzIiwicG9zaXRpb25Db3VudHMiLCJhY2MiLCJjYWxjdWxhdGVSZXBsYWNlbWVudEJhc2VsaW5lcyIsImJhc2VsaW5lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/lib/optimal-lineup-engine.ts\n");

/***/ }),

/***/ "(rsc)/./app/lib/position-grade-engine.ts":
/*!******************************************!*\
  !*** ./app/lib/position-grade-engine.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PositionGradeEngine)\n/* harmony export */ });\nclass PositionGradeEngine {\n    constructor(vorpArray = []){\n        this.vorpLookup = {};\n        this.leagueAverages = {};\n        this.leagueStdDevs = {};\n        vorpArray.forEach((p)=>{\n            const name = (p.playerName || \"\").toLowerCase();\n            const val = p.vorpScore ?? p.vorp_score ?? 0;\n            if (name) this.vorpLookup[name] = Number(val);\n        });\n    }\n    calculatePositionGrades(teams, settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const actualTeams = settings.teams || 12;\n        const actualRounds = settings.rounds || 16;\n        // Get dynamic position requirements based on actual draft data\n        const positionRequirements = this.getPositionRequirements(leagueType, actualTeams, actualRounds);\n        console.log(\"\\uD83D\\uDCCA Position grade calculation:\", {\n            leagueType,\n            actualTeams,\n            actualRounds,\n            positionRequirements: {\n                ...positionRequirements,\n                _metadata: positionRequirements._metadata\n            }\n        });\n        // Calculate position grades for each team first\n        const teamsWithPositionGrades = teams.map((team)=>{\n            const positionGrades = this.calculateTeamPositionGrades(team, positionRequirements);\n            return {\n                ...team,\n                positionGrades\n            };\n        });\n        // Calculate overall grades based on actual performance, not forced percentiles\n        const teamsWithOverallScores = teamsWithPositionGrades.map((team)=>{\n            // Calculate overall score based on optimal lineup points\n            const overallScore = team.optimalLineupPoints || 0;\n            // Convert to letter grade based on actual performance thresholds\n            const overallGrade = this.scoreToGrade(overallScore);\n            return {\n                ...team,\n                overallGrade: {\n                    grade: overallGrade,\n                    score: overallScore,\n                    rawScore: overallScore\n                }\n            };\n        });\n        return teamsWithOverallScores;\n    }\n    calculateTeamPositionGrades(team, positionRequirements) {\n        const positionGrades = {};\n        // Extract position names from the requirements object (excluding metadata and flexPositions)\n        const positionNames = Object.keys(positionRequirements).filter((key)=>![\n                \"flexPositions\",\n                \"superflexPositions\",\n                \"totalStarters\",\n                \"_metadata\"\n            ].includes(key));\n        positionNames.forEach((pos)=>{\n            if (pos === \"FLEX\" || pos === \"SUPERFLEX\") {\n                // Handle flex positions specially\n                const flexPlayers = this.getFlexPlayers(team, pos);\n                if (flexPlayers.length > 0) {\n                    const grade = this.gradePositionSimple(flexPlayers, pos);\n                    positionGrades[pos] = grade;\n                }\n            } else {\n                // Handle regular positions\n                const players = this.getPositionPlayers(team, pos);\n                if (players.length > 0) {\n                    const grade = this.gradePositionSimple(players, pos);\n                    positionGrades[pos] = grade;\n                }\n            }\n        });\n        return positionGrades;\n    }\n    gradePositionSimple(players, position) {\n        if (players.length === 0) return {\n            grade: \"‚Äî\",\n            score: 0,\n            reason: \"No players\"\n        };\n        const totalPoints = players.reduce((sum, p)=>sum + (p.projectedPoints || 0), 0);\n        // Simple grading based on projected points thresholds for different positions\n        let grade = \"C\";\n        let gradeScore = totalPoints;\n        // Position-specific scoring thresholds (approximate)\n        const thresholds = {\n            \"QB\": {\n                excellent: 25,\n                good: 22,\n                average: 18,\n                poor: 15\n            },\n            \"RB\": {\n                excellent: 40,\n                good: 30,\n                average: 22,\n                poor: 15\n            },\n            \"WR\": {\n                excellent: 40,\n                good: 30,\n                average: 22,\n                poor: 15\n            },\n            \"TE\": {\n                excellent: 15,\n                good: 12,\n                average: 9,\n                poor: 6\n            },\n            \"FLEX\": {\n                excellent: 20,\n                good: 15,\n                average: 12,\n                poor: 8\n            },\n            \"SUPERFLEX\": {\n                excellent: 25,\n                good: 20,\n                average: 15,\n                poor: 10\n            },\n            \"K\": {\n                excellent: 10,\n                good: 8,\n                average: 6,\n                poor: 4\n            },\n            \"DEF\": {\n                excellent: 12,\n                good: 9,\n                average: 7,\n                poor: 5\n            }\n        };\n        const threshold = thresholds[position] || thresholds[\"FLEX\"];\n        if (totalPoints >= threshold.excellent) grade = \"A+\";\n        else if (totalPoints >= threshold.good) grade = \"A\";\n        else if (totalPoints >= threshold.average) grade = \"B\";\n        else if (totalPoints >= threshold.poor) grade = \"C\";\n        else grade = \"D\";\n        return {\n            grade,\n            score: totalPoints,\n            reason: this.generatePositionReason(grade, 0, position)\n        };\n    }\n    getFlexPlayers(team, flexType) {\n        const flexPositions = flexType === \"SUPERFLEX\" ? [\n            \"QB\",\n            \"RB\",\n            \"WR\",\n            \"TE\"\n        ] : [\n            \"RB\",\n            \"WR\",\n            \"TE\"\n        ];\n        const allFlexPlayers = [];\n        // Look at the roster for flex players, not the optimal lineup\n        if (!team.roster) return [];\n        flexPositions.forEach((pos)=>{\n            const players = (team.roster || []).filter((p)=>(p.position || \"\").toUpperCase() === pos);\n            allFlexPlayers.push(...players);\n        });\n        // Sort by projected points and take top players\n        return allFlexPlayers.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0)).slice(0, 3); // Top 3 for flex grading\n    }\n    getPositionPlayers(team, position) {\n        // For regular positions (QB, RB, WR, TE, K, DEF), look at the roster\n        if (position !== \"FLEX\" && position !== \"SUPERFLEX\") {\n            if (!team.roster) return [];\n            return (team.roster || []).filter((p)=>(p.position || \"\").toUpperCase() === position);\n        }\n        // For flex positions, look at the optimal lineup\n        if (!team.optimalLineup || !team.optimalLineup[position]) return [];\n        return team.optimalLineup[position] || [];\n    }\n    calculateOverallGrade(team, positionGrades, settings = {}) {\n        // Calculate weighted overall score based on position grades\n        const leagueType = settings.leagueType || \"standard\";\n        const superflexSlots = settings.superflexSlots || 0;\n        const positionWeights = {\n            \"QB\": leagueType === \"superflex\" ? 1.4 : 1.2,\n            \"RB\": 1.0,\n            \"WR\": 1.0,\n            \"TE\": 0.9,\n            \"FLEX\": 0.8,\n            \"SUPERFLEX\": leagueType === \"superflex\" ? 1.3 : 0.8,\n            \"K\": 0.3,\n            \"DEF\": 0.4 // Defense less important\n        };\n        let totalWeightedScore = 0;\n        let totalWeight = 0;\n        Object.entries(positionGrades).forEach(([pos, grade])=>{\n            if (grade && grade.grade !== \"‚Äî\") {\n                const weight = positionWeights[pos] || 1.0;\n                const gradeScore = this.gradeToScore(grade.grade);\n                totalWeightedScore += gradeScore * weight;\n                totalWeight += weight;\n            }\n        });\n        if (totalWeight === 0) return {\n            grade: \"‚Äî\",\n            score: 0\n        };\n        const overallScore = totalWeightedScore / totalWeight;\n        const overallGrade = this.scoreToGrade(overallScore);\n        return {\n            grade: overallGrade,\n            score: overallScore,\n            totalWeightedScore,\n            totalWeight\n        };\n    }\n    gradePosition(players, position) {\n        if (players.length === 0) return {\n            grade: \"‚Äî\",\n            score: 0,\n            reason: \"No players\"\n        };\n        const totalPoints = players.reduce((sum, p)=>sum + (p.projectedPoints || 0), 0);\n        const avgVorp = players.reduce((sum, p)=>sum + (p.vorpScore || 0), 0) / players.length;\n        // Get league average for this position\n        const leagueAvg = this.leagueAverages[position] || 0;\n        const leagueStdDev = this.leagueStdDevs[position] || 1;\n        // Calculate z-score\n        const zScore = leagueStdDev > 0 ? (totalPoints - leagueAvg) / leagueStdDev : 0;\n        // Convert to grade\n        const grade = this.zScoreToGrade(zScore);\n        return {\n            grade,\n            score: totalPoints,\n            zScore,\n            avgVorp,\n            reason: this.generatePositionReason(grade, zScore, position)\n        };\n    }\n    zScoreToGrade(zScore) {\n        if (zScore >= 1.5) return \"A+\";\n        if (zScore >= 1.0) return \"A\";\n        if (zScore >= 0.5) return \"B+\";\n        if (zScore >= 0.0) return \"B\";\n        if (zScore >= -0.5) return \"C+\";\n        if (zScore >= -1.0) return \"C\";\n        if (zScore >= -1.5) return \"D+\";\n        if (zScore >= -2.0) return \"D\";\n        return \"F\";\n    }\n    gradeToScore(grade) {\n        const gradeScores = {\n            \"A+\": 95,\n            \"A\": 90,\n            \"A-\": 85,\n            \"B+\": 80,\n            \"B\": 75,\n            \"B-\": 70,\n            \"C+\": 65,\n            \"C\": 60,\n            \"C-\": 55,\n            \"D+\": 50,\n            \"D\": 45,\n            \"D-\": 40,\n            \"F\": 30\n        };\n        return gradeScores[grade] || 50;\n    }\n    scoreToGrade(score) {\n        // Realistic scoring thresholds based on actual fantasy football performance\n        // These thresholds allow for genuine grade distribution based on team quality\n        if (score >= 200) return \"A+\"; // Exceptional team\n        if (score >= 185) return \"A\"; // Excellent team  \n        if (score >= 170) return \"A-\"; // Very good team\n        if (score >= 155) return \"B+\"; // Good team\n        if (score >= 140) return \"B\"; // Above average team\n        if (score >= 125) return \"B-\"; // Slightly above average\n        if (score >= 110) return \"C+\"; // Average team\n        if (score >= 95) return \"C\"; // Below average team\n        if (score >= 80) return \"C-\"; // Poor team\n        if (score >= 65) return \"D+\"; // Very poor team\n        if (score >= 50) return \"D\"; // Terrible team\n        return \"F\"; // Complete failure\n    }\n    generatePositionReason(grade, zScore, position) {\n        if (grade.startsWith(\"A\")) return `Excellent ${position} performance`;\n        if (grade.startsWith(\"B\")) return `Good ${position} performance`;\n        if (grade.startsWith(\"C\")) return `Average ${position} performance`;\n        if (grade.startsWith(\"D\")) return `Below average ${position} performance`;\n        return `Poor ${position} performance`;\n    }\n    calculateLeagueStats(teams, positionRequirements) {\n        const positionStats = {};\n        // Initialize position stats\n        positionRequirements.forEach((pos)=>{\n            positionStats[pos] = {\n                points: [],\n                vorp: []\n            };\n        });\n        // Collect all player stats across teams\n        teams.forEach((team)=>{\n            (team.roster || []).forEach((player)=>{\n                const pos = (player.position || \"\").toUpperCase();\n                if (!pos || !positionStats[pos]) return;\n                const points = player.projectedPoints || 0;\n                const vorp = this.getPlayerVorp(player.playerName || player.name || \"\");\n                positionStats[pos].points.push(points);\n                positionStats[pos].vorp.push(vorp);\n            });\n        });\n        // Calculate averages and standard deviations\n        Object.keys(positionStats).forEach((pos)=>{\n            const points = positionStats[pos].points.filter((p)=>p > 0);\n            const vorp = positionStats[pos].vorp.filter((v)=>v !== 0);\n            if (points.length > 0) {\n                this.leagueAverages[pos] = points.reduce((sum, p)=>sum + p, 0) / points.length;\n                this.leagueStdDevs[pos] = this.calculateStdDev(points, this.leagueAverages[pos]);\n            }\n            if (vorp.length > 0) {\n                this.leagueAverages[`${pos}_VORP`] = vorp.reduce((sum, v)=>sum + v, 0) / vorp.length;\n                this.leagueStdDevs[`${pos}_VORP`] = this.calculateStdDev(vorp, this.leagueAverages[`${pos}_VORP`]);\n            }\n        });\n    }\n    calculateStdDev(values, mean) {\n        if (values.length <= 1) return 0;\n        const variance = values.reduce((sum, val)=>sum + Math.pow(val - mean, 2), 0) / values.length;\n        return Math.sqrt(variance);\n    }\n    getPlayerVorp(playerName) {\n        if (!playerName) return 0;\n        const normalizedName = playerName.toLowerCase();\n        return this.vorpLookup[normalizedName] || 0;\n    }\n    getPositionRequirements(leagueType = \"standard\", actualTeams = 12, actualRounds = 16) {\n        // Fixed starter requirements - bench size scales with rounds, not starters\n        const baseRequirements = {\n            standard: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            superflex: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"QB\",\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2qb\": {\n                QB: 2,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2flex\": {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 2,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            }\n        };\n        const requirements = baseRequirements[leagueType] || baseRequirements.standard;\n        // Calculate total starters (fixed, doesn't change with rounds)\n        const totalStarters = Object.entries(requirements).filter(([key])=>![\n                \"flexPositions\",\n                \"superflexPositions\"\n            ].includes(key)).reduce((sum, [_, count])=>sum + (typeof count === \"number\" ? count : 0), 0);\n        return {\n            ...requirements,\n            totalStarters,\n            _metadata: {\n                actualTeams,\n                actualRounds,\n                leagueType,\n                calculatedAt: new Date().toISOString()\n            }\n        };\n    }\n    // Calculate replacement baselines for VORP calculations\n    calculateReplacementBaselines(settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const superflexSlots = settings.superflexSlots || 0;\n        const teams = settings.teams || 12;\n        const baselines = {\n            QB: teams * (1 + superflexSlots),\n            RB: teams * 2,\n            WR: teams * 2,\n            TE: teams * 1,\n            K: teams * 1,\n            DEF: teams * 1\n        };\n        return baselines;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ1hvRyxLQUFLcEcsUUFBUTtRQUNmO1FBRUEsT0FBT2dIO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZmX2FwaV9za2VsZXRvbi8uL2FwcC9saWIvcG9zaXRpb24tZ3JhZGUtZW5naW5lLnRzPzJhYjEiXSwic291cmNlc0NvbnRlbnQiOlsidHlwZSBMZWFndWVTZXR0aW5ncyA9IHtcbiAgc2NvcmluZz86IHN0cmluZztcbiAgbGVhZ3VlVHlwZT86IHN0cmluZztcbiAgc3VwZXJmbGV4U2xvdHM/OiBudW1iZXI7XG4gIHRlYW1zPzogbnVtYmVyO1xuICByb3VuZHM/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbkdyYWRlRW5naW5lIHtcbiAgcHJpdmF0ZSB2b3JwTG9va3VwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIHByaXZhdGUgbGVhZ3VlQXZlcmFnZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgcHJpdmF0ZSBsZWFndWVTdGREZXZzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgY29uc3RydWN0b3Iodm9ycEFycmF5OiBBcnJheTx7IHBsYXllck5hbWU/OiBzdHJpbmc7IHZvcnBfc2NvcmU/OiBudW1iZXI7IHZvcnBTY29yZT86IG51bWJlciB9PiA9IFtdKSB7XG4gICAgdm9ycEFycmF5LmZvckVhY2goKHApID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSAocC5wbGF5ZXJOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgdmFsID0gKHAgYXMgYW55KS52b3JwU2NvcmUgPz8gcC52b3JwX3Njb3JlID8/IDA7XG4gICAgICBpZiAobmFtZSkgdGhpcy52b3JwTG9va3VwW25hbWVdID0gTnVtYmVyKHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVQb3NpdGlvbkdyYWRlcyh0ZWFtczogYW55W10sIHNldHRpbmdzOiBMZWFndWVTZXR0aW5ncyA9IHt9KSB7XG4gICAgY29uc3QgbGVhZ3VlVHlwZSA9IHNldHRpbmdzLmxlYWd1ZVR5cGUgfHwgJ3N0YW5kYXJkJztcbiAgICBjb25zdCBhY3R1YWxUZWFtcyA9IHNldHRpbmdzLnRlYW1zIHx8IDEyO1xuICAgIGNvbnN0IGFjdHVhbFJvdW5kcyA9IHNldHRpbmdzLnJvdW5kcyB8fCAxNjtcbiAgICBcbiAgICAvLyBHZXQgZHluYW1pYyBwb3NpdGlvbiByZXF1aXJlbWVudHMgYmFzZWQgb24gYWN0dWFsIGRyYWZ0IGRhdGFcbiAgICBjb25zdCBwb3NpdGlvblJlcXVpcmVtZW50cyA9IHRoaXMuZ2V0UG9zaXRpb25SZXF1aXJlbWVudHMobGVhZ3VlVHlwZSwgYWN0dWFsVGVhbXMsIGFjdHVhbFJvdW5kcyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogUG9zaXRpb24gZ3JhZGUgY2FsY3VsYXRpb246Jywge1xuICAgICAgbGVhZ3VlVHlwZSxcbiAgICAgIGFjdHVhbFRlYW1zLFxuICAgICAgYWN0dWFsUm91bmRzLFxuICAgICAgcG9zaXRpb25SZXF1aXJlbWVudHM6IHtcbiAgICAgICAgLi4ucG9zaXRpb25SZXF1aXJlbWVudHMsXG4gICAgICAgIF9tZXRhZGF0YTogcG9zaXRpb25SZXF1aXJlbWVudHMuX21ldGFkYXRhXG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGdyYWRlcyBmb3IgZWFjaCB0ZWFtIGZpcnN0XG4gICAgY29uc3QgdGVhbXNXaXRoUG9zaXRpb25HcmFkZXMgPSB0ZWFtcy5tYXAodGVhbSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbkdyYWRlcyA9IHRoaXMuY2FsY3VsYXRlVGVhbVBvc2l0aW9uR3JhZGVzKHRlYW0sIHBvc2l0aW9uUmVxdWlyZW1lbnRzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRlYW0sXG4gICAgICAgIHBvc2l0aW9uR3JhZGVzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvdmVyYWxsIGdyYWRlcyBiYXNlZCBvbiBhY3R1YWwgcGVyZm9ybWFuY2UsIG5vdCBmb3JjZWQgcGVyY2VudGlsZXNcbiAgICBjb25zdCB0ZWFtc1dpdGhPdmVyYWxsU2NvcmVzID0gdGVhbXNXaXRoUG9zaXRpb25HcmFkZXMubWFwKHRlYW0gPT4ge1xuICAgICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgc2NvcmUgYmFzZWQgb24gb3B0aW1hbCBsaW5ldXAgcG9pbnRzXG4gICAgICBjb25zdCBvdmVyYWxsU2NvcmUgPSB0ZWFtLm9wdGltYWxMaW5ldXBQb2ludHMgfHwgMDtcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCB0byBsZXR0ZXIgZ3JhZGUgYmFzZWQgb24gYWN0dWFsIHBlcmZvcm1hbmNlIHRocmVzaG9sZHNcbiAgICAgIGNvbnN0IG92ZXJhbGxHcmFkZSA9IHRoaXMuc2NvcmVUb0dyYWRlKG92ZXJhbGxTY29yZSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRlYW0sXG4gICAgICAgIG92ZXJhbGxHcmFkZToge1xuICAgICAgICAgIGdyYWRlOiBvdmVyYWxsR3JhZGUsXG4gICAgICAgICAgc2NvcmU6IG92ZXJhbGxTY29yZSxcbiAgICAgICAgICByYXdTY29yZTogb3ZlcmFsbFNjb3JlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRlYW1zV2l0aE92ZXJhbGxTY29yZXM7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZVRlYW1Qb3NpdGlvbkdyYWRlcyh0ZWFtOiBhbnksIHBvc2l0aW9uUmVxdWlyZW1lbnRzOiBhbnkpIHtcbiAgICBjb25zdCBwb3NpdGlvbkdyYWRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgIFxuICAgIC8vIEV4dHJhY3QgcG9zaXRpb24gbmFtZXMgZnJvbSB0aGUgcmVxdWlyZW1lbnRzIG9iamVjdCAoZXhjbHVkaW5nIG1ldGFkYXRhIGFuZCBmbGV4UG9zaXRpb25zKVxuICAgIGNvbnN0IHBvc2l0aW9uTmFtZXMgPSBPYmplY3Qua2V5cyhwb3NpdGlvblJlcXVpcmVtZW50cykuZmlsdGVyKGtleSA9PiBcbiAgICAgICFbJ2ZsZXhQb3NpdGlvbnMnLCAnc3VwZXJmbGV4UG9zaXRpb25zJywgJ3RvdGFsU3RhcnRlcnMnLCAnX21ldGFkYXRhJ10uaW5jbHVkZXMoa2V5KVxuICAgICk7XG4gICAgXG4gICAgcG9zaXRpb25OYW1lcy5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICBpZiAocG9zID09PSAnRkxFWCcgfHwgcG9zID09PSAnU1VQRVJGTEVYJykge1xuICAgICAgICAvLyBIYW5kbGUgZmxleCBwb3NpdGlvbnMgc3BlY2lhbGx5XG4gICAgICAgIGNvbnN0IGZsZXhQbGF5ZXJzID0gdGhpcy5nZXRGbGV4UGxheWVycyh0ZWFtLCBwb3MpO1xuICAgICAgICBpZiAoZmxleFBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGdyYWRlID0gdGhpcy5ncmFkZVBvc2l0aW9uU2ltcGxlKGZsZXhQbGF5ZXJzLCBwb3MpO1xuICAgICAgICAgIHBvc2l0aW9uR3JhZGVzW3Bvc10gPSBncmFkZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIHJlZ3VsYXIgcG9zaXRpb25zXG4gICAgICAgIGNvbnN0IHBsYXllcnMgPSB0aGlzLmdldFBvc2l0aW9uUGxheWVycyh0ZWFtLCBwb3MpO1xuICAgICAgICBpZiAocGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZ3JhZGUgPSB0aGlzLmdyYWRlUG9zaXRpb25TaW1wbGUocGxheWVycywgcG9zKTtcbiAgICAgICAgICBwb3NpdGlvbkdyYWRlc1twb3NdID0gZ3JhZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcG9zaXRpb25HcmFkZXM7XG4gIH1cblxuICBwcml2YXRlIGdyYWRlUG9zaXRpb25TaW1wbGUocGxheWVyczogYW55W10sIHBvc2l0aW9uOiBzdHJpbmcpIHtcbiAgICBpZiAocGxheWVycy5sZW5ndGggPT09IDApIHJldHVybiB7IGdyYWRlOiAn4oCUJywgc2NvcmU6IDAsIHJlYXNvbjogJ05vIHBsYXllcnMnIH07XG4gICAgXG4gICAgY29uc3QgdG90YWxQb2ludHMgPSBwbGF5ZXJzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyAocC5wcm9qZWN0ZWRQb2ludHMgfHwgMCksIDApO1xuICAgIFxuICAgIC8vIFNpbXBsZSBncmFkaW5nIGJhc2VkIG9uIHByb2plY3RlZCBwb2ludHMgdGhyZXNob2xkcyBmb3IgZGlmZmVyZW50IHBvc2l0aW9uc1xuICAgIGxldCBncmFkZSA9ICdDJztcbiAgICBsZXQgZ3JhZGVTY29yZSA9IHRvdGFsUG9pbnRzO1xuICAgIFxuICAgIC8vIFBvc2l0aW9uLXNwZWNpZmljIHNjb3JpbmcgdGhyZXNob2xkcyAoYXBwcm94aW1hdGUpXG4gICAgY29uc3QgdGhyZXNob2xkczogUmVjb3JkPHN0cmluZywgeyBleGNlbGxlbnQ6IG51bWJlciwgZ29vZDogbnVtYmVyLCBhdmVyYWdlOiBudW1iZXIsIHBvb3I6IG51bWJlciB9PiA9IHtcbiAgICAgICdRQic6IHsgZXhjZWxsZW50OiAyNSwgZ29vZDogMjIsIGF2ZXJhZ2U6IDE4LCBwb29yOiAxNSB9LFxuICAgICAgJ1JCJzogeyBleGNlbGxlbnQ6IDQwLCBnb29kOiAzMCwgYXZlcmFnZTogMjIsIHBvb3I6IDE1IH0sIC8vIDIgUkJzXG4gICAgICAnV1InOiB7IGV4Y2VsbGVudDogNDAsIGdvb2Q6IDMwLCBhdmVyYWdlOiAyMiwgcG9vcjogMTUgfSwgLy8gMiBXUnMgIFxuICAgICAgJ1RFJzogeyBleGNlbGxlbnQ6IDE1LCBnb29kOiAxMiwgYXZlcmFnZTogOSwgcG9vcjogNiB9LFxuICAgICAgJ0ZMRVgnOiB7IGV4Y2VsbGVudDogMjAsIGdvb2Q6IDE1LCBhdmVyYWdlOiAxMiwgcG9vcjogOCB9LFxuICAgICAgJ1NVUEVSRkxFWCc6IHsgZXhjZWxsZW50OiAyNSwgZ29vZDogMjAsIGF2ZXJhZ2U6IDE1LCBwb29yOiAxMCB9LCAvLyBRQiBwcmlvcml0eSBpbiBzdXBlcmZsZXhcbiAgICAgICdLJzogeyBleGNlbGxlbnQ6IDEwLCBnb29kOiA4LCBhdmVyYWdlOiA2LCBwb29yOiA0IH0sXG4gICAgICAnREVGJzogeyBleGNlbGxlbnQ6IDEyLCBnb29kOiA5LCBhdmVyYWdlOiA3LCBwb29yOiA1IH1cbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRocmVzaG9sZHNbcG9zaXRpb25dIHx8IHRocmVzaG9sZHNbJ0ZMRVgnXTtcbiAgICBcbiAgICBpZiAodG90YWxQb2ludHMgPj0gdGhyZXNob2xkLmV4Y2VsbGVudCkgZ3JhZGUgPSAnQSsnO1xuICAgIGVsc2UgaWYgKHRvdGFsUG9pbnRzID49IHRocmVzaG9sZC5nb29kKSBncmFkZSA9ICdBJztcbiAgICBlbHNlIGlmICh0b3RhbFBvaW50cyA+PSB0aHJlc2hvbGQuYXZlcmFnZSkgZ3JhZGUgPSAnQic7XG4gICAgZWxzZSBpZiAodG90YWxQb2ludHMgPj0gdGhyZXNob2xkLnBvb3IpIGdyYWRlID0gJ0MnO1xuICAgIGVsc2UgZ3JhZGUgPSAnRCc7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGdyYWRlLFxuICAgICAgc2NvcmU6IHRvdGFsUG9pbnRzLFxuICAgICAgcmVhc29uOiB0aGlzLmdlbmVyYXRlUG9zaXRpb25SZWFzb24oZ3JhZGUsIDAsIHBvc2l0aW9uKVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldEZsZXhQbGF5ZXJzKHRlYW06IGFueSwgZmxleFR5cGU6IHN0cmluZykge1xuICAgIGNvbnN0IGZsZXhQb3NpdGlvbnMgPSBmbGV4VHlwZSA9PT0gJ1NVUEVSRkxFWCcgPyBbJ1FCJywgJ1JCJywgJ1dSJywgJ1RFJ10gOiBbJ1JCJywgJ1dSJywgJ1RFJ107XG4gICAgY29uc3QgYWxsRmxleFBsYXllcnM6IGFueVtdID0gW107XG4gICAgXG4gICAgLy8gTG9vayBhdCB0aGUgcm9zdGVyIGZvciBmbGV4IHBsYXllcnMsIG5vdCB0aGUgb3B0aW1hbCBsaW5ldXBcbiAgICBpZiAoIXRlYW0ucm9zdGVyKSByZXR1cm4gW107XG4gICAgXG4gICAgZmxleFBvc2l0aW9ucy5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICBjb25zdCBwbGF5ZXJzID0gKHRlYW0ucm9zdGVyIHx8IFtdKS5maWx0ZXIoKHA6IGFueSkgPT4gXG4gICAgICAgIChwLnBvc2l0aW9uIHx8ICcnKS50b1VwcGVyQ2FzZSgpID09PSBwb3NcbiAgICAgICk7XG4gICAgICBhbGxGbGV4UGxheWVycy5wdXNoKC4uLnBsYXllcnMpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNvcnQgYnkgcHJvamVjdGVkIHBvaW50cyBhbmQgdGFrZSB0b3AgcGxheWVyc1xuICAgIHJldHVybiBhbGxGbGV4UGxheWVyc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IChiLnByb2plY3RlZFBvaW50cyB8fCAwKSAtIChhLnByb2plY3RlZFBvaW50cyB8fCAwKSlcbiAgICAgIC5zbGljZSgwLCAzKTsgLy8gVG9wIDMgZm9yIGZsZXggZ3JhZGluZ1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQb3NpdGlvblBsYXllcnModGVhbTogYW55LCBwb3NpdGlvbjogc3RyaW5nKSB7XG4gICAgLy8gRm9yIHJlZ3VsYXIgcG9zaXRpb25zIChRQiwgUkIsIFdSLCBURSwgSywgREVGKSwgbG9vayBhdCB0aGUgcm9zdGVyXG4gICAgaWYgKHBvc2l0aW9uICE9PSAnRkxFWCcgJiYgcG9zaXRpb24gIT09ICdTVVBFUkZMRVgnKSB7XG4gICAgICBpZiAoIXRlYW0ucm9zdGVyKSByZXR1cm4gW107XG4gICAgICByZXR1cm4gKHRlYW0ucm9zdGVyIHx8IFtdKS5maWx0ZXIoKHA6IGFueSkgPT4gXG4gICAgICAgIChwLnBvc2l0aW9uIHx8ICcnKS50b1VwcGVyQ2FzZSgpID09PSBwb3NpdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yIGZsZXggcG9zaXRpb25zLCBsb29rIGF0IHRoZSBvcHRpbWFsIGxpbmV1cFxuICAgIGlmICghdGVhbS5vcHRpbWFsTGluZXVwIHx8ICF0ZWFtLm9wdGltYWxMaW5ldXBbcG9zaXRpb25dKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHRlYW0ub3B0aW1hbExpbmV1cFtwb3NpdGlvbl0gfHwgW107XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU92ZXJhbGxHcmFkZSh0ZWFtOiBhbnksIHBvc2l0aW9uR3JhZGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBzZXR0aW5nczogTGVhZ3VlU2V0dGluZ3MgPSB7fSkge1xuICAgIC8vIENhbGN1bGF0ZSB3ZWlnaHRlZCBvdmVyYWxsIHNjb3JlIGJhc2VkIG9uIHBvc2l0aW9uIGdyYWRlc1xuICAgIGNvbnN0IGxlYWd1ZVR5cGUgPSBzZXR0aW5ncy5sZWFndWVUeXBlIHx8ICdzdGFuZGFyZCc7XG4gICAgY29uc3Qgc3VwZXJmbGV4U2xvdHMgPSBzZXR0aW5ncy5zdXBlcmZsZXhTbG90cyB8fCAwO1xuICAgIFxuICAgIGNvbnN0IHBvc2l0aW9uV2VpZ2h0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAgICdRQic6IGxlYWd1ZVR5cGUgPT09ICdzdXBlcmZsZXgnID8gMS40IDogMS4yLCAgICAvLyBRQiBnZXRzIHByZW1pdW0gaW4gc3VwZXJmbGV4XG4gICAgICAnUkInOiAxLjAsICAgIC8vIFJCIGlzIGJhc2VsaW5lXG4gICAgICAnV1InOiAxLjAsICAgIC8vIFdSIGlzIGJhc2VsaW5lXG4gICAgICAnVEUnOiAwLjksICAgIC8vIFRFIHNsaWdodGx5IGxlc3MgaW1wb3J0YW50XG4gICAgICAnRkxFWCc6IDAuOCwgIC8vIEZsZXggaXMgYm9udXNcbiAgICAgICdTVVBFUkZMRVgnOiBsZWFndWVUeXBlID09PSAnc3VwZXJmbGV4JyA/IDEuMyA6IDAuOCwgLy8gU3VwZXJmbGV4IGlzIHByZW1pdW0gaW4gc3VwZXJmbGV4IGxlYWd1ZXNcbiAgICAgICdLJzogMC4zLCAgICAgLy8gS2lja2VyIG11Y2ggbGVzcyBpbXBvcnRhbnRcbiAgICAgICdERUYnOiAwLjQgICAgLy8gRGVmZW5zZSBsZXNzIGltcG9ydGFudFxuICAgIH07XG4gICAgXG4gICAgbGV0IHRvdGFsV2VpZ2h0ZWRTY29yZSA9IDA7XG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcbiAgICBcbiAgICBPYmplY3QuZW50cmllcyhwb3NpdGlvbkdyYWRlcykuZm9yRWFjaCgoW3BvcywgZ3JhZGVdKSA9PiB7XG4gICAgICBpZiAoZ3JhZGUgJiYgZ3JhZGUuZ3JhZGUgIT09ICfigJQnKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IHBvc2l0aW9uV2VpZ2h0c1twb3NdIHx8IDEuMDtcbiAgICAgICAgY29uc3QgZ3JhZGVTY29yZSA9IHRoaXMuZ3JhZGVUb1Njb3JlKGdyYWRlLmdyYWRlKTtcbiAgICAgICAgdG90YWxXZWlnaHRlZFNjb3JlICs9IGdyYWRlU2NvcmUgKiB3ZWlnaHQ7XG4gICAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAodG90YWxXZWlnaHQgPT09IDApIHJldHVybiB7IGdyYWRlOiAn4oCUJywgc2NvcmU6IDAgfTtcbiAgICBcbiAgICBjb25zdCBvdmVyYWxsU2NvcmUgPSB0b3RhbFdlaWdodGVkU2NvcmUgLyB0b3RhbFdlaWdodDtcbiAgICBjb25zdCBvdmVyYWxsR3JhZGUgPSB0aGlzLnNjb3JlVG9HcmFkZShvdmVyYWxsU2NvcmUpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBncmFkZTogb3ZlcmFsbEdyYWRlLFxuICAgICAgc2NvcmU6IG92ZXJhbGxTY29yZSxcbiAgICAgIHRvdGFsV2VpZ2h0ZWRTY29yZSxcbiAgICAgIHRvdGFsV2VpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ3JhZGVQb3NpdGlvbihwbGF5ZXJzOiBhbnlbXSwgcG9zaXRpb246IHN0cmluZykge1xuICAgIGlmIChwbGF5ZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgZ3JhZGU6ICfigJQnLCBzY29yZTogMCwgcmVhc29uOiAnTm8gcGxheWVycycgfTtcbiAgICBcbiAgICBjb25zdCB0b3RhbFBvaW50cyA9IHBsYXllcnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIChwLnByb2plY3RlZFBvaW50cyB8fCAwKSwgMCk7XG4gICAgY29uc3QgYXZnVm9ycCA9IHBsYXllcnMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIChwLnZvcnBTY29yZSB8fCAwKSwgMCkgLyBwbGF5ZXJzLmxlbmd0aDtcbiAgICBcbiAgICAvLyBHZXQgbGVhZ3VlIGF2ZXJhZ2UgZm9yIHRoaXMgcG9zaXRpb25cbiAgICBjb25zdCBsZWFndWVBdmcgPSB0aGlzLmxlYWd1ZUF2ZXJhZ2VzW3Bvc2l0aW9uXSB8fCAwO1xuICAgIGNvbnN0IGxlYWd1ZVN0ZERldiA9IHRoaXMubGVhZ3VlU3RkRGV2c1twb3NpdGlvbl0gfHwgMTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgei1zY29yZVxuICAgIGNvbnN0IHpTY29yZSA9IGxlYWd1ZVN0ZERldiA+IDAgPyAodG90YWxQb2ludHMgLSBsZWFndWVBdmcpIC8gbGVhZ3VlU3RkRGV2IDogMDtcbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGdyYWRlXG4gICAgY29uc3QgZ3JhZGUgPSB0aGlzLnpTY29yZVRvR3JhZGUoelNjb3JlKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgZ3JhZGUsXG4gICAgICBzY29yZTogdG90YWxQb2ludHMsXG4gICAgICB6U2NvcmUsXG4gICAgICBhdmdWb3JwLFxuICAgICAgcmVhc29uOiB0aGlzLmdlbmVyYXRlUG9zaXRpb25SZWFzb24oZ3JhZGUsIHpTY29yZSwgcG9zaXRpb24pXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgelNjb3JlVG9HcmFkZSh6U2NvcmU6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKHpTY29yZSA+PSAxLjUpIHJldHVybiAnQSsnO1xuICAgIGlmICh6U2NvcmUgPj0gMS4wKSByZXR1cm4gJ0EnO1xuICAgIGlmICh6U2NvcmUgPj0gMC41KSByZXR1cm4gJ0IrJztcbiAgICBpZiAoelNjb3JlID49IDAuMCkgcmV0dXJuICdCJztcbiAgICBpZiAoelNjb3JlID49IC0wLjUpIHJldHVybiAnQysnO1xuICAgIGlmICh6U2NvcmUgPj0gLTEuMCkgcmV0dXJuICdDJztcbiAgICBpZiAoelNjb3JlID49IC0xLjUpIHJldHVybiAnRCsnO1xuICAgIGlmICh6U2NvcmUgPj0gLTIuMCkgcmV0dXJuICdEJztcbiAgICByZXR1cm4gJ0YnO1xuICB9XG5cbiAgcHJpdmF0ZSBncmFkZVRvU2NvcmUoZ3JhZGU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgZ3JhZGVTY29yZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICAnQSsnOiA5NSwgJ0EnOiA5MCwgJ0EtJzogODUsXG4gICAgICAnQisnOiA4MCwgJ0InOiA3NSwgJ0ItJzogNzAsXG4gICAgICAnQysnOiA2NSwgJ0MnOiA2MCwgJ0MtJzogNTUsXG4gICAgICAnRCsnOiA1MCwgJ0QnOiA0NSwgJ0QtJzogNDAsXG4gICAgICAnRic6IDMwXG4gICAgfTtcbiAgICByZXR1cm4gZ3JhZGVTY29yZXNbZ3JhZGVdIHx8IDUwO1xuICB9XG5cbiAgcHJpdmF0ZSBzY29yZVRvR3JhZGUoc2NvcmU6IG51bWJlcik6IHN0cmluZyB7XG4gICAgLy8gUmVhbGlzdGljIHNjb3JpbmcgdGhyZXNob2xkcyBiYXNlZCBvbiBhY3R1YWwgZmFudGFzeSBmb290YmFsbCBwZXJmb3JtYW5jZVxuICAgIC8vIFRoZXNlIHRocmVzaG9sZHMgYWxsb3cgZm9yIGdlbnVpbmUgZ3JhZGUgZGlzdHJpYnV0aW9uIGJhc2VkIG9uIHRlYW0gcXVhbGl0eVxuICAgIFxuICAgIGlmIChzY29yZSA+PSAyMDApIHJldHVybiAnQSsnOyAgICAgIC8vIEV4Y2VwdGlvbmFsIHRlYW1cbiAgICBpZiAoc2NvcmUgPj0gMTg1KSByZXR1cm4gJ0EnOyAgICAgICAvLyBFeGNlbGxlbnQgdGVhbSAgXG4gICAgaWYgKHNjb3JlID49IDE3MCkgcmV0dXJuICdBLSc7ICAgICAgLy8gVmVyeSBnb29kIHRlYW1cbiAgICBpZiAoc2NvcmUgPj0gMTU1KSByZXR1cm4gJ0IrJzsgICAgICAvLyBHb29kIHRlYW1cbiAgICBpZiAoc2NvcmUgPj0gMTQwKSByZXR1cm4gJ0InOyAgICAgICAvLyBBYm92ZSBhdmVyYWdlIHRlYW1cbiAgICBpZiAoc2NvcmUgPj0gMTI1KSByZXR1cm4gJ0ItJzsgICAgICAvLyBTbGlnaHRseSBhYm92ZSBhdmVyYWdlXG4gICAgaWYgKHNjb3JlID49IDExMCkgcmV0dXJuICdDKyc7ICAgICAgLy8gQXZlcmFnZSB0ZWFtXG4gICAgaWYgKHNjb3JlID49IDk1KSByZXR1cm4gJ0MnOyAgICAgICAgLy8gQmVsb3cgYXZlcmFnZSB0ZWFtXG4gICAgaWYgKHNjb3JlID49IDgwKSByZXR1cm4gJ0MtJzsgICAgICAgLy8gUG9vciB0ZWFtXG4gICAgaWYgKHNjb3JlID49IDY1KSByZXR1cm4gJ0QrJzsgICAgICAgLy8gVmVyeSBwb29yIHRlYW1cbiAgICBpZiAoc2NvcmUgPj0gNTApIHJldHVybiAnRCc7ICAgICAgICAvLyBUZXJyaWJsZSB0ZWFtXG4gICAgcmV0dXJuICdGJzsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlIGZhaWx1cmVcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVQb3NpdGlvblJlYXNvbihncmFkZTogc3RyaW5nLCB6U2NvcmU6IG51bWJlciwgcG9zaXRpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKGdyYWRlLnN0YXJ0c1dpdGgoJ0EnKSkgcmV0dXJuIGBFeGNlbGxlbnQgJHtwb3NpdGlvbn0gcGVyZm9ybWFuY2VgO1xuICAgIGlmIChncmFkZS5zdGFydHNXaXRoKCdCJykpIHJldHVybiBgR29vZCAke3Bvc2l0aW9ufSBwZXJmb3JtYW5jZWA7XG4gICAgaWYgKGdyYWRlLnN0YXJ0c1dpdGgoJ0MnKSkgcmV0dXJuIGBBdmVyYWdlICR7cG9zaXRpb259IHBlcmZvcm1hbmNlYDtcbiAgICBpZiAoZ3JhZGUuc3RhcnRzV2l0aCgnRCcpKSByZXR1cm4gYEJlbG93IGF2ZXJhZ2UgJHtwb3NpdGlvbn0gcGVyZm9ybWFuY2VgO1xuICAgIHJldHVybiBgUG9vciAke3Bvc2l0aW9ufSBwZXJmb3JtYW5jZWA7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUxlYWd1ZVN0YXRzKHRlYW1zOiBhbnlbXSwgcG9zaXRpb25SZXF1aXJlbWVudHM6IHN0cmluZ1tdKSB7XG4gICAgY29uc3QgcG9zaXRpb25TdGF0czogUmVjb3JkPHN0cmluZywgeyBwb2ludHM6IG51bWJlcltdLCB2b3JwOiBudW1iZXJbXSB9PiA9IHt9O1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgcG9zaXRpb24gc3RhdHNcbiAgICBwb3NpdGlvblJlcXVpcmVtZW50cy5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICBwb3NpdGlvblN0YXRzW3Bvc10gPSB7IHBvaW50czogW10sIHZvcnA6IFtdIH07XG4gICAgfSk7XG5cbiAgICAvLyBDb2xsZWN0IGFsbCBwbGF5ZXIgc3RhdHMgYWNyb3NzIHRlYW1zXG4gICAgdGVhbXMuZm9yRWFjaCh0ZWFtID0+IHtcbiAgICAgICh0ZWFtLnJvc3RlciB8fCBbXSkuZm9yRWFjaCgocGxheWVyOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gKHBsYXllci5wb3NpdGlvbiB8fCAnJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKCFwb3MgfHwgIXBvc2l0aW9uU3RhdHNbcG9zXSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcG9pbnRzID0gcGxheWVyLnByb2plY3RlZFBvaW50cyB8fCAwO1xuICAgICAgICBjb25zdCB2b3JwID0gdGhpcy5nZXRQbGF5ZXJWb3JwKHBsYXllci5wbGF5ZXJOYW1lIHx8IHBsYXllci5uYW1lIHx8ICcnKTtcbiAgICAgICAgXG4gICAgICAgIHBvc2l0aW9uU3RhdHNbcG9zXS5wb2ludHMucHVzaChwb2ludHMpO1xuICAgICAgICBwb3NpdGlvblN0YXRzW3Bvc10udm9ycC5wdXNoKHZvcnApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgYXZlcmFnZXMgYW5kIHN0YW5kYXJkIGRldmlhdGlvbnNcbiAgICBPYmplY3Qua2V5cyhwb3NpdGlvblN0YXRzKS5mb3JFYWNoKHBvcyA9PiB7XG4gICAgICBjb25zdCBwb2ludHMgPSBwb3NpdGlvblN0YXRzW3Bvc10ucG9pbnRzLmZpbHRlcihwID0+IHAgPiAwKTtcbiAgICAgIGNvbnN0IHZvcnAgPSBwb3NpdGlvblN0YXRzW3Bvc10udm9ycC5maWx0ZXIodiA9PiB2ICE9PSAwKTtcbiAgICAgIFxuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMubGVhZ3VlQXZlcmFnZXNbcG9zXSA9IHBvaW50cy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgcCwgMCkgLyBwb2ludHMubGVuZ3RoO1xuICAgICAgICB0aGlzLmxlYWd1ZVN0ZERldnNbcG9zXSA9IHRoaXMuY2FsY3VsYXRlU3RkRGV2KHBvaW50cywgdGhpcy5sZWFndWVBdmVyYWdlc1twb3NdKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHZvcnAubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmxlYWd1ZUF2ZXJhZ2VzW2Ake3Bvc31fVk9SUGBdID0gdm9ycC5yZWR1Y2UoKHN1bSwgdikgPT4gc3VtICsgdiwgMCkgLyB2b3JwLmxlbmd0aDtcbiAgICAgICAgdGhpcy5sZWFndWVTdGREZXZzW2Ake3Bvc31fVk9SUGBdID0gdGhpcy5jYWxjdWxhdGVTdGREZXYodm9ycCwgdGhpcy5sZWFndWVBdmVyYWdlc1tgJHtwb3N9X1ZPUlBgXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZVN0ZERldih2YWx1ZXM6IG51bWJlcltdLCBtZWFuOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoIDw9IDEpIHJldHVybiAwO1xuICAgIGNvbnN0IHZhcmlhbmNlID0gdmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIE1hdGgucG93KHZhbCAtIG1lYW4sIDIpLCAwKSAvIHZhbHVlcy5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2YXJpYW5jZSk7XG4gIH1cblxuICBwcml2YXRlIGdldFBsYXllclZvcnAocGxheWVyTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBpZiAoIXBsYXllck5hbWUpIHJldHVybiAwO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gcGxheWVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB0aGlzLnZvcnBMb29rdXBbbm9ybWFsaXplZE5hbWVdIHx8IDA7XG4gIH1cblxuICBwcml2YXRlIGdldFBvc2l0aW9uUmVxdWlyZW1lbnRzKGxlYWd1ZVR5cGU6IHN0cmluZyA9ICdzdGFuZGFyZCcsIGFjdHVhbFRlYW1zOiBudW1iZXIgPSAxMiwgYWN0dWFsUm91bmRzOiBudW1iZXIgPSAxNikge1xuICAgIC8vIEZpeGVkIHN0YXJ0ZXIgcmVxdWlyZW1lbnRzIC0gYmVuY2ggc2l6ZSBzY2FsZXMgd2l0aCByb3VuZHMsIG5vdCBzdGFydGVyc1xuICAgIGNvbnN0IGJhc2VSZXF1aXJlbWVudHMgPSB7XG4gICAgICBzdGFuZGFyZDoge1xuICAgICAgICBRQjogMSwgUkI6IDIsIFdSOiAyLCBURTogMSwgRkxFWDogMSwgREVGOiAxLCBLOiAxLCAvLyA5IHN0YXJ0ZXJzXG4gICAgICAgIGZsZXhQb3NpdGlvbnM6IFsnUkInLCAnV1InLCAnVEUnXSxcbiAgICAgICAgc3VwZXJmbGV4UG9zaXRpb25zOiBbXVxuICAgICAgfSxcbiAgICAgIHN1cGVyZmxleDoge1xuICAgICAgICBRQjogMSwgUkI6IDIsIFdSOiAyLCBURTogMSwgRkxFWDogMSwgREVGOiAxLCBLOiAxLCAvLyA5IHN0YXJ0ZXJzIChRQiBlbGlnaWJsZSBpbiBmbGV4KVxuICAgICAgICBmbGV4UG9zaXRpb25zOiBbJ1FCJywgJ1JCJywgJ1dSJywgJ1RFJ10sXG4gICAgICAgIHN1cGVyZmxleFBvc2l0aW9uczogW11cbiAgICAgIH0sXG4gICAgICAnMnFiJzoge1xuICAgICAgICBRQjogMiwgUkI6IDIsIFdSOiAyLCBURTogMSwgRkxFWDogMSwgREVGOiAxLCBLOiAxLCAvLyAxMCBzdGFydGVyc1xuICAgICAgICBmbGV4UG9zaXRpb25zOiBbJ1JCJywgJ1dSJywgJ1RFJ10sXG4gICAgICAgIHN1cGVyZmxleFBvc2l0aW9uczogW11cbiAgICAgIH0sXG4gICAgICAnMmZsZXgnOiB7XG4gICAgICAgIFFCOiAxLCBSQjogMiwgV1I6IDIsIFRFOiAxLCBGTEVYOiAyLCBERUY6IDEsIEs6IDEsIC8vIDEwIHN0YXJ0ZXJzXG4gICAgICAgIGZsZXhQb3NpdGlvbnM6IFsnUkInLCAnV1InLCAnVEUnXSxcbiAgICAgICAgc3VwZXJmbGV4UG9zaXRpb25zOiBbXVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXF1aXJlbWVudHMgPSBiYXNlUmVxdWlyZW1lbnRzW2xlYWd1ZVR5cGUgYXMga2V5b2YgdHlwZW9mIGJhc2VSZXF1aXJlbWVudHNdIHx8IGJhc2VSZXF1aXJlbWVudHMuc3RhbmRhcmQ7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHN0YXJ0ZXJzIChmaXhlZCwgZG9lc24ndCBjaGFuZ2Ugd2l0aCByb3VuZHMpXG4gICAgY29uc3QgdG90YWxTdGFydGVycyA9IE9iamVjdC5lbnRyaWVzKHJlcXVpcmVtZW50cylcbiAgICAgIC5maWx0ZXIoKFtrZXldKSA9PiAhWydmbGV4UG9zaXRpb25zJywgJ3N1cGVyZmxleFBvc2l0aW9ucyddLmluY2x1ZGVzKGtleSkpXG4gICAgICAucmVkdWNlKChzdW0sIFtfLCBjb3VudF0pID0+IHN1bSArICh0eXBlb2YgY291bnQgPT09ICdudW1iZXInID8gY291bnQgOiAwKSwgMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVxdWlyZW1lbnRzLFxuICAgICAgdG90YWxTdGFydGVycyxcbiAgICAgIF9tZXRhZGF0YToge1xuICAgICAgICBhY3R1YWxUZWFtcyxcbiAgICAgICAgYWN0dWFsUm91bmRzLFxuICAgICAgICBsZWFndWVUeXBlLFxuICAgICAgICBjYWxjdWxhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgcmVwbGFjZW1lbnQgYmFzZWxpbmVzIGZvciBWT1JQIGNhbGN1bGF0aW9uc1xuICBjYWxjdWxhdGVSZXBsYWNlbWVudEJhc2VsaW5lcyhzZXR0aW5nczogTGVhZ3VlU2V0dGluZ3MgPSB7fSkge1xuICAgIGNvbnN0IGxlYWd1ZVR5cGUgPSBzZXR0aW5ncy5sZWFndWVUeXBlIHx8ICdzdGFuZGFyZCc7XG4gICAgY29uc3Qgc3VwZXJmbGV4U2xvdHMgPSBzZXR0aW5ncy5zdXBlcmZsZXhTbG90cyB8fCAwO1xuICAgIGNvbnN0IHRlYW1zID0gc2V0dGluZ3MudGVhbXMgfHwgMTI7XG4gICAgXG4gICAgY29uc3QgYmFzZWxpbmVzID0ge1xuICAgICAgUUI6IHRlYW1zICogKDEgKyBzdXBlcmZsZXhTbG90cyksIC8vIFFCIGRlbWFuZCBpbmNyZWFzZXMgd2l0aCBzdXBlcmZsZXggc2xvdHNcbiAgICAgIFJCOiB0ZWFtcyAqIDIsIC8vIFN0YW5kYXJkIFJCIGRlbWFuZFxuICAgICAgV1I6IHRlYW1zICogMiwgLy8gU3RhbmRhcmQgV1IgZGVtYW5kICBcbiAgICAgIFRFOiB0ZWFtcyAqIDEsIC8vIFN0YW5kYXJkIFRFIGRlbWFuZFxuICAgICAgSzogdGVhbXMgKiAxLFxuICAgICAgREVGOiB0ZWFtcyAqIDFcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBiYXNlbGluZXM7XG4gIH1cbn0gIl0sIm5hbWVzIjpbIlBvc2l0aW9uR3JhZGVFbmdpbmUiLCJjb25zdHJ1Y3RvciIsInZvcnBBcnJheSIsInZvcnBMb29rdXAiLCJsZWFndWVBdmVyYWdlcyIsImxlYWd1ZVN0ZERldnMiLCJmb3JFYWNoIiwicCIsIm5hbWUiLCJwbGF5ZXJOYW1lIiwidG9Mb3dlckNhc2UiLCJ2YWwiLCJ2b3JwU2NvcmUiLCJ2b3JwX3Njb3JlIiwiTnVtYmVyIiwiY2FsY3VsYXRlUG9zaXRpb25HcmFkZXMiLCJ0ZWFtcyIsInNldHRpbmdzIiwibGVhZ3VlVHlwZSIsImFjdHVhbFRlYW1zIiwiYWN0dWFsUm91bmRzIiwicm91bmRzIiwicG9zaXRpb25SZXF1aXJlbWVudHMiLCJnZXRQb3NpdGlvblJlcXVpcmVtZW50cyIsImNvbnNvbGUiLCJsb2ciLCJfbWV0YWRhdGEiLCJ0ZWFtc1dpdGhQb3NpdGlvbkdyYWRlcyIsIm1hcCIsInRlYW0iLCJwb3NpdGlvbkdyYWRlcyIsImNhbGN1bGF0ZVRlYW1Qb3NpdGlvbkdyYWRlcyIsInRlYW1zV2l0aE92ZXJhbGxTY29yZXMiLCJvdmVyYWxsU2NvcmUiLCJvcHRpbWFsTGluZXVwUG9pbnRzIiwib3ZlcmFsbEdyYWRlIiwic2NvcmVUb0dyYWRlIiwiZ3JhZGUiLCJzY29yZSIsInJhd1Njb3JlIiwicG9zaXRpb25OYW1lcyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJpbmNsdWRlcyIsInBvcyIsImZsZXhQbGF5ZXJzIiwiZ2V0RmxleFBsYXllcnMiLCJsZW5ndGgiLCJncmFkZVBvc2l0aW9uU2ltcGxlIiwicGxheWVycyIsImdldFBvc2l0aW9uUGxheWVycyIsInBvc2l0aW9uIiwicmVhc29uIiwidG90YWxQb2ludHMiLCJyZWR1Y2UiLCJzdW0iLCJwcm9qZWN0ZWRQb2ludHMiLCJncmFkZVNjb3JlIiwidGhyZXNob2xkcyIsImV4Y2VsbGVudCIsImdvb2QiLCJhdmVyYWdlIiwicG9vciIsInRocmVzaG9sZCIsImdlbmVyYXRlUG9zaXRpb25SZWFzb24iLCJmbGV4VHlwZSIsImZsZXhQb3NpdGlvbnMiLCJhbGxGbGV4UGxheWVycyIsInJvc3RlciIsInRvVXBwZXJDYXNlIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsInNsaWNlIiwib3B0aW1hbExpbmV1cCIsImNhbGN1bGF0ZU92ZXJhbGxHcmFkZSIsInN1cGVyZmxleFNsb3RzIiwicG9zaXRpb25XZWlnaHRzIiwidG90YWxXZWlnaHRlZFNjb3JlIiwidG90YWxXZWlnaHQiLCJlbnRyaWVzIiwid2VpZ2h0IiwiZ3JhZGVUb1Njb3JlIiwiZ3JhZGVQb3NpdGlvbiIsImF2Z1ZvcnAiLCJsZWFndWVBdmciLCJsZWFndWVTdGREZXYiLCJ6U2NvcmUiLCJ6U2NvcmVUb0dyYWRlIiwiZ3JhZGVTY29yZXMiLCJzdGFydHNXaXRoIiwiY2FsY3VsYXRlTGVhZ3VlU3RhdHMiLCJwb3NpdGlvblN0YXRzIiwicG9pbnRzIiwidm9ycCIsInBsYXllciIsImdldFBsYXllclZvcnAiLCJ2IiwiY2FsY3VsYXRlU3RkRGV2IiwidmFsdWVzIiwibWVhbiIsInZhcmlhbmNlIiwiTWF0aCIsInBvdyIsInNxcnQiLCJub3JtYWxpemVkTmFtZSIsImJhc2VSZXF1aXJlbWVudHMiLCJzdGFuZGFyZCIsIlFCIiwiUkIiLCJXUiIsIlRFIiwiRkxFWCIsIkRFRiIsIksiLCJzdXBlcmZsZXhQb3NpdGlvbnMiLCJzdXBlcmZsZXgiLCJyZXF1aXJlbWVudHMiLCJ0b3RhbFN0YXJ0ZXJzIiwiXyIsImNvdW50IiwiY2FsY3VsYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY2FsY3VsYXRlUmVwbGFjZW1lbnRCYXNlbGluZXMiLCJiYXNlbGluZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/lib/position-grade-engine.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();