"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/analyze-draft/route";
exports.ids = ["app/api/analyze-draft/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_kanikameister_Documents_ff_api_skeleton_app_api_analyze_draft_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/analyze-draft/route.ts */ \"(rsc)/./app/api/analyze-draft/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/analyze-draft/route\",\n        pathname: \"/api/analyze-draft\",\n        filename: \"route\",\n        bundlePath: \"app/api/analyze-draft/route\"\n    },\n    resolvedPagePath: \"/Users/kanikameister/Documents/ff_api_skeleton/app/api/analyze-draft/route.ts\",\n    nextConfigOutput,\n    userland: _Users_kanikameister_Documents_ff_api_skeleton_app_api_analyze_draft_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/analyze-draft/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZhbmFseXplLWRyYWZ0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZhbmFseXplLWRyYWZ0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGYW5hbHl6ZS1kcmFmdCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmthbmlrYW1laXN0ZXIlMkZEb2N1bWVudHMlMkZmZl9hcGlfc2tlbGV0b24lMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGa2FuaWthbWVpc3RlciUyRkRvY3VtZW50cyUyRmZmX2FwaV9za2VsZXRvbiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDNkI7QUFDMUc7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mZl9hcGlfc2tlbGV0b24vP2QxZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2thbmlrYW1laXN0ZXIvRG9jdW1lbnRzL2ZmX2FwaV9za2VsZXRvbi9hcHAvYXBpL2FuYWx5emUtZHJhZnQvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2FuYWx5emUtZHJhZnQvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9hbmFseXplLWRyYWZ0XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9hbmFseXplLWRyYWZ0L3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2thbmlrYW1laXN0ZXIvRG9jdW1lbnRzL2ZmX2FwaV9za2VsZXRvbi9hcHAvYXBpL2FuYWx5emUtZHJhZnQvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2FuYWx5emUtZHJhZnQvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/analyze-draft/route.ts":
/*!****************************************!*\
  !*** ./app/api/analyze-draft/route.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_optimal_lineup_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/optimal-lineup-engine */ \"(rsc)/./app/lib/optimal-lineup-engine.ts\");\n/* harmony import */ var _lib_position_grade_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/position-grade-engine */ \"(rsc)/./app/lib/position-grade-engine.ts\");\nconst runtime = \"nodejs\";\n\n\n\n// Draft Analyzer class converted for Next.js\nclass DraftAnalyzer {\n    async initialize() {\n        try {\n            console.log(\"\\uD83D\\uDE80 Initializing Draft Analyzer...\");\n            // Load consolidated player data via imports so Vercel bundles them\n            const [masterPlayersModule, nameLookupModule, vorpDataModule, adpDataModule] = await Promise.all([\n                __webpack_require__.e(/*! import() */ \"_rsc_data_consolidated_master-players_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! data/consolidated/master-players.json */ \"(rsc)/./data/consolidated/master-players.json\", 19)),\n                __webpack_require__.e(/*! import() */ \"_rsc_data_consolidated_name-lookup-index_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! data/consolidated/name-lookup-index.json */ \"(rsc)/./data/consolidated/name-lookup-index.json\", 19)),\n                __webpack_require__.e(/*! import() */ \"_rsc_data_consolidated_player-vorp-scores_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! data/consolidated/player-vorp-scores.json */ \"(rsc)/./data/consolidated/player-vorp-scores.json\", 19)),\n                __webpack_require__.e(/*! import() */ \"_rsc_adp_data_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../../adp_data.json */ \"(rsc)/./adp_data.json\", 19))\n            ]);\n            console.log(\"\\uD83D\\uDD0D Loaded modules:\", {\n                masterPlayers: !!masterPlayersModule,\n                nameLookup: !!nameLookupModule,\n                vorpData: !!vorpDataModule,\n                adpData: !!adpDataModule\n            });\n            // Create lookup by player name (case-insensitive)\n            const masterPlayers = masterPlayersModule.default.players;\n            console.log(\"\\uD83D\\uDD0D Master players structure:\", {\n                hasDefault: !!masterPlayersModule.default,\n                hasPlayers: !!masterPlayers,\n                playerCount: masterPlayers?.length || 0,\n                samplePlayer: masterPlayers?.[0]\n            });\n            this.consolidatedData = {};\n            masterPlayers.forEach((player)=>{\n                if (player.full_name) {\n                    // Store by both full_name and player_id for flexibility\n                    this.consolidatedData[player.full_name.toLowerCase()] = player;\n                    if (player.player_id) {\n                        this.consolidatedData[player.player_id.toLowerCase()] = player;\n                    }\n                }\n            });\n            this.nameLookupIndex = nameLookupModule.default;\n            this.vorpData = vorpDataModule.default.vorpScores || vorpDataModule.default;\n            // Create ADP lookup by player name - adp_data.json has players array\n            this.adpData = {};\n            const adpPlayers = adpDataModule.default.players || [];\n            console.log(\"\\uD83D\\uDD0D ADP data structure:\", {\n                hasDefault: !!adpDataModule.default,\n                hasPlayers: !!adpPlayers,\n                playerCount: adpPlayers?.length || 0,\n                samplePlayer: adpPlayers?.[0]\n            });\n            adpPlayers.forEach((player)=>{\n                if (player.full_name) {\n                    this.adpData[player.full_name.toLowerCase()] = player;\n                }\n            });\n            console.log(`✅ Draft Analyzer initialized with ${Object.keys(this.consolidatedData).length} players and ${Object.keys(this.adpData).length} ADP records.`);\n            console.log(`🔍 Sample consolidated players:`, Object.keys(this.consolidatedData).slice(0, 5));\n            console.log(`🔍 Sample ADP players:`, Object.keys(this.adpData).slice(0, 5));\n        } catch (error) {\n            console.error(\"❌ Failed to initialize Draft Analyzer:\", error);\n            throw new Error(\"Failed to load necessary data for analysis.\");\n        }\n    }\n    async fetchSleeperApi(url) {\n        console.log(`🔍 Fetching from Sleeper API: ${url}`);\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch from Sleeper API: ${response.statusText}`);\n        }\n        const data = await response.json();\n        console.log(`✅ Sleeper API response:`, {\n            url,\n            status: response.status,\n            dataType: Array.isArray(data) ? \"array\" : \"object\",\n            dataLength: Array.isArray(data) ? data.length : Object.keys(data).length,\n            sampleData: Array.isArray(data) ? data.slice(0, 2) : Object.keys(data).slice(0, 5)\n        });\n        return data;\n    }\n    parseSleeperDraftUrl(url) {\n        // Support both sleeper.com and sleeper.app domains and alphanumeric draft IDs\n        const regex = /sleeper\\.(?:com|app)\\/draft\\/nfl\\/([a-zA-Z0-9]+)/;\n        const match = url.match(regex);\n        if (!match || !match[1]) {\n            throw new Error(\"Invalid Sleeper mock draft URL format. Expected format: https://sleeper.app/draft/nfl/{draft_id}\");\n        }\n        return match[1];\n    }\n    normalizePlayerName(name) {\n        if (!name) return \"\";\n        // Remove common suffixes and normalize\n        return name.toLowerCase().replace(/\\s+(jr\\.?|sr\\.?|ii|iii|iv|v|vi|vii|viii|ix|x)\\s*$/i, \"\") // Remove suffixes\n        .replace(/\\s+/g, \" \") // Normalize whitespace\n        .trim();\n    }\n    findPlayerByName(playerName, position) {\n        if (!playerName) return null;\n        const normalizedName = this.normalizePlayerName(playerName);\n        console.log(`🔍 Looking for player: \"${playerName}\" -> normalized: \"${normalizedName}\"`);\n        // First try exact match with normalized name\n        let player = this.consolidatedData[normalizedName];\n        if (player) {\n            console.log(`✅ Found exact match: ${playerName}`);\n            return player;\n        }\n        // Try exact match with original name (case-insensitive)\n        player = this.consolidatedData[playerName.toLowerCase()];\n        if (player) {\n            console.log(`✅ Found exact match with original name: ${playerName}`);\n            return player;\n        }\n        // Try fuzzy matching by removing suffixes and checking partial matches\n        const nameParts = normalizedName.split(\" \");\n        if (nameParts.length >= 2) {\n            const firstName = nameParts[0];\n            const lastName = nameParts[nameParts.length - 1];\n            console.log(`🔍 Trying fuzzy match: firstName=\"${firstName}\", lastName=\"${lastName}\"`);\n            // Look for players with matching first and last name\n            for (const [key, data] of Object.entries(this.consolidatedData)){\n                const keyParts = key.split(\" \");\n                if (keyParts.length >= 2) {\n                    const keyFirstName = keyParts[0];\n                    const keyLastName = keyParts[keyParts.length - 1];\n                    if (keyFirstName === firstName && keyLastName === lastName) {\n                        console.log(`✅ Found fuzzy match: \"${playerName}\" -> \"${key}\"`);\n                        return data;\n                    }\n                }\n            }\n        }\n        // Last resort: try to find any player whose name contains the search name\n        for (const [key, data] of Object.entries(this.consolidatedData)){\n            if (key.includes(normalizedName) || normalizedName.includes(key)) {\n                console.log(`✅ Found partial match: \"${playerName}\" -> \"${key}\"`);\n                return data;\n            }\n        }\n        console.log(`❌ No match found for: ${playerName}`);\n        console.log(`🔍 Available players starting with similar names:`, Object.keys(this.consolidatedData).filter((k)=>k.includes(normalizedName.split(\" \")[0])).slice(0, 5));\n        return null;\n    }\n    getPlayerProjectedPoints(playerName, position) {\n        const player = this.findPlayerByName(playerName, position);\n        if (!player || !player.projections) {\n            console.log(`⚠️ No player or projections found for: ${playerName} (${position})`);\n            return 0;\n        }\n        const posKey = position?.toLowerCase();\n        console.log(`🔍 Looking for projections for ${playerName} at position: ${posKey}`);\n        console.log(`🔍 Available projection keys:`, Object.keys(player.projections));\n        let fpts = 0;\n        // Handle defense projections - try multiple approaches\n        if (posKey === \"def\" || posKey === \"defense\") {\n            console.log(`🛡️ Processing DEFENSE player: ${playerName}`);\n            // Method 1: Try exact position keys\n            const defenseKeys = [\n                \"def\",\n                \"DEF\",\n                \"defense\",\n                \"Defense\",\n                \"DEFENSE\"\n            ];\n            for (const key of defenseKeys){\n                if (player.projections[key]?.fpts) {\n                    fpts = player.projections[key].fpts;\n                    console.log(`✅ Found defense projections using key: ${key} = ${fpts}`);\n                    break;\n                }\n            }\n            // Method 2: Try partial key matching\n            if (!fpts) {\n                for (const key of Object.keys(player.projections)){\n                    if (key.toLowerCase().includes(\"def\")) {\n                        fpts = player.projections[key].fpts;\n                        console.log(`✅ Found defense projections using partial key: ${key} = ${fpts}`);\n                        break;\n                    }\n                }\n            }\n            // Method 3: Look for any numeric projection value\n            if (!fpts) {\n                for (const key of Object.keys(player.projections)){\n                    const projection = player.projections[key];\n                    if (projection && typeof projection === \"object\" && projection.fpts) {\n                        fpts = projection.fpts;\n                        console.log(`✅ Found defense projections using generic key: ${key} = ${fpts}`);\n                        break;\n                    }\n                }\n            }\n            // Method 4: Look for any numeric value in projections\n            if (!fpts) {\n                for (const key of Object.keys(player.projections)){\n                    const value = player.projections[key];\n                    if (typeof value === \"number\" && value > 0) {\n                        fpts = value;\n                        console.log(`✅ Found defense projections using numeric key: ${key} = ${fpts}`);\n                        break;\n                    }\n                }\n            }\n            // Method 5: Check if projections is just a number (some defenses have this)\n            if (!fpts && typeof player.projections === \"number\" && player.projections > 0) {\n                fpts = player.projections;\n                console.log(`✅ Found defense projections as direct number: ${fpts}`);\n            }\n        } else {\n            // Non-defense players - try standard approach\n            fpts = player.projections[posKey]?.fpts;\n        }\n        if (fpts) {\n            console.log(`✅ Projected points for ${playerName}: ${fpts}`);\n            return typeof fpts === \"number\" ? fpts : parseFloat(fpts);\n        } else {\n            console.log(`❌ No projected points found for ${playerName} at position ${posKey}`);\n            console.log(`🔍 Player projections structure:`, player.projections);\n            return 0;\n        }\n    }\n    getPlayerAdp(playerName) {\n        const player = this.findPlayerByName(playerName, \"\");\n        if (!player) return 0;\n        // Try to find in ADP data with normalized name\n        const normalizedName = this.normalizePlayerName(playerName);\n        let adpPlayer = this.adpData[normalizedName];\n        if (!adpPlayer) {\n            // Try fuzzy matching for ADP too\n            const nameParts = normalizedName.split(\" \");\n            if (nameParts.length >= 2) {\n                const firstName = nameParts[0];\n                const lastName = nameParts[nameParts.length - 1];\n                for (const [key, data] of Object.entries(this.adpData)){\n                    const keyParts = key.split(\" \");\n                    if (keyParts.length >= 2) {\n                        const keyFirstName = keyParts[0];\n                        const keyLastName = keyParts[keyParts.length - 1];\n                        if (keyFirstName === firstName && keyLastName === lastName) {\n                            adpPlayer = data;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        const adp = adpPlayer?.adp_value;\n        return adp ? parseFloat(adp) : 0;\n    }\n    getPlayerVorp(playerName) {\n        const normalizedName = this.normalizePlayerName(playerName);\n        if (!normalizedName) return 0;\n        const direct = Array.isArray(this.vorpData) ? this.vorpData.find((p)=>{\n            const pName = this.normalizePlayerName(p.playerName || \"\");\n            return pName === normalizedName;\n        }) : undefined;\n        return direct?.vorp_score || direct?.vorpScore ? parseFloat(direct.vorp_score || direct.vorpScore) : 0;\n    }\n    async analyzeDraft(draftUrl, leagueType = \"standard\") {\n        await this.initialize();\n        console.log(\"\\uD83D\\uDD0D Fetching draft data from Sleeper...\");\n        const draftId = this.parseSleeperDraftUrl(draftUrl);\n        // Fetch draft data\n        const draftData = await this.fetchSleeperApi(`https://api.sleeper.app/v1/draft/${draftId}`);\n        const draftPicks = await this.fetchSleeperApi(`https://api.sleeper.app/v1/draft/${draftId}/picks?limit=1000`);\n        console.log(\"\\uD83D\\uDCCA Draft data fetched:\", {\n            draftName: draftData.name,\n            teams: draftData.teams?.length || 0,\n            rounds: draftData.settings?.rounds || 0,\n            picks: draftPicks?.length || 0,\n            expectedPicks: (draftData.teams?.length || 0) * (draftData.settings?.rounds || 0)\n        });\n        // Process draft picks and build team rosters\n        const teams = await this.buildTeamRosters(draftData, draftPicks);\n        // Calculate optimal lineups and grades\n        const result = this.analyzeTeams(teams, leagueType);\n        return {\n            draftInfo: {\n                name: draftData.name,\n                teams: draftData.teams?.length || 0,\n                rounds: draftData.settings?.rounds || 0,\n                totalPicks: draftPicks?.length || 0\n            },\n            ...result\n        };\n    }\n    analyzeTeams(teams, leagueType = \"standard\") {\n        const lineupEngine = new _lib_optimal_lineup_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        const gradeEngine = new _lib_position_grade_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        // Get actual draft dimensions from the teams data\n        const actualTeams = Object.keys(teams).length;\n        const actualRounds = Math.max(...Object.values(teams).map((team)=>Math.max(...(team.roster || []).map((p)=>p.round || 0))), 16);\n        console.log(\"\\uD83D\\uDCCA Draft dimensions:\", {\n            actualTeams,\n            actualRounds\n        });\n        // First calculate optimal lineups for all teams\n        const analysisTeams = Object.entries(teams).map(([id, team])=>{\n            const lineup = lineupEngine.calculateOptimalLineup(team.roster, {\n                leagueType,\n                scoring: \"ppr\",\n                teams: actualTeams,\n                rounds: actualRounds\n            });\n            // Calculate average ADP\n            const adpValues = team.roster.map((p)=>p.adpValue || 0).filter((v)=>v !== 0);\n            const averageAdpValue = adpValues.length > 0 ? adpValues.reduce((s, v)=>s + v, 0) / adpValues.length : 0;\n            // Calculate average VORP\n            const vorpValues = team.roster.map((p)=>p.vorpScore || 0).filter((v)=>v !== 0);\n            const averageVorpScore = vorpValues.length > 0 ? vorpValues.reduce((s, v)=>s + v, 0) / vorpValues.length : 0;\n            // Calculate optimal lineup points\n            const optimalLineupPoints = lineupEngine.calculateTotalProjectedPoints(lineup);\n            // Get bench players and points\n            const benchPlayers = lineupEngine.getBenchPlayers(team.roster, lineup);\n            const benchPoints = lineupEngine.calculateTotalProjectedPoints(benchPlayers);\n            // Get lineup analysis\n            const lineupAnalysis = lineupEngine.analyzeLineup(lineup, {\n                leagueType,\n                scoring: \"ppr\",\n                teams: Object.keys(teams).length\n            });\n            return {\n                teamId: id,\n                teamName: team.teamName,\n                draftSlot: team.draftSlot,\n                roster: team.roster,\n                optimalLineup: lineup,\n                optimalLineupPoints,\n                benchPlayers,\n                benchPoints,\n                totalProjectedPoints: optimalLineupPoints + benchPoints,\n                averageAdpValue,\n                averageVorpScore,\n                lineupAnalysis\n            };\n        });\n        // Now calculate position grades using the teams with optimal lineups\n        const gradedTeams = gradeEngine.calculatePositionGrades(analysisTeams, {\n            leagueType,\n            scoring: \"ppr\",\n            teams: Object.keys(teams).length\n        });\n        // Map the graded teams back to the expected format for the frontend\n        const finalTeams = gradedTeams.map((gradedTeam)=>{\n            // Find the original analysis team data\n            const originalTeam = analysisTeams.find((t)=>t.teamId === gradedTeam.teamId);\n            return {\n                teamId: gradedTeam.teamId,\n                teamName: gradedTeam.teamName,\n                draftSlot: originalTeam?.draftSlot || 0,\n                optimalLineup: originalTeam?.optimalLineup || {},\n                optimalLineupPoints: originalTeam?.optimalLineupPoints || 0,\n                benchPlayers: originalTeam?.benchPlayers || [],\n                benchPoints: originalTeam?.benchPoints || 0,\n                positionGrades: gradedTeam.positionGrades || {},\n                overallGrade: gradedTeam.overallGrade || {\n                    grade: \"—\",\n                    score: 0\n                },\n                totalProjectedPoints: (originalTeam?.optimalLineupPoints || 0) + (originalTeam?.benchPoints || 0),\n                averageProjectedPoints: (()=>{\n                    if (!originalTeam?.roster?.length) return 0;\n                    return originalTeam.roster.reduce((sum, p)=>sum + (p.projectedPoints || 0), 0) / originalTeam.roster.length;\n                })(),\n                averageAdpValue: originalTeam?.averageAdpValue || 0,\n                averageVorpScore: originalTeam?.averageVorpScore || 0,\n                players: originalTeam?.roster || [],\n                roster: originalTeam?.roster || []\n            };\n        });\n        return {\n            analysis: {\n                teams: finalTeams\n            }\n        };\n    }\n    async buildTeamRosters(draftData, draftPicks) {\n        const slotToRosterId = draftData.slot_to_roster_id;\n        if (!slotToRosterId) {\n            throw new Error(\"No slot_to_roster_id found in draft data - this may not be a mock draft\");\n        }\n        const slotToName = {};\n        // SMART USERNAME DETECTION - Don't rely on failing endpoints\n        if (draftData.metadata?.draft_order_by_roster_id) {\n            // Use metadata if available\n            Object.entries(draftData.metadata.draft_order_by_roster_id).forEach(([rosterId, slot])=>{\n                slotToName[slot] = `Team ${parseInt(rosterId) + 1}`;\n            });\n        } else {\n            // Fallback to slot numbers\n            Object.keys(slotToRosterId).forEach((slot)=>{\n                slotToName[slot] = `Team ${parseInt(slot) + 1}`;\n            });\n        }\n        // Fetch NFL players data\n        const playersMap = await this.fetchSleeperApi(`https://api.sleeper.app/v1/players/nfl`);\n        const getSleeperPlayer = (id)=>playersMap?.[id];\n        const teams = {};\n        console.log(\"\\uD83D\\uDD0D Building team rosters from draft picks...\");\n        console.log(\"\\uD83D\\uDD0D Total draft picks:\", draftPicks.length);\n        console.log(\"\\uD83D\\uDD0D Slot to roster mapping:\", slotToRosterId);\n        // Initialize all teams first\n        Object.entries(slotToRosterId).forEach(([slot, rosterId])=>{\n            teams[rosterId] = {\n                teamId: rosterId,\n                teamName: slotToName[slot] || `Team ${rosterId}`,\n                draftSlot: parseInt(slot),\n                roster: []\n            };\n        });\n        // Process each pick and build team rosters\n        draftPicks.forEach((pick, index)=>{\n            // Use the draft_slot from the pick data directly\n            const draftSlot = pick.draft_slot;\n            if (draftSlot === undefined || draftSlot === null) {\n                console.warn(`Pick ${index + 1} has no draft_slot:`, pick);\n                return;\n            }\n            // Find the roster ID for this draft slot\n            const rosterId = slotToRosterId[draftSlot.toString()];\n            if (!rosterId) {\n                console.warn(`No roster ID found for draft slot ${draftSlot}`);\n                return;\n            }\n            if (!teams[rosterId]) {\n                console.warn(`Team ${rosterId} not initialized for draft slot ${draftSlot}`);\n                return;\n            }\n            // Get player data\n            const sleeperPlayer = getSleeperPlayer(pick.player_id);\n            if (!sleeperPlayer) {\n                console.warn(`No player data found for ID ${pick.player_id}`);\n                return;\n            }\n            // Calculate round from pick number and total teams\n            const totalTeams = Object.keys(slotToRosterId).length;\n            const round = Math.floor(index / totalTeams) + 1;\n            // Enhance player data with projections and VORP\n            const enhancedPlayer = this.enhancePlayerData(sleeperPlayer, pick, round);\n            teams[rosterId].roster.push(enhancedPlayer);\n            console.log(`🔍 Pick ${index + 1} (Round ${round}, Slot ${draftSlot}): ${sleeperPlayer.full_name} -> Team ${rosterId}`);\n        });\n        console.log(\"\\uD83D\\uDD0D Team roster summary:\");\n        Object.entries(teams).forEach(([rosterId, team])=>{\n            console.log(`🔍 Team ${rosterId}: ${team.roster.length} players`);\n        });\n        return teams;\n    }\n    enhancePlayerData(sleeperPlayer, pick, round) {\n        const playerName = sleeperPlayer.full_name || `${sleeperPlayer.first_name || \"\"} ${sleeperPlayer.last_name || \"\"}`.trim();\n        const position = sleeperPlayer.position || pick.metadata?.position || \"\";\n        const projectedPoints = this.getPlayerProjectedPoints(playerName, position);\n        const adpValue = this.getPlayerAdp(playerName);\n        const vorpScore = this.getPlayerVorp(playerName);\n        // Calculate draft value: negative means player was drafted above ADP (good value)\n        const draftValue = adpValue > 0 ? adpValue - pick.draft_slot : 0;\n        return {\n            ...pick,\n            metadata: sleeperPlayer,\n            playerName,\n            position,\n            projectedPoints,\n            adpValue,\n            vorpScore,\n            draftValue,\n            playerId: pick.player_id,\n            round: round\n        };\n    }\n    constructor(){\n        this.consolidatedData = {};\n        this.nameLookupIndex = {};\n        this.playerDetails = {};\n        this.vorpData = {};\n        this.adpData = {} // Added adpData property\n        ;\n    }\n}\nasync function POST(request) {\n    try {\n        const { draftUrl, leagueType = \"standard\" } = await request.json();\n        if (!draftUrl) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Draft URL is required\"\n            });\n        }\n        console.log(\"\\uD83D\\uDE80 Starting draft analysis...\");\n        console.log(\"\\uD83D\\uDD0D Draft URL:\", draftUrl);\n        console.log(\"\\uD83C\\uDFC8 League Type:\", leagueType);\n        const analyzer = new DraftAnalyzer();\n        await analyzer.initialize();\n        const result = await analyzer.analyzeDraft(draftUrl, leagueType);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data: result\n        });\n    } catch (error) {\n        console.error(\"❌ Error in draft analysis:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error instanceof Error ? error.message : \"Unknown error occurred\"\n        });\n    }\n}\nfunction GET() {\n    return new Response(\"Method Not Allowed\", {\n        status: 405,\n        headers: {\n            Allow: \"POST\"\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDN0IzRixRQUFRQyxHQUFHLENBQUMsNkJBQW1CMkY7UUFFL0IsTUFBTThGLFdBQVcsSUFBSTVMO1FBQ3JCLE1BQU00TCxTQUFTM0wsVUFBVTtRQUV6QixNQUFNd0csU0FBUyxNQUFNbUYsU0FBU2hHLFlBQVksQ0FBQ0MsVUFBVUM7UUFFckQsT0FBT2pHLHFEQUFZQSxDQUFDNkMsSUFBSSxDQUFDO1lBQUVpSixTQUFTO1lBQU1sSixNQUFNZ0U7UUFBTztJQUMzRCxFQUFFLE9BQU94RSxPQUFPO1FBQ1ovQixRQUFRK0IsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBT3BDLHFEQUFZQSxDQUFDNkMsSUFBSSxDQUFDO1lBQ3JCaUosU0FBUztZQUNUMUosT0FBT0EsaUJBQWlCQyxRQUFRRCxNQUFNNEosT0FBTyxHQUFHO1FBQ3BEO0lBQ0o7QUFDSjtBQUVPLFNBQVNDO0lBQ2QsT0FBTyxJQUFJQyxTQUFTLHNCQUFzQjtRQUFFcEosUUFBUTtRQUFLcUosU0FBUztZQUFFQyxPQUFPO1FBQU87SUFBRTtBQUN0RiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZmX2FwaV9za2VsZXRvbi8uL2FwcC9hcGkvYW5hbHl6ZS1kcmFmdC9yb3V0ZS50cz8yNjdmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBydW50aW1lID0gJ25vZGVqcyc7XG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9zZXJ2ZXJcIjtcbmltcG9ydCBPcHRpbWFsTGluZXVwRW5naW5lIGZyb20gJy4uLy4uL2xpYi9vcHRpbWFsLWxpbmV1cC1lbmdpbmUnO1xuaW1wb3J0IFBvc2l0aW9uR3JhZGVFbmdpbmUgZnJvbSAnLi4vLi4vbGliL3Bvc2l0aW9uLWdyYWRlLWVuZ2luZSc7XG5cbi8vIERyYWZ0IEFuYWx5emVyIGNsYXNzIGNvbnZlcnRlZCBmb3IgTmV4dC5qc1xuY2xhc3MgRHJhZnRBbmFseXplciB7XG4gICAgcHJpdmF0ZSBjb25zb2xpZGF0ZWREYXRhOiBhbnkgPSB7fTtcbiAgICBwcml2YXRlIG5hbWVMb29rdXBJbmRleDogYW55ID0ge307XG4gICAgcHJpdmF0ZSBwbGF5ZXJEZXRhaWxzOiBhbnkgPSB7fTtcbiAgICBwcml2YXRlIHZvcnBEYXRhOiBhbnkgPSB7fTtcbiAgICBwcml2YXRlIGFkcERhdGE6IGFueSA9IHt9OyAvLyBBZGRlZCBhZHBEYXRhIHByb3BlcnR5XG5cbiAgICBhc3luYyBpbml0aWFsaXplKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CfmoAgSW5pdGlhbGl6aW5nIERyYWZ0IEFuYWx5emVyLi4uJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExvYWQgY29uc29saWRhdGVkIHBsYXllciBkYXRhIHZpYSBpbXBvcnRzIHNvIFZlcmNlbCBidW5kbGVzIHRoZW1cbiAgICAgICAgICAgIGNvbnN0IFttYXN0ZXJQbGF5ZXJzTW9kdWxlLCBuYW1lTG9va3VwTW9kdWxlLCB2b3JwRGF0YU1vZHVsZSwgYWRwRGF0YU1vZHVsZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgaW1wb3J0KCdkYXRhL2NvbnNvbGlkYXRlZC9tYXN0ZXItcGxheWVycy5qc29uJyksXG4gICAgICAgICAgICAgICAgaW1wb3J0KCdkYXRhL2NvbnNvbGlkYXRlZC9uYW1lLWxvb2t1cC1pbmRleC5qc29uJyksXG4gICAgICAgICAgICAgICAgaW1wb3J0KCdkYXRhL2NvbnNvbGlkYXRlZC9wbGF5ZXItdm9ycC1zY29yZXMuanNvbicpLFxuICAgICAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vLi4vYWRwX2RhdGEuanNvbicpXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gTG9hZGVkIG1vZHVsZXM6Jywge1xuICAgICAgICAgICAgICAgIG1hc3RlclBsYXllcnM6ICEhbWFzdGVyUGxheWVyc01vZHVsZSxcbiAgICAgICAgICAgICAgICBuYW1lTG9va3VwOiAhIW5hbWVMb29rdXBNb2R1bGUsXG4gICAgICAgICAgICAgICAgdm9ycERhdGE6ICEhdm9ycERhdGFNb2R1bGUsXG4gICAgICAgICAgICAgICAgYWRwRGF0YTogISFhZHBEYXRhTW9kdWxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxvb2t1cCBieSBwbGF5ZXIgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICAgICAgICAgIGNvbnN0IG1hc3RlclBsYXllcnMgPSAobWFzdGVyUGxheWVyc01vZHVsZSBhcyBhbnkpLmRlZmF1bHQucGxheWVycztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIE1hc3RlciBwbGF5ZXJzIHN0cnVjdHVyZTonLCB7XG4gICAgICAgICAgICAgICAgaGFzRGVmYXVsdDogISEobWFzdGVyUGxheWVyc01vZHVsZSBhcyBhbnkpLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgaGFzUGxheWVyczogISFtYXN0ZXJQbGF5ZXJzLFxuICAgICAgICAgICAgICAgIHBsYXllckNvdW50OiBtYXN0ZXJQbGF5ZXJzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgICBzYW1wbGVQbGF5ZXI6IG1hc3RlclBsYXllcnM/LlswXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY29uc29saWRhdGVkRGF0YSA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtYXN0ZXJQbGF5ZXJzLmZvckVhY2goKHBsYXllcjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBsYXllci5mdWxsX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgYnkgYm90aCBmdWxsX25hbWUgYW5kIHBsYXllcl9pZCBmb3IgZmxleGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zb2xpZGF0ZWREYXRhW3BsYXllci5mdWxsX25hbWUudG9Mb3dlckNhc2UoKV0gPSBwbGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucGxheWVyX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnNvbGlkYXRlZERhdGFbcGxheWVyLnBsYXllcl9pZC50b0xvd2VyQ2FzZSgpXSA9IHBsYXllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWVMb29rdXBJbmRleCA9IChuYW1lTG9va3VwTW9kdWxlIGFzIGFueSkuZGVmYXVsdDtcbiAgICAgICAgICAgIHRoaXMudm9ycERhdGEgPSAodm9ycERhdGFNb2R1bGUgYXMgYW55KS5kZWZhdWx0LnZvcnBTY29yZXMgfHwgKHZvcnBEYXRhTW9kdWxlIGFzIGFueSkuZGVmYXVsdDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIEFEUCBsb29rdXAgYnkgcGxheWVyIG5hbWUgLSBhZHBfZGF0YS5qc29uIGhhcyBwbGF5ZXJzIGFycmF5XG4gICAgICAgICAgICB0aGlzLmFkcERhdGEgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGFkcFBsYXllcnMgPSAoYWRwRGF0YU1vZHVsZSBhcyBhbnkpLmRlZmF1bHQucGxheWVycyB8fCBbXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEFEUCBkYXRhIHN0cnVjdHVyZTonLCB7XG4gICAgICAgICAgICAgICAgaGFzRGVmYXVsdDogISEoYWRwRGF0YU1vZHVsZSBhcyBhbnkpLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgaGFzUGxheWVyczogISFhZHBQbGF5ZXJzLFxuICAgICAgICAgICAgICAgIHBsYXllckNvdW50OiBhZHBQbGF5ZXJzPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgICBzYW1wbGVQbGF5ZXI6IGFkcFBsYXllcnM/LlswXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGFkcFBsYXllcnMuZm9yRWFjaCgocGxheWVyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGxheWVyLmZ1bGxfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkcERhdGFbcGxheWVyLmZ1bGxfbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHBsYXllcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBEcmFmdCBBbmFseXplciBpbml0aWFsaXplZCB3aXRoICR7T2JqZWN0LmtleXModGhpcy5jb25zb2xpZGF0ZWREYXRhKS5sZW5ndGh9IHBsYXllcnMgYW5kICR7T2JqZWN0LmtleXModGhpcy5hZHBEYXRhKS5sZW5ndGh9IEFEUCByZWNvcmRzLmApO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gU2FtcGxlIGNvbnNvbGlkYXRlZCBwbGF5ZXJzOmAsIE9iamVjdC5rZXlzKHRoaXMuY29uc29saWRhdGVkRGF0YSkuc2xpY2UoMCwgNSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gU2FtcGxlIEFEUCBwbGF5ZXJzOmAsIE9iamVjdC5rZXlzKHRoaXMuYWRwRGF0YSkuc2xpY2UoMCwgNSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIERyYWZ0IEFuYWx5emVyOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgbmVjZXNzYXJ5IGRhdGEgZm9yIGFuYWx5c2lzLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBmZXRjaFNsZWVwZXJBcGkodXJsOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gRmV0Y2hpbmcgZnJvbSBTbGVlcGVyIEFQSTogJHt1cmx9YCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZnJvbSBTbGVlcGVyIEFQSTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgU2xlZXBlciBBUEkgcmVzcG9uc2U6YCwge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhVHlwZTogQXJyYXkuaXNBcnJheShkYXRhKSA/ICdhcnJheScgOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGRhdGFMZW5ndGg6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhLmxlbmd0aCA6IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCxcbiAgICAgICAgICAgIHNhbXBsZURhdGE6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhLnNsaWNlKDAsIDIpIDogT2JqZWN0LmtleXMoZGF0YSkuc2xpY2UoMCwgNSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VTbGVlcGVyRHJhZnRVcmwodXJsOiBzdHJpbmcpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBib3RoIHNsZWVwZXIuY29tIGFuZCBzbGVlcGVyLmFwcCBkb21haW5zIGFuZCBhbHBoYW51bWVyaWMgZHJhZnQgSURzXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL3NsZWVwZXJcXC4oPzpjb218YXBwKVxcL2RyYWZ0XFwvbmZsXFwvKFthLXpBLVowLTldKykvO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZWdleCk7XG4gICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoWzFdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2xlZXBlciBtb2NrIGRyYWZ0IFVSTCBmb3JtYXQuIEV4cGVjdGVkIGZvcm1hdDogaHR0cHM6Ly9zbGVlcGVyLmFwcC9kcmFmdC9uZmwve2RyYWZ0X2lkfScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG5vcm1hbGl6ZVBsYXllck5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgY29tbW9uIHN1ZmZpeGVzIGFuZCBub3JtYWxpemVcbiAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKyhqclxcLj98c3JcXC4/fGlpfGlpaXxpdnx2fHZpfHZpaXx2aWlpfGl4fHgpXFxzKiQvaSwgJycpIC8vIFJlbW92ZSBzdWZmaXhlc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBOb3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmRQbGF5ZXJCeU5hbWUocGxheWVyTmFtZTogc3RyaW5nLCBwb3NpdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIGlmICghcGxheWVyTmFtZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IHRoaXMubm9ybWFsaXplUGxheWVyTmFtZShwbGF5ZXJOYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gTG9va2luZyBmb3IgcGxheWVyOiBcIiR7cGxheWVyTmFtZX1cIiAtPiBub3JtYWxpemVkOiBcIiR7bm9ybWFsaXplZE5hbWV9XCJgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpcnN0IHRyeSBleGFjdCBtYXRjaCB3aXRoIG5vcm1hbGl6ZWQgbmFtZVxuICAgICAgICBsZXQgcGxheWVyID0gdGhpcy5jb25zb2xpZGF0ZWREYXRhW25vcm1hbGl6ZWROYW1lXTtcbiAgICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBleGFjdCBtYXRjaDogJHtwbGF5ZXJOYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IGV4YWN0IG1hdGNoIHdpdGggb3JpZ2luYWwgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICAgICAgcGxheWVyID0gdGhpcy5jb25zb2xpZGF0ZWREYXRhW3BsYXllck5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChwbGF5ZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZXhhY3QgbWF0Y2ggd2l0aCBvcmlnaW5hbCBuYW1lOiAke3BsYXllck5hbWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgZnV6enkgbWF0Y2hpbmcgYnkgcmVtb3Zpbmcgc3VmZml4ZXMgYW5kIGNoZWNraW5nIHBhcnRpYWwgbWF0Y2hlc1xuICAgICAgICBjb25zdCBuYW1lUGFydHMgPSBub3JtYWxpemVkTmFtZS5zcGxpdCgnICcpO1xuICAgICAgICBpZiAobmFtZVBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdE5hbWUgPSBuYW1lUGFydHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0TmFtZSA9IG5hbWVQYXJ0c1tuYW1lUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFRyeWluZyBmdXp6eSBtYXRjaDogZmlyc3ROYW1lPVwiJHtmaXJzdE5hbWV9XCIsIGxhc3ROYW1lPVwiJHtsYXN0TmFtZX1cImApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBMb29rIGZvciBwbGF5ZXJzIHdpdGggbWF0Y2hpbmcgZmlyc3QgYW5kIGxhc3QgbmFtZVxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBkYXRhXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNvbnNvbGlkYXRlZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UGFydHMgPSBrZXkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5UGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5Rmlyc3ROYW1lID0ga2V5UGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUxhc3ROYW1lID0ga2V5UGFydHNba2V5UGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Rmlyc3ROYW1lID09PSBmaXJzdE5hbWUgJiYga2V5TGFzdE5hbWUgPT09IGxhc3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGZ1enp5IG1hdGNoOiBcIiR7cGxheWVyTmFtZX1cIiAtPiBcIiR7a2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTGFzdCByZXNvcnQ6IHRyeSB0byBmaW5kIGFueSBwbGF5ZXIgd2hvc2UgbmFtZSBjb250YWlucyB0aGUgc2VhcmNoIG5hbWVcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBkYXRhXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmNvbnNvbGlkYXRlZERhdGEpKSB7XG4gICAgICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKG5vcm1hbGl6ZWROYW1lKSB8fCBub3JtYWxpemVkTmFtZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBwYXJ0aWFsIG1hdGNoOiBcIiR7cGxheWVyTmFtZX1cIiAtPiBcIiR7a2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDinYwgTm8gbWF0Y2ggZm91bmQgZm9yOiAke3BsYXllck5hbWV9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEF2YWlsYWJsZSBwbGF5ZXJzIHN0YXJ0aW5nIHdpdGggc2ltaWxhciBuYW1lczpgLCBcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uc29saWRhdGVkRGF0YSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGsgPT4gay5pbmNsdWRlcyhub3JtYWxpemVkTmFtZS5zcGxpdCgnICcpWzBdKSlcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgNSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRQbGF5ZXJQcm9qZWN0ZWRQb2ludHMocGxheWVyTmFtZTogc3RyaW5nLCBwb3NpdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuZmluZFBsYXllckJ5TmFtZShwbGF5ZXJOYW1lLCBwb3NpdGlvbik7XG4gICAgICAgIGlmICghcGxheWVyIHx8ICFwbGF5ZXIucHJvamVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gTm8gcGxheWVyIG9yIHByb2plY3Rpb25zIGZvdW5kIGZvcjogJHtwbGF5ZXJOYW1lfSAoJHtwb3NpdGlvbn0pYCk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvc0tleSA9IHBvc2l0aW9uPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBMb29raW5nIGZvciBwcm9qZWN0aW9ucyBmb3IgJHtwbGF5ZXJOYW1lfSBhdCBwb3NpdGlvbjogJHtwb3NLZXl9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEF2YWlsYWJsZSBwcm9qZWN0aW9uIGtleXM6YCwgT2JqZWN0LmtleXMocGxheWVyLnByb2plY3Rpb25zKSk7XG4gICAgICAgIFxuICAgICAgICBsZXQgZnB0cyA9IDA7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgZGVmZW5zZSBwcm9qZWN0aW9ucyAtIHRyeSBtdWx0aXBsZSBhcHByb2FjaGVzXG4gICAgICAgIGlmIChwb3NLZXkgPT09ICdkZWYnIHx8IHBvc0tleSA9PT0gJ2RlZmVuc2UnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+boe+4jyBQcm9jZXNzaW5nIERFRkVOU0UgcGxheWVyOiAke3BsYXllck5hbWV9YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1ldGhvZCAxOiBUcnkgZXhhY3QgcG9zaXRpb24ga2V5c1xuICAgICAgICAgICAgY29uc3QgZGVmZW5zZUtleXMgPSBbJ2RlZicsICdERUYnLCAnZGVmZW5zZScsICdEZWZlbnNlJywgJ0RFRkVOU0UnXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGRlZmVuc2VLZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsYXllci5wcm9qZWN0aW9uc1trZXldPy5mcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZwdHMgPSBwbGF5ZXIucHJvamVjdGlvbnNba2V5XS5mcHRzO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGRlZmVuc2UgcHJvamVjdGlvbnMgdXNpbmcga2V5OiAke2tleX0gPSAke2ZwdHN9YCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTWV0aG9kIDI6IFRyeSBwYXJ0aWFsIGtleSBtYXRjaGluZ1xuICAgICAgICAgICAgaWYgKCFmcHRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGxheWVyLnByb2plY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RlZicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcHRzID0gcGxheWVyLnByb2plY3Rpb25zW2tleV0uZnB0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZGVmZW5zZSBwcm9qZWN0aW9ucyB1c2luZyBwYXJ0aWFsIGtleTogJHtrZXl9ID0gJHtmcHRzfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1ldGhvZCAzOiBMb29rIGZvciBhbnkgbnVtZXJpYyBwcm9qZWN0aW9uIHZhbHVlXG4gICAgICAgICAgICBpZiAoIWZwdHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwbGF5ZXIucHJvamVjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSBwbGF5ZXIucHJvamVjdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgdHlwZW9mIHByb2plY3Rpb24gPT09ICdvYmplY3QnICYmIHByb2plY3Rpb24uZnB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnB0cyA9IHByb2plY3Rpb24uZnB0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZGVmZW5zZSBwcm9qZWN0aW9ucyB1c2luZyBnZW5lcmljIGtleTogJHtrZXl9ID0gJHtmcHRzfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1ldGhvZCA0OiBMb29rIGZvciBhbnkgbnVtZXJpYyB2YWx1ZSBpbiBwcm9qZWN0aW9uc1xuICAgICAgICAgICAgaWYgKCFmcHRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGxheWVyLnByb2plY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBsYXllci5wcm9qZWN0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZwdHMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZGVmZW5zZSBwcm9qZWN0aW9ucyB1c2luZyBudW1lcmljIGtleTogJHtrZXl9ID0gJHtmcHRzfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1ldGhvZCA1OiBDaGVjayBpZiBwcm9qZWN0aW9ucyBpcyBqdXN0IGEgbnVtYmVyIChzb21lIGRlZmVuc2VzIGhhdmUgdGhpcylcbiAgICAgICAgICAgIGlmICghZnB0cyAmJiB0eXBlb2YgcGxheWVyLnByb2plY3Rpb25zID09PSAnbnVtYmVyJyAmJiBwbGF5ZXIucHJvamVjdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZnB0cyA9IHBsYXllci5wcm9qZWN0aW9ucztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGRlZmVuc2UgcHJvamVjdGlvbnMgYXMgZGlyZWN0IG51bWJlcjogJHtmcHRzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm9uLWRlZmVuc2UgcGxheWVycyAtIHRyeSBzdGFuZGFyZCBhcHByb2FjaFxuICAgICAgICAgICAgZnB0cyA9IHBsYXllci5wcm9qZWN0aW9uc1twb3NLZXldPy5mcHRzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZnB0cykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBQcm9qZWN0ZWQgcG9pbnRzIGZvciAke3BsYXllck5hbWV9OiAke2ZwdHN9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZwdHMgPT09ICdudW1iZXInID8gZnB0cyA6IHBhcnNlRmxvYXQoZnB0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIE5vIHByb2plY3RlZCBwb2ludHMgZm91bmQgZm9yICR7cGxheWVyTmFtZX0gYXQgcG9zaXRpb24gJHtwb3NLZXl9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBQbGF5ZXIgcHJvamVjdGlvbnMgc3RydWN0dXJlOmAsIHBsYXllci5wcm9qZWN0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UGxheWVyQWRwKHBsYXllck5hbWU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmZpbmRQbGF5ZXJCeU5hbWUocGxheWVyTmFtZSwgJycpO1xuICAgICAgICBpZiAoIXBsYXllcikgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgdG8gZmluZCBpbiBBRFAgZGF0YSB3aXRoIG5vcm1hbGl6ZWQgbmFtZVxuICAgICAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IHRoaXMubm9ybWFsaXplUGxheWVyTmFtZShwbGF5ZXJOYW1lKTtcbiAgICAgICAgbGV0IGFkcFBsYXllciA9IHRoaXMuYWRwRGF0YVtub3JtYWxpemVkTmFtZV07XG4gICAgICAgIFxuICAgICAgICBpZiAoIWFkcFBsYXllcikge1xuICAgICAgICAgICAgLy8gVHJ5IGZ1enp5IG1hdGNoaW5nIGZvciBBRFAgdG9vXG4gICAgICAgICAgICBjb25zdCBuYW1lUGFydHMgPSBub3JtYWxpemVkTmFtZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgaWYgKG5hbWVQYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TmFtZSA9IG5hbWVQYXJ0c1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0TmFtZSA9IG5hbWVQYXJ0c1tuYW1lUGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBkYXRhXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmFkcERhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVBhcnRzID0ga2V5LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlQYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5Rmlyc3ROYW1lID0ga2V5UGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlMYXN0TmFtZSA9IGtleVBhcnRzW2tleVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Rmlyc3ROYW1lID09PSBmaXJzdE5hbWUgJiYga2V5TGFzdE5hbWUgPT09IGxhc3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRwUGxheWVyID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYWRwID0gYWRwUGxheWVyPy5hZHBfdmFsdWU7XG4gICAgICAgIHJldHVybiBhZHAgPyBwYXJzZUZsb2F0KGFkcCkgOiAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UGxheWVyVm9ycChwbGF5ZXJOYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSB0aGlzLm5vcm1hbGl6ZVBsYXllck5hbWUocGxheWVyTmFtZSk7XG4gICAgICAgIGlmICghbm9ybWFsaXplZE5hbWUpIHJldHVybiAwO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZGlyZWN0ID0gQXJyYXkuaXNBcnJheSh0aGlzLnZvcnBEYXRhKVxuICAgICAgICAgICAgPyAodGhpcy52b3JwRGF0YSBhcyBhbnlbXSkuZmluZCgocDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcE5hbWUgPSB0aGlzLm5vcm1hbGl6ZVBsYXllck5hbWUocC5wbGF5ZXJOYW1lIHx8ICcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcE5hbWUgPT09IG5vcm1hbGl6ZWROYW1lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlyZWN0Py52b3JwX3Njb3JlIHx8IGRpcmVjdD8udm9ycFNjb3JlID8gcGFyc2VGbG9hdChkaXJlY3Qudm9ycF9zY29yZSB8fCBkaXJlY3Qudm9ycFNjb3JlKSA6IDA7XG4gICAgfVxuXG4gICAgYXN5bmMgYW5hbHl6ZURyYWZ0KGRyYWZ0VXJsOiBzdHJpbmcsIGxlYWd1ZVR5cGU6IHN0cmluZyA9ICdzdGFuZGFyZCcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBGZXRjaGluZyBkcmFmdCBkYXRhIGZyb20gU2xlZXBlci4uLicpO1xuICAgICAgICBjb25zdCBkcmFmdElkID0gdGhpcy5wYXJzZVNsZWVwZXJEcmFmdFVybChkcmFmdFVybCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGZXRjaCBkcmFmdCBkYXRhXG4gICAgICAgIGNvbnN0IGRyYWZ0RGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hTbGVlcGVyQXBpKGBodHRwczovL2FwaS5zbGVlcGVyLmFwcC92MS9kcmFmdC8ke2RyYWZ0SWR9YCk7XG4gICAgICAgIGNvbnN0IGRyYWZ0UGlja3MgPSBhd2FpdCB0aGlzLmZldGNoU2xlZXBlckFwaShgaHR0cHM6Ly9hcGkuc2xlZXBlci5hcHAvdjEvZHJhZnQvJHtkcmFmdElkfS9waWNrcz9saW1pdD0xMDAwYCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBEcmFmdCBkYXRhIGZldGNoZWQ6Jywge1xuICAgICAgICAgICAgZHJhZnROYW1lOiBkcmFmdERhdGEubmFtZSxcbiAgICAgICAgICAgIHRlYW1zOiBkcmFmdERhdGEudGVhbXM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgcm91bmRzOiBkcmFmdERhdGEuc2V0dGluZ3M/LnJvdW5kcyB8fCAwLFxuICAgICAgICAgICAgcGlja3M6IGRyYWZ0UGlja3M/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgZXhwZWN0ZWRQaWNrczogKGRyYWZ0RGF0YS50ZWFtcz8ubGVuZ3RoIHx8IDApICogKGRyYWZ0RGF0YS5zZXR0aW5ncz8ucm91bmRzIHx8IDApXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyBkcmFmdCBwaWNrcyBhbmQgYnVpbGQgdGVhbSByb3N0ZXJzXG4gICAgICAgIGNvbnN0IHRlYW1zID0gYXdhaXQgdGhpcy5idWlsZFRlYW1Sb3N0ZXJzKGRyYWZ0RGF0YSwgZHJhZnRQaWNrcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgb3B0aW1hbCBsaW5ldXBzIGFuZCBncmFkZXNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbmFseXplVGVhbXModGVhbXMsIGxlYWd1ZVR5cGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYWZ0SW5mbzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRyYWZ0RGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIHRlYW1zOiBkcmFmdERhdGEudGVhbXM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICAgIHJvdW5kczogZHJhZnREYXRhLnNldHRpbmdzPy5yb3VuZHMgfHwgMCxcbiAgICAgICAgICAgICAgICB0b3RhbFBpY2tzOiBkcmFmdFBpY2tzPy5sZW5ndGggfHwgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnJlc3VsdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgYW5hbHl6ZVRlYW1zKHRlYW1zOiBhbnksIGxlYWd1ZVR5cGU6IHN0cmluZyA9ICdzdGFuZGFyZCcpIHtcbiAgICAgICAgY29uc3QgbGluZXVwRW5naW5lID0gbmV3IE9wdGltYWxMaW5ldXBFbmdpbmUoKTtcbiAgICAgICAgY29uc3QgZ3JhZGVFbmdpbmUgPSBuZXcgUG9zaXRpb25HcmFkZUVuZ2luZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGFjdHVhbCBkcmFmdCBkaW1lbnNpb25zIGZyb20gdGhlIHRlYW1zIGRhdGFcbiAgICAgICAgY29uc3QgYWN0dWFsVGVhbXMgPSBPYmplY3Qua2V5cyh0ZWFtcykubGVuZ3RoO1xuICAgICAgICBjb25zdCBhY3R1YWxSb3VuZHMgPSBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKHRlYW1zKS5tYXAoKHRlYW06IGFueSkgPT4gXG4gICAgICAgICAgICBNYXRoLm1heCguLi4odGVhbS5yb3N0ZXIgfHwgW10pLm1hcCgocDogYW55KSA9PiBwLnJvdW5kIHx8IDApKVxuICAgICAgICApLCAxNik7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBEcmFmdCBkaW1lbnNpb25zOicsIHsgYWN0dWFsVGVhbXMsIGFjdHVhbFJvdW5kcyB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpcnN0IGNhbGN1bGF0ZSBvcHRpbWFsIGxpbmV1cHMgZm9yIGFsbCB0ZWFtc1xuICAgICAgICBjb25zdCBhbmFseXNpc1RlYW1zID0gT2JqZWN0LmVudHJpZXModGVhbXMpLm1hcCgoW2lkLCB0ZWFtXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZXVwID0gbGluZXVwRW5naW5lLmNhbGN1bGF0ZU9wdGltYWxMaW5ldXAodGVhbS5yb3N0ZXIsIHsgXG4gICAgICAgICAgICAgICAgbGVhZ3VlVHlwZSwgXG4gICAgICAgICAgICAgICAgc2NvcmluZzogJ3BwcicsXG4gICAgICAgICAgICAgICAgdGVhbXM6IGFjdHVhbFRlYW1zLFxuICAgICAgICAgICAgICAgIHJvdW5kczogYWN0dWFsUm91bmRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgQURQXG4gICAgICAgICAgICBjb25zdCBhZHBWYWx1ZXMgPSB0ZWFtLnJvc3Rlci5tYXAoKHA6IGFueSkgPT4gcC5hZHBWYWx1ZSB8fCAwKS5maWx0ZXIoKHY6IG51bWJlcikgPT4gdiAhPT0gMCk7XG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlQWRwVmFsdWUgPSBhZHBWYWx1ZXMubGVuZ3RoID4gMCA/IGFkcFZhbHVlcy5yZWR1Y2UoKHM6IG51bWJlciwgdjogbnVtYmVyKSA9PiBzICsgdiwgMCkgLyBhZHBWYWx1ZXMubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgVk9SUFxuICAgICAgICAgICAgY29uc3Qgdm9ycFZhbHVlcyA9IHRlYW0ucm9zdGVyLm1hcCgocDogYW55KSA9PiBwLnZvcnBTY29yZSB8fCAwKS5maWx0ZXIoKHY6IG51bWJlcikgPT4gdiAhPT0gMCk7XG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlVm9ycFNjb3JlID0gdm9ycFZhbHVlcy5sZW5ndGggPiAwID8gdm9ycFZhbHVlcy5yZWR1Y2UoKHM6IG51bWJlciwgdjogbnVtYmVyKSA9PiBzICsgdiwgMCkgLyB2b3JwVmFsdWVzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvcHRpbWFsIGxpbmV1cCBwb2ludHNcbiAgICAgICAgICAgIGNvbnN0IG9wdGltYWxMaW5ldXBQb2ludHMgPSBsaW5ldXBFbmdpbmUuY2FsY3VsYXRlVG90YWxQcm9qZWN0ZWRQb2ludHMobGluZXVwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IGJlbmNoIHBsYXllcnMgYW5kIHBvaW50c1xuICAgICAgICAgICAgY29uc3QgYmVuY2hQbGF5ZXJzID0gbGluZXVwRW5naW5lLmdldEJlbmNoUGxheWVycyh0ZWFtLnJvc3RlciwgbGluZXVwKTtcbiAgICAgICAgICAgIGNvbnN0IGJlbmNoUG9pbnRzID0gbGluZXVwRW5naW5lLmNhbGN1bGF0ZVRvdGFsUHJvamVjdGVkUG9pbnRzKGJlbmNoUGxheWVycyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdldCBsaW5ldXAgYW5hbHlzaXNcbiAgICAgICAgICAgIGNvbnN0IGxpbmV1cEFuYWx5c2lzID0gbGluZXVwRW5naW5lLmFuYWx5emVMaW5ldXAobGluZXVwLCB7IFxuICAgICAgICAgICAgICAgIGxlYWd1ZVR5cGUsIFxuICAgICAgICAgICAgICAgIHNjb3Jpbmc6ICdwcHInLFxuICAgICAgICAgICAgICAgIHRlYW1zOiBPYmplY3Qua2V5cyh0ZWFtcykubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IGlkLFxuICAgICAgICAgICAgICAgIHRlYW1OYW1lOiB0ZWFtLnRlYW1OYW1lLFxuICAgICAgICAgICAgICAgIGRyYWZ0U2xvdDogdGVhbS5kcmFmdFNsb3QsXG4gICAgICAgICAgICAgICAgcm9zdGVyOiB0ZWFtLnJvc3RlcixcbiAgICAgICAgICAgICAgICBvcHRpbWFsTGluZXVwOiBsaW5ldXAsXG4gICAgICAgICAgICAgICAgb3B0aW1hbExpbmV1cFBvaW50cyxcbiAgICAgICAgICAgICAgICBiZW5jaFBsYXllcnMsXG4gICAgICAgICAgICAgICAgYmVuY2hQb2ludHMsXG4gICAgICAgICAgICAgICAgdG90YWxQcm9qZWN0ZWRQb2ludHM6IG9wdGltYWxMaW5ldXBQb2ludHMgKyBiZW5jaFBvaW50cyxcbiAgICAgICAgICAgICAgICBhdmVyYWdlQWRwVmFsdWUsXG4gICAgICAgICAgICAgICAgYXZlcmFnZVZvcnBTY29yZSxcbiAgICAgICAgICAgICAgICBsaW5ldXBBbmFseXNpc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTm93IGNhbGN1bGF0ZSBwb3NpdGlvbiBncmFkZXMgdXNpbmcgdGhlIHRlYW1zIHdpdGggb3B0aW1hbCBsaW5ldXBzXG4gICAgICAgIGNvbnN0IGdyYWRlZFRlYW1zID0gZ3JhZGVFbmdpbmUuY2FsY3VsYXRlUG9zaXRpb25HcmFkZXMoYW5hbHlzaXNUZWFtcywgeyBcbiAgICAgICAgICAgIGxlYWd1ZVR5cGUsIFxuICAgICAgICAgICAgc2NvcmluZzogJ3BwcicsXG4gICAgICAgICAgICB0ZWFtczogT2JqZWN0LmtleXModGVhbXMpLmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBNYXAgdGhlIGdyYWRlZCB0ZWFtcyBiYWNrIHRvIHRoZSBleHBlY3RlZCBmb3JtYXQgZm9yIHRoZSBmcm9udGVuZFxuICAgICAgICBjb25zdCBmaW5hbFRlYW1zID0gZ3JhZGVkVGVhbXMubWFwKGdyYWRlZFRlYW0gPT4ge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgb3JpZ2luYWwgYW5hbHlzaXMgdGVhbSBkYXRhXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFRlYW0gPSBhbmFseXNpc1RlYW1zLmZpbmQodCA9PiB0LnRlYW1JZCA9PT0gZ3JhZGVkVGVhbS50ZWFtSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogZ3JhZGVkVGVhbS50ZWFtSWQsXG4gICAgICAgICAgICAgICAgdGVhbU5hbWU6IGdyYWRlZFRlYW0udGVhbU5hbWUsXG4gICAgICAgICAgICAgICAgZHJhZnRTbG90OiBvcmlnaW5hbFRlYW0/LmRyYWZ0U2xvdCB8fCAwLFxuICAgICAgICAgICAgICAgIG9wdGltYWxMaW5ldXA6IG9yaWdpbmFsVGVhbT8ub3B0aW1hbExpbmV1cCB8fCB7fSxcbiAgICAgICAgICAgICAgICBvcHRpbWFsTGluZXVwUG9pbnRzOiBvcmlnaW5hbFRlYW0/Lm9wdGltYWxMaW5ldXBQb2ludHMgfHwgMCxcbiAgICAgICAgICAgICAgICBiZW5jaFBsYXllcnM6IG9yaWdpbmFsVGVhbT8uYmVuY2hQbGF5ZXJzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGJlbmNoUG9pbnRzOiBvcmlnaW5hbFRlYW0/LmJlbmNoUG9pbnRzIHx8IDAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25HcmFkZXM6IGdyYWRlZFRlYW0ucG9zaXRpb25HcmFkZXMgfHwge30sXG4gICAgICAgICAgICAgICAgb3ZlcmFsbEdyYWRlOiBncmFkZWRUZWFtLm92ZXJhbGxHcmFkZSB8fCB7IGdyYWRlOiAn4oCUJywgc2NvcmU6IDAgfSxcbiAgICAgICAgICAgICAgICB0b3RhbFByb2plY3RlZFBvaW50czogKG9yaWdpbmFsVGVhbT8ub3B0aW1hbExpbmV1cFBvaW50cyB8fCAwKSArIChvcmlnaW5hbFRlYW0/LmJlbmNoUG9pbnRzIHx8IDApLFxuICAgICAgICAgICAgICAgIGF2ZXJhZ2VQcm9qZWN0ZWRQb2ludHM6ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luYWxUZWFtPy5yb3N0ZXI/Lmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFRlYW0ucm9zdGVyLnJlZHVjZSgoc3VtOiBudW1iZXIsIHA6IGFueSkgPT4gc3VtICsgKHAucHJvamVjdGVkUG9pbnRzIHx8IDApLCAwKSAvIG9yaWdpbmFsVGVhbS5yb3N0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICAgICAgYXZlcmFnZUFkcFZhbHVlOiBvcmlnaW5hbFRlYW0/LmF2ZXJhZ2VBZHBWYWx1ZSB8fCAwLFxuICAgICAgICAgICAgICAgIGF2ZXJhZ2VWb3JwU2NvcmU6IG9yaWdpbmFsVGVhbT8uYXZlcmFnZVZvcnBTY29yZSB8fCAwLFxuICAgICAgICAgICAgICAgIHBsYXllcnM6IG9yaWdpbmFsVGVhbT8ucm9zdGVyIHx8IFtdLFxuICAgICAgICAgICAgICAgIHJvc3Rlcjogb3JpZ2luYWxUZWFtPy5yb3N0ZXIgfHwgW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbmFseXNpczoge1xuICAgICAgICAgICAgICAgIHRlYW1zOiBmaW5hbFRlYW1zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGJ1aWxkVGVhbVJvc3RlcnMoZHJhZnREYXRhOiBhbnksIGRyYWZ0UGlja3M6IGFueSkge1xuICAgICAgICBjb25zdCBzbG90VG9Sb3N0ZXJJZCA9IGRyYWZ0RGF0YS5zbG90X3RvX3Jvc3Rlcl9pZCBhcyB7IFtzbG90OiBzdHJpbmddOiBudW1iZXIgfTtcbiAgICAgICAgaWYgKCFzbG90VG9Sb3N0ZXJJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzbG90X3RvX3Jvc3Rlcl9pZCBmb3VuZCBpbiBkcmFmdCBkYXRhIC0gdGhpcyBtYXkgbm90IGJlIGEgbW9jayBkcmFmdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2xvdFRvTmFtZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgICAgICBcbiAgICAgICAgLy8gU01BUlQgVVNFUk5BTUUgREVURUNUSU9OIC0gRG9uJ3QgcmVseSBvbiBmYWlsaW5nIGVuZHBvaW50c1xuICAgICAgICBpZiAoZHJhZnREYXRhLm1ldGFkYXRhPy5kcmFmdF9vcmRlcl9ieV9yb3N0ZXJfaWQpIHtcbiAgICAgICAgICAgIC8vIFVzZSBtZXRhZGF0YSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRyYWZ0RGF0YS5tZXRhZGF0YS5kcmFmdF9vcmRlcl9ieV9yb3N0ZXJfaWQpLmZvckVhY2goKFtyb3N0ZXJJZCwgc2xvdF06IFtzdHJpbmcsIGFueV0pID0+IHtcbiAgICAgICAgICAgICAgICBzbG90VG9OYW1lW3Nsb3RdID0gYFRlYW0gJHtwYXJzZUludChyb3N0ZXJJZCkgKyAxfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHNsb3QgbnVtYmVyc1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2xvdFRvUm9zdGVySWQpLmZvckVhY2goc2xvdCA9PiB7XG4gICAgICAgICAgICAgICAgc2xvdFRvTmFtZVtzbG90XSA9IGBUZWFtICR7cGFyc2VJbnQoc2xvdCkgKyAxfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZldGNoIE5GTCBwbGF5ZXJzIGRhdGFcbiAgICAgICAgY29uc3QgcGxheWVyc01hcDogYW55ID0gYXdhaXQgdGhpcy5mZXRjaFNsZWVwZXJBcGkoYGh0dHBzOi8vYXBpLnNsZWVwZXIuYXBwL3YxL3BsYXllcnMvbmZsYCk7XG4gICAgICAgIGNvbnN0IGdldFNsZWVwZXJQbGF5ZXIgPSAoaWQ6IHN0cmluZykgPT4gcGxheWVyc01hcD8uW2lkXTtcblxuICAgICAgICBjb25zdCB0ZWFtczogeyBbcm9zdGVySWQ6IG51bWJlcl06IGFueSB9ID0ge307XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gQnVpbGRpbmcgdGVhbSByb3N0ZXJzIGZyb20gZHJhZnQgcGlja3MuLi4nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gVG90YWwgZHJhZnQgcGlja3M6JywgZHJhZnRQaWNrcy5sZW5ndGgpO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBTbG90IHRvIHJvc3RlciBtYXBwaW5nOicsIHNsb3RUb1Jvc3RlcklkKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGFsbCB0ZWFtcyBmaXJzdFxuICAgICAgICBPYmplY3QuZW50cmllcyhzbG90VG9Sb3N0ZXJJZCkuZm9yRWFjaCgoW3Nsb3QsIHJvc3RlcklkXTogW3N0cmluZywgbnVtYmVyXSkgPT4ge1xuICAgICAgICAgICAgdGVhbXNbcm9zdGVySWRdID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcm9zdGVySWQsXG4gICAgICAgICAgICAgICAgdGVhbU5hbWU6IHNsb3RUb05hbWVbc2xvdF0gfHwgYFRlYW0gJHtyb3N0ZXJJZH1gLFxuICAgICAgICAgICAgICAgIGRyYWZ0U2xvdDogcGFyc2VJbnQoc2xvdCksXG4gICAgICAgICAgICAgICAgcm9zdGVyOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHBpY2sgYW5kIGJ1aWxkIHRlYW0gcm9zdGVyc1xuICAgICAgICBkcmFmdFBpY2tzLmZvckVhY2goKHBpY2s6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBkcmFmdF9zbG90IGZyb20gdGhlIHBpY2sgZGF0YSBkaXJlY3RseVxuICAgICAgICAgICAgY29uc3QgZHJhZnRTbG90ID0gcGljay5kcmFmdF9zbG90O1xuICAgICAgICAgICAgaWYgKGRyYWZ0U2xvdCA9PT0gdW5kZWZpbmVkIHx8IGRyYWZ0U2xvdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUGljayAke2luZGV4ICsgMX0gaGFzIG5vIGRyYWZ0X3Nsb3Q6YCwgcGljayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSByb3N0ZXIgSUQgZm9yIHRoaXMgZHJhZnQgc2xvdFxuICAgICAgICAgICAgY29uc3Qgcm9zdGVySWQgPSBzbG90VG9Sb3N0ZXJJZFtkcmFmdFNsb3QudG9TdHJpbmcoKV07XG4gICAgICAgICAgICBpZiAoIXJvc3RlcklkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBObyByb3N0ZXIgSUQgZm91bmQgZm9yIGRyYWZ0IHNsb3QgJHtkcmFmdFNsb3R9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRlYW1zW3Jvc3RlcklkXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGVhbSAke3Jvc3RlcklkfSBub3QgaW5pdGlhbGl6ZWQgZm9yIGRyYWZ0IHNsb3QgJHtkcmFmdFNsb3R9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgcGxheWVyIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHNsZWVwZXJQbGF5ZXIgPSBnZXRTbGVlcGVyUGxheWVyKHBpY2sucGxheWVyX2lkKTtcbiAgICAgICAgICAgIGlmICghc2xlZXBlclBsYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgTm8gcGxheWVyIGRhdGEgZm91bmQgZm9yIElEICR7cGljay5wbGF5ZXJfaWR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcm91bmQgZnJvbSBwaWNrIG51bWJlciBhbmQgdG90YWwgdGVhbXNcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsVGVhbXMgPSBPYmplY3Qua2V5cyhzbG90VG9Sb3N0ZXJJZCkubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgcm91bmQgPSBNYXRoLmZsb29yKGluZGV4IC8gdG90YWxUZWFtcykgKyAxO1xuXG4gICAgICAgICAgICAvLyBFbmhhbmNlIHBsYXllciBkYXRhIHdpdGggcHJvamVjdGlvbnMgYW5kIFZPUlBcbiAgICAgICAgICAgIGNvbnN0IGVuaGFuY2VkUGxheWVyID0gdGhpcy5lbmhhbmNlUGxheWVyRGF0YShzbGVlcGVyUGxheWVyLCBwaWNrLCByb3VuZCk7XG4gICAgICAgICAgICB0ZWFtc1tyb3N0ZXJJZF0ucm9zdGVyLnB1c2goZW5oYW5jZWRQbGF5ZXIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBQaWNrICR7aW5kZXggKyAxfSAoUm91bmQgJHtyb3VuZH0sIFNsb3QgJHtkcmFmdFNsb3R9KTogJHtzbGVlcGVyUGxheWVyLmZ1bGxfbmFtZX0gLT4gVGVhbSAke3Jvc3RlcklkfWApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBUZWFtIHJvc3RlciBzdW1tYXJ5OicpO1xuICAgICAgICBPYmplY3QuZW50cmllcyh0ZWFtcykuZm9yRWFjaCgoW3Jvc3RlcklkLCB0ZWFtXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gVGVhbSAke3Jvc3RlcklkfTogJHt0ZWFtLnJvc3Rlci5sZW5ndGh9IHBsYXllcnNgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRlYW1zO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW5oYW5jZVBsYXllckRhdGEoc2xlZXBlclBsYXllcjogYW55LCBwaWNrOiBhbnksIHJvdW5kOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcGxheWVyTmFtZTogc3RyaW5nID0gc2xlZXBlclBsYXllci5mdWxsX25hbWUgfHwgYCR7c2xlZXBlclBsYXllci5maXJzdF9uYW1lIHx8ICcnfSAke3NsZWVwZXJQbGF5ZXIubGFzdF9uYW1lIHx8ICcnfWAudHJpbSgpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbjogc3RyaW5nID0gc2xlZXBlclBsYXllci5wb3NpdGlvbiB8fCBwaWNrLm1ldGFkYXRhPy5wb3NpdGlvbiB8fCAnJztcblxuICAgICAgICBjb25zdCBwcm9qZWN0ZWRQb2ludHMgPSB0aGlzLmdldFBsYXllclByb2plY3RlZFBvaW50cyhwbGF5ZXJOYW1lLCBwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGFkcFZhbHVlID0gdGhpcy5nZXRQbGF5ZXJBZHAocGxheWVyTmFtZSk7XG4gICAgICAgIGNvbnN0IHZvcnBTY29yZSA9IHRoaXMuZ2V0UGxheWVyVm9ycChwbGF5ZXJOYW1lKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBkcmFmdCB2YWx1ZTogbmVnYXRpdmUgbWVhbnMgcGxheWVyIHdhcyBkcmFmdGVkIGFib3ZlIEFEUCAoZ29vZCB2YWx1ZSlcbiAgICAgICAgY29uc3QgZHJhZnRWYWx1ZSA9IGFkcFZhbHVlID4gMCA/IChhZHBWYWx1ZSAtIHBpY2suZHJhZnRfc2xvdCkgOiAwO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5waWNrLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNsZWVwZXJQbGF5ZXIsXG4gICAgICAgICAgICBwbGF5ZXJOYW1lLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBwcm9qZWN0ZWRQb2ludHMsXG4gICAgICAgICAgICBhZHBWYWx1ZSxcbiAgICAgICAgICAgIHZvcnBTY29yZSxcbiAgICAgICAgICAgIGRyYWZ0VmFsdWUsXG4gICAgICAgICAgICBwbGF5ZXJJZDogcGljay5wbGF5ZXJfaWQsXG4gICAgICAgICAgICByb3VuZDogcm91bmQsIC8vIEFkZCByb3VuZCB0byB0aGUgZW5oYW5jZWQgcGxheWVyIGRhdGFcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IFJlcXVlc3QpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRyYWZ0VXJsLCBsZWFndWVUeXBlID0gJ3N0YW5kYXJkJyB9ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWRyYWZ0VXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdEcmFmdCBVUkwgaXMgcmVxdWlyZWQnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ/CfmoAgU3RhcnRpbmcgZHJhZnQgYW5hbHlzaXMuLi4nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRHJhZnQgVVJMOicsIGRyYWZ0VXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfj4ggTGVhZ3VlIFR5cGU6JywgbGVhZ3VlVHlwZSk7XG5cbiAgICAgICAgY29uc3QgYW5hbHl6ZXIgPSBuZXcgRHJhZnRBbmFseXplcigpO1xuICAgICAgICBhd2FpdCBhbmFseXplci5pbml0aWFsaXplKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplci5hbmFseXplRHJhZnQoZHJhZnRVcmwsIGxlYWd1ZVR5cGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBkcmFmdCBhbmFseXNpczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnIFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBHRVQoKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UoXCJNZXRob2QgTm90IEFsbG93ZWRcIiwgeyBzdGF0dXM6IDQwNSwgaGVhZGVyczogeyBBbGxvdzogXCJQT1NUXCIgfSB9KTtcbn0gIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJOZXh0UmVzcG9uc2UiLCJPcHRpbWFsTGluZXVwRW5naW5lIiwiUG9zaXRpb25HcmFkZUVuZ2luZSIsIkRyYWZ0QW5hbHl6ZXIiLCJpbml0aWFsaXplIiwiY29uc29sZSIsImxvZyIsIm1hc3RlclBsYXllcnNNb2R1bGUiLCJuYW1lTG9va3VwTW9kdWxlIiwidm9ycERhdGFNb2R1bGUiLCJhZHBEYXRhTW9kdWxlIiwiUHJvbWlzZSIsImFsbCIsIm1hc3RlclBsYXllcnMiLCJuYW1lTG9va3VwIiwidm9ycERhdGEiLCJhZHBEYXRhIiwiZGVmYXVsdCIsInBsYXllcnMiLCJoYXNEZWZhdWx0IiwiaGFzUGxheWVycyIsInBsYXllckNvdW50IiwibGVuZ3RoIiwic2FtcGxlUGxheWVyIiwiY29uc29saWRhdGVkRGF0YSIsImZvckVhY2giLCJwbGF5ZXIiLCJmdWxsX25hbWUiLCJ0b0xvd2VyQ2FzZSIsInBsYXllcl9pZCIsIm5hbWVMb29rdXBJbmRleCIsInZvcnBTY29yZXMiLCJhZHBQbGF5ZXJzIiwiT2JqZWN0Iiwia2V5cyIsInNsaWNlIiwiZXJyb3IiLCJFcnJvciIsImZldGNoU2xlZXBlckFwaSIsInVybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsInN0YXR1cyIsImRhdGFUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiZGF0YUxlbmd0aCIsInNhbXBsZURhdGEiLCJwYXJzZVNsZWVwZXJEcmFmdFVybCIsInJlZ2V4IiwibWF0Y2giLCJub3JtYWxpemVQbGF5ZXJOYW1lIiwibmFtZSIsInJlcGxhY2UiLCJ0cmltIiwiZmluZFBsYXllckJ5TmFtZSIsInBsYXllck5hbWUiLCJwb3NpdGlvbiIsIm5vcm1hbGl6ZWROYW1lIiwibmFtZVBhcnRzIiwic3BsaXQiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImtleSIsImVudHJpZXMiLCJrZXlQYXJ0cyIsImtleUZpcnN0TmFtZSIsImtleUxhc3ROYW1lIiwiaW5jbHVkZXMiLCJmaWx0ZXIiLCJrIiwiZ2V0UGxheWVyUHJvamVjdGVkUG9pbnRzIiwicHJvamVjdGlvbnMiLCJwb3NLZXkiLCJmcHRzIiwiZGVmZW5zZUtleXMiLCJwcm9qZWN0aW9uIiwidmFsdWUiLCJwYXJzZUZsb2F0IiwiZ2V0UGxheWVyQWRwIiwiYWRwUGxheWVyIiwiYWRwIiwiYWRwX3ZhbHVlIiwiZ2V0UGxheWVyVm9ycCIsImRpcmVjdCIsImZpbmQiLCJwIiwicE5hbWUiLCJ1bmRlZmluZWQiLCJ2b3JwX3Njb3JlIiwidm9ycFNjb3JlIiwiYW5hbHl6ZURyYWZ0IiwiZHJhZnRVcmwiLCJsZWFndWVUeXBlIiwiZHJhZnRJZCIsImRyYWZ0RGF0YSIsImRyYWZ0UGlja3MiLCJkcmFmdE5hbWUiLCJ0ZWFtcyIsInJvdW5kcyIsInNldHRpbmdzIiwicGlja3MiLCJleHBlY3RlZFBpY2tzIiwiYnVpbGRUZWFtUm9zdGVycyIsInJlc3VsdCIsImFuYWx5emVUZWFtcyIsImRyYWZ0SW5mbyIsInRvdGFsUGlja3MiLCJsaW5ldXBFbmdpbmUiLCJncmFkZUVuZ2luZSIsImFjdHVhbFRlYW1zIiwiYWN0dWFsUm91bmRzIiwiTWF0aCIsIm1heCIsInZhbHVlcyIsIm1hcCIsInRlYW0iLCJyb3N0ZXIiLCJyb3VuZCIsImFuYWx5c2lzVGVhbXMiLCJpZCIsImxpbmV1cCIsImNhbGN1bGF0ZU9wdGltYWxMaW5ldXAiLCJzY29yaW5nIiwiYWRwVmFsdWVzIiwiYWRwVmFsdWUiLCJ2IiwiYXZlcmFnZUFkcFZhbHVlIiwicmVkdWNlIiwicyIsInZvcnBWYWx1ZXMiLCJhdmVyYWdlVm9ycFNjb3JlIiwib3B0aW1hbExpbmV1cFBvaW50cyIsImNhbGN1bGF0ZVRvdGFsUHJvamVjdGVkUG9pbnRzIiwiYmVuY2hQbGF5ZXJzIiwiZ2V0QmVuY2hQbGF5ZXJzIiwiYmVuY2hQb2ludHMiLCJsaW5ldXBBbmFseXNpcyIsImFuYWx5emVMaW5ldXAiLCJ0ZWFtSWQiLCJ0ZWFtTmFtZSIsImRyYWZ0U2xvdCIsIm9wdGltYWxMaW5ldXAiLCJ0b3RhbFByb2plY3RlZFBvaW50cyIsImdyYWRlZFRlYW1zIiwiY2FsY3VsYXRlUG9zaXRpb25HcmFkZXMiLCJmaW5hbFRlYW1zIiwiZ3JhZGVkVGVhbSIsIm9yaWdpbmFsVGVhbSIsInQiLCJwb3NpdGlvbkdyYWRlcyIsIm92ZXJhbGxHcmFkZSIsImdyYWRlIiwic2NvcmUiLCJhdmVyYWdlUHJvamVjdGVkUG9pbnRzIiwic3VtIiwicHJvamVjdGVkUG9pbnRzIiwiYW5hbHlzaXMiLCJzbG90VG9Sb3N0ZXJJZCIsInNsb3RfdG9fcm9zdGVyX2lkIiwic2xvdFRvTmFtZSIsIm1ldGFkYXRhIiwiZHJhZnRfb3JkZXJfYnlfcm9zdGVyX2lkIiwicm9zdGVySWQiLCJzbG90IiwicGFyc2VJbnQiLCJwbGF5ZXJzTWFwIiwiZ2V0U2xlZXBlclBsYXllciIsInBpY2siLCJpbmRleCIsImRyYWZ0X3Nsb3QiLCJ3YXJuIiwidG9TdHJpbmciLCJzbGVlcGVyUGxheWVyIiwidG90YWxUZWFtcyIsImZsb29yIiwiZW5oYW5jZWRQbGF5ZXIiLCJlbmhhbmNlUGxheWVyRGF0YSIsInB1c2giLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiZHJhZnRWYWx1ZSIsInBsYXllcklkIiwicGxheWVyRGV0YWlscyIsIlBPU1QiLCJyZXF1ZXN0Iiwic3VjY2VzcyIsImFuYWx5emVyIiwibWVzc2FnZSIsIkdFVCIsIlJlc3BvbnNlIiwiaGVhZGVycyIsIkFsbG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/analyze-draft/route.ts\n");

/***/ }),

/***/ "(rsc)/./app/lib/optimal-lineup-engine.ts":
/*!******************************************!*\
  !*** ./app/lib/optimal-lineup-engine.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OptimalLineupEngine)\n/* harmony export */ });\nclass OptimalLineupEngine {\n    getRosterRequirements(leagueType = \"standard\", actualTeams = 12, actualRounds = 16) {\n        // Fixed starter requirements - bench size scales with rounds, not starters\n        const baseRequirements = {\n            standard: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            superflex: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"QB\",\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2qb\": {\n                QB: 2,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2flex\": {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 2,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"robs-bullshit\": {\n                QB: 2,\n                RB: 2,\n                WR: 3,\n                TE: 1,\n                FLEX: 2,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            }\n        };\n        const requirements = baseRequirements[leagueType] || baseRequirements.standard;\n        // Calculate total starters (fixed, doesn't change with rounds)\n        const totalStarters = Object.entries(requirements).filter(([key])=>![\n                \"flexPositions\",\n                \"superflexPositions\"\n            ].includes(key)).reduce((sum, [_, count])=>sum + (typeof count === \"number\" ? count : 0), 0);\n        return {\n            ...requirements,\n            totalStarters,\n            // Add metadata about the dynamic calculation\n            _metadata: {\n                actualTeams,\n                actualRounds,\n                leagueType,\n                calculatedAt: new Date().toISOString()\n            }\n        };\n    }\n    calculateOptimalLineup(roster, settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const actualTeams = settings.teams || 12;\n        const actualRounds = settings.rounds || 16; // Get actual rounds from settings\n        // Calculate roster requirements based on actual draft data\n        const requirements = this.getRosterRequirements(leagueType, actualTeams, actualRounds);\n        console.log(\"\\uD83D\\uDD0D Calculating optimal lineup:\", {\n            leagueType,\n            actualTeams,\n            actualRounds,\n            requirements: {\n                ...requirements,\n                _metadata: requirements._metadata\n            }\n        });\n        // Group players by position\n        const positionGroups = this.groupPlayersByPosition(roster);\n        // Start building optimal lineup\n        const optimalLineup = {};\n        const usedPlayers = new Set();\n        console.log(\"\\uD83D\\uDD0D Filling required positions...\");\n        // Fill required positions first (excluding special positions)\n        Object.entries(requirements).forEach(([position, count])=>{\n            if (position === \"totalStarters\" || position === \"flexPositions\" || position === \"superflexPositions\") return;\n            console.log(`🔍 Processing position: ${position}, count: ${count}`);\n            if (typeof count === \"number\" && count > 0) {\n                optimalLineup[position] = [];\n                // Get best players for this position\n                const availablePlayers = positionGroups[position] || [];\n                console.log(`🔍 Available players for ${position}:`, availablePlayers);\n                const sortedPlayers = availablePlayers.filter((p)=>!usedPlayers.has(p.playerId || p.playerName)).sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0)).slice(0, count);\n                console.log(`🔍 Selected players for ${position}:`, sortedPlayers);\n                optimalLineup[position] = sortedPlayers;\n                sortedPlayers.forEach((p)=>usedPlayers.add(p.playerId || p.playerName));\n            }\n        });\n        // Handle FLEX position\n        if (requirements.flexPositions) {\n            const flexPlayers = requirements.flexPositions.flatMap((pos)=>(positionGroups[pos] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName)));\n            if (flexPlayers.length > 0) {\n                const bestFlexPlayer = flexPlayers.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n                if (bestFlexPlayer) {\n                    optimalLineup.FLEX = [\n                        bestFlexPlayer\n                    ];\n                    usedPlayers.add(bestFlexPlayer.playerId || bestFlexPlayer.playerName);\n                    // Log which type of flex this is\n                    if (leagueType === \"superflex\") {\n                        console.log(`🦸 Superflex FLEX: Selected ${bestFlexPlayer.position} ${bestFlexPlayer.playerName} with ${bestFlexPlayer.projectedPoints} points`);\n                    } else {\n                        console.log(`🔄 Standard FLEX: Selected ${bestFlexPlayer.position} ${bestFlexPlayer.playerName} with ${bestFlexPlayer.projectedPoints} points`);\n                    }\n                }\n            }\n        }\n        // Handle 2 FLEX positions (if applicable)\n        if ((leagueType === \"2flex\" || leagueType === \"robs-bullshit\") && requirements.FLEX === 2) {\n            optimalLineup.FLEX = [];\n            const bestFlexPlayer1 = this.findBestFlexPlayer(positionGroups, usedPlayers);\n            if (bestFlexPlayer1) {\n                optimalLineup.FLEX.push(bestFlexPlayer1);\n                usedPlayers.add(bestFlexPlayer1.playerId || bestFlexPlayer1.playerName);\n                console.log(`🔄 FLEX 1: Selected ${bestFlexPlayer1.position} ${bestFlexPlayer1.playerName} with ${bestFlexPlayer1.projectedPoints} points`);\n            }\n            const bestFlexPlayer2 = this.findBestFlexPlayer(positionGroups, usedPlayers);\n            if (bestFlexPlayer2) {\n                optimalLineup.FLEX.push(bestFlexPlayer2);\n                usedPlayers.add(bestFlexPlayer2.playerId || bestFlexPlayer2.playerName);\n                console.log(`🔄 FLEX 2: Selected ${bestFlexPlayer2.position} ${bestFlexPlayer2.playerName} with ${bestFlexPlayer2.projectedPoints} points`);\n            }\n        }\n        // Ensure all required positions have at least an empty array\n        Object.entries(requirements).forEach(([position, count])=>{\n            if (position === \"totalStarters\" || position === \"flexPositions\" || position === \"superflexPositions\") return;\n            if (typeof count === \"number\" && count > 0 && !optimalLineup[position]) {\n                optimalLineup[position] = [];\n            }\n        });\n        return optimalLineup;\n    }\n    findBestSuperflexPlayer(positionGroups, usedPlayers) {\n        // Get all available superflex eligible players\n        const availableQBs = (positionGroups[\"QB\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableRBs = (positionGroups[\"RB\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableWRs = (positionGroups[\"WR\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableTEs = (positionGroups[\"TE\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        // In superflex, QBs are extremely valuable - give them priority\n        let bestSuperflexPlayer = null;\n        // First priority: Best available QB (QBs score much higher than other positions)\n        if (availableQBs.length > 0) {\n            const bestQB = availableQBs.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            bestSuperflexPlayer = bestQB;\n        }\n        // If no QBs available, select best RB/WR/TE\n        if (!bestSuperflexPlayer) {\n            const otherPlayers = [\n                ...availableRBs,\n                ...availableWRs,\n                ...availableTEs\n            ];\n            if (otherPlayers.length > 0) {\n                bestSuperflexPlayer = otherPlayers.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            }\n        }\n        return bestSuperflexPlayer;\n    }\n    findBestFlexPlayer(positionGroups, usedPlayers) {\n        // Get all available flex eligible players\n        const availableRBs = (positionGroups[\"RB\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableWRs = (positionGroups[\"WR\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        const availableTEs = (positionGroups[\"TE\"] || []).filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n        // In flex, RB/WR/TE are all valuable - give them priority\n        let bestFlexPlayer = null;\n        // First priority: Best available RB\n        if (availableRBs.length > 0) {\n            const bestRB = availableRBs.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            bestFlexPlayer = bestRB;\n        }\n        // If no RBs available, select best WR/TE\n        if (!bestFlexPlayer) {\n            const otherPlayers = [\n                ...availableWRs,\n                ...availableTEs\n            ];\n            if (otherPlayers.length > 0) {\n                bestFlexPlayer = otherPlayers.sort((a, b)=>(b.projectedPoints || 0) - (a.projectedPoints || 0))[0];\n            }\n        }\n        return bestFlexPlayer;\n    }\n    groupPlayersByPosition(roster) {\n        const groups = {};\n        console.log(\"\\uD83D\\uDD0D Grouping players by position. Roster:\", roster);\n        roster.forEach((player)=>{\n            const position = (player.position || \"\").toUpperCase();\n            console.log(`🔍 Player: ${player.playerName}, Position: ${position}, Raw position: ${player.position}`);\n            if (!position) {\n                console.log(`⚠️ Skipping player ${player.playerName} - no position`);\n                return;\n            }\n            if (!groups[position]) {\n                groups[position] = [];\n            }\n            groups[position].push(player);\n        });\n        console.log(\"\\uD83D\\uDD0D Grouped players:\", groups);\n        return groups;\n    }\n    getBenchPlayers(roster, optimalLineup) {\n        const usedPlayers = new Set();\n        // Collect all players used in optimal lineup\n        Object.values(optimalLineup).forEach((players)=>{\n            if (Array.isArray(players)) {\n                players.forEach((p)=>{\n                    usedPlayers.add(p.playerId || p.playerName);\n                });\n            }\n        });\n        // Return players not used in optimal lineup\n        return roster.filter((p)=>!usedPlayers.has(p.playerId || p.playerName));\n    }\n    calculateTotalProjectedPoints(players) {\n        if (Array.isArray(players)) {\n            return players.reduce((total, player)=>total + (player.projectedPoints || 0), 0);\n        }\n        // Handle object format\n        let total = 0;\n        Object.values(players).forEach((positionPlayers)=>{\n            if (Array.isArray(positionPlayers)) {\n                total += positionPlayers.reduce((sum, p)=>sum + (p.projectedPoints || 0), 0);\n            }\n        });\n        return total;\n    }\n    analyzeLineup(optimalLineup, settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const superflexSlots = settings.superflexSlots || 0;\n        const actualTeams = settings.teams || 12;\n        const actualRounds = 16; // Default to 16 rounds for dynamic calculation\n        const requirements = this.getRosterRequirements(leagueType, actualTeams, actualRounds);\n        return {\n            totalStarters: requirements.totalStarters,\n            leagueType,\n            superflexSlots: requirements.superflexPositions ? requirements.superflexPositions.length : 0,\n            requirements,\n            positionCounts: Object.entries(requirements).filter(([key])=>![\n                    \"totalStarters\",\n                    \"flexPositions\",\n                    \"superflexPositions\"\n                ].includes(key)).reduce((acc, [pos, count])=>({\n                    ...acc,\n                    [pos]: count\n                }), {})\n        };\n    }\n    // Calculate replacement baselines for VORP calculations\n    calculateReplacementBaselines(settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const superflexSlots = settings.superflexSlots || 0;\n        const actualTeams = settings.teams || 12;\n        const actualRounds = 16; // Default to 16 rounds for dynamic calculation\n        const baselines = {\n            QB: actualTeams * (1 + superflexSlots),\n            RB: actualTeams * 2,\n            WR: actualTeams * 2,\n            TE: actualTeams * 1,\n            K: actualTeams * 1,\n            DEF: actualTeams * 1\n        };\n        return baselines;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxDQUFDLENBQUNDLElBQUksR0FBSyxDQUFDO29CQUFDO29CQUFpQjtvQkFBaUI7aUJBQXFCLENBQUNDLFFBQVEsQ0FBQ0QsTUFDckZFLE1BQU0sQ0FBQyxDQUFDa0UsS0FBSyxDQUFDOUIsS0FBS2pDLE1BQU0sR0FBTTtvQkFBRSxHQUFHK0QsR0FBRztvQkFBRSxDQUFDOUIsSUFBSSxFQUFFakM7Z0JBQU0sSUFBSSxDQUFDO1FBQ2hFO0lBQ0Y7SUFFQSx3REFBd0Q7SUFDeERnRSw4QkFBOEJ6RCxXQUEyQixDQUFDLENBQUMsRUFBRTtRQUMzRCxNQUFNaEMsYUFBYWdDLFNBQVNoQyxVQUFVLElBQUk7UUFDMUMsTUFBTXNGLGlCQUFpQnRELFNBQVNzRCxjQUFjLElBQUk7UUFDbEQsTUFBTXJGLGNBQWMrQixTQUFTQyxLQUFLLElBQUk7UUFDdEMsTUFBTS9CLGVBQWUsSUFBSSwrQ0FBK0M7UUFFeEUsTUFBTXdGLFlBQVk7WUFDaEJyRixJQUFJSixjQUFlLEtBQUlxRixjQUFhO1lBQ3BDaEYsSUFBSUwsY0FBYztZQUNsQk0sSUFBSU4sY0FBYztZQUNsQk8sSUFBSVAsY0FBYztZQUNsQlUsR0FBR1YsY0FBYztZQUNqQlMsS0FBS1QsY0FBYztRQUNyQjtRQUVBLE9BQU95RjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mZl9hcGlfc2tlbGV0b24vLi9hcHAvbGliL29wdGltYWwtbGluZXVwLWVuZ2luZS50cz82YjNkIl0sInNvdXJjZXNDb250ZW50IjpbInR5cGUgTGVhZ3VlU2V0dGluZ3MgPSB7XG4gIHNjb3Jpbmc/OiBzdHJpbmc7XG4gIGxlYWd1ZVR5cGU/OiBzdHJpbmc7XG4gIHN1cGVyZmxleFNsb3RzPzogbnVtYmVyO1xuICB0ZWFtcz86IG51bWJlcjtcbiAgcm91bmRzPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW1hbExpbmV1cEVuZ2luZSB7XG4gIHByaXZhdGUgZ2V0Um9zdGVyUmVxdWlyZW1lbnRzKGxlYWd1ZVR5cGU6IHN0cmluZyA9ICdzdGFuZGFyZCcsIGFjdHVhbFRlYW1zOiBudW1iZXIgPSAxMiwgYWN0dWFsUm91bmRzOiBudW1iZXIgPSAxNikge1xuICAgIC8vIEZpeGVkIHN0YXJ0ZXIgcmVxdWlyZW1lbnRzIC0gYmVuY2ggc2l6ZSBzY2FsZXMgd2l0aCByb3VuZHMsIG5vdCBzdGFydGVyc1xuICAgIGNvbnN0IGJhc2VSZXF1aXJlbWVudHMgPSB7XG4gICAgICBzdGFuZGFyZDoge1xuICAgICAgICBRQjogMSwgUkI6IDIsIFdSOiAyLCBURTogMSwgRkxFWDogMSwgREVGOiAxLCBLOiAxLCAvLyA5IHN0YXJ0ZXJzXG4gICAgICAgIGZsZXhQb3NpdGlvbnM6IFsnUkInLCAnV1InLCAnVEUnXSxcbiAgICAgICAgc3VwZXJmbGV4UG9zaXRpb25zOiBbXVxuICAgICAgfSxcbiAgICAgIHN1cGVyZmxleDoge1xuICAgICAgICBRQjogMSwgUkI6IDIsIFdSOiAyLCBURTogMSwgRkxFWDogMSwgREVGOiAxLCBLOiAxLCAvLyA5IHN0YXJ0ZXJzIChRQiBlbGlnaWJsZSBpbiBmbGV4KVxuICAgICAgICBmbGV4UG9zaXRpb25zOiBbJ1FCJywgJ1JCJywgJ1dSJywgJ1RFJ10sIC8vIFFCIGVsaWdpYmxlIGluIGZsZXhcbiAgICAgICAgc3VwZXJmbGV4UG9zaXRpb25zOiBbXVxuICAgICAgfSxcbiAgICAgICcycWInOiB7XG4gICAgICAgIFFCOiAyLCBSQjogMiwgV1I6IDIsIFRFOiAxLCBGTEVYOiAxLCBERUY6IDEsIEs6IDEsIC8vIDEwIHN0YXJ0ZXJzXG4gICAgICAgIGZsZXhQb3NpdGlvbnM6IFsnUkInLCAnV1InLCAnVEUnXSxcbiAgICAgICAgc3VwZXJmbGV4UG9zaXRpb25zOiBbXVxuICAgICAgfSxcbiAgICAgICcyZmxleCc6IHtcbiAgICAgICAgUUI6IDEsIFJCOiAyLCBXUjogMiwgVEU6IDEsIEZMRVg6IDIsIERFRjogMSwgSzogMSwgLy8gMTAgc3RhcnRlcnNcbiAgICAgICAgZmxleFBvc2l0aW9uczogWydSQicsICdXUicsICdURSddLFxuICAgICAgICBzdXBlcmZsZXhQb3NpdGlvbnM6IFtdXG4gICAgICB9LFxuICAgICAgJ3JvYnMtYnVsbHNoaXQnOiB7XG4gICAgICAgIFFCOiAyLCBSQjogMiwgV1I6IDMsIFRFOiAxLCBGTEVYOiAyLCBERUY6IDEsIEs6IDEsIC8vIDEyIHN0YXJ0ZXJzIChUSEUgQkVBU1QhKVxuICAgICAgICBmbGV4UG9zaXRpb25zOiBbJ1JCJywgJ1dSJywgJ1RFJ10sXG4gICAgICAgIHN1cGVyZmxleFBvc2l0aW9uczogW11cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gYmFzZVJlcXVpcmVtZW50c1tsZWFndWVUeXBlIGFzIGtleW9mIHR5cGVvZiBiYXNlUmVxdWlyZW1lbnRzXSB8fCBiYXNlUmVxdWlyZW1lbnRzLnN0YW5kYXJkO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBzdGFydGVycyAoZml4ZWQsIGRvZXNuJ3QgY2hhbmdlIHdpdGggcm91bmRzKVxuICAgIGNvbnN0IHRvdGFsU3RhcnRlcnMgPSBPYmplY3QuZW50cmllcyhyZXF1aXJlbWVudHMpXG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4gIVsnZmxleFBvc2l0aW9ucycsICdzdXBlcmZsZXhQb3NpdGlvbnMnXS5pbmNsdWRlcyhrZXkpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBbXywgY291bnRdKSA9PiBzdW0gKyAodHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyA/IGNvdW50IDogMCksIDApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcXVpcmVtZW50cyxcbiAgICAgIHRvdGFsU3RhcnRlcnMsXG4gICAgICAvLyBBZGQgbWV0YWRhdGEgYWJvdXQgdGhlIGR5bmFtaWMgY2FsY3VsYXRpb25cbiAgICAgIF9tZXRhZGF0YToge1xuICAgICAgICBhY3R1YWxUZWFtcyxcbiAgICAgICAgYWN0dWFsUm91bmRzLFxuICAgICAgICBsZWFndWVUeXBlLFxuICAgICAgICBjYWxjdWxhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVPcHRpbWFsTGluZXVwKHJvc3RlcjogYW55W10sIHNldHRpbmdzOiBMZWFndWVTZXR0aW5ncyA9IHt9KSB7XG4gICAgY29uc3QgbGVhZ3VlVHlwZSA9IHNldHRpbmdzLmxlYWd1ZVR5cGUgfHwgJ3N0YW5kYXJkJztcbiAgICBjb25zdCBhY3R1YWxUZWFtcyA9IHNldHRpbmdzLnRlYW1zIHx8IDEyO1xuICAgIGNvbnN0IGFjdHVhbFJvdW5kcyA9IHNldHRpbmdzLnJvdW5kcyB8fCAxNjsgLy8gR2V0IGFjdHVhbCByb3VuZHMgZnJvbSBzZXR0aW5nc1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSByb3N0ZXIgcmVxdWlyZW1lbnRzIGJhc2VkIG9uIGFjdHVhbCBkcmFmdCBkYXRhXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gdGhpcy5nZXRSb3N0ZXJSZXF1aXJlbWVudHMobGVhZ3VlVHlwZSwgYWN0dWFsVGVhbXMsIGFjdHVhbFJvdW5kcyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gQ2FsY3VsYXRpbmcgb3B0aW1hbCBsaW5ldXA6JywgeyBcbiAgICAgIGxlYWd1ZVR5cGUsIFxuICAgICAgYWN0dWFsVGVhbXMsIFxuICAgICAgYWN0dWFsUm91bmRzLCBcbiAgICAgIHJlcXVpcmVtZW50czoge1xuICAgICAgICAuLi5yZXF1aXJlbWVudHMsXG4gICAgICAgIF9tZXRhZGF0YTogcmVxdWlyZW1lbnRzLl9tZXRhZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEdyb3VwIHBsYXllcnMgYnkgcG9zaXRpb25cbiAgICBjb25zdCBwb3NpdGlvbkdyb3VwcyA9IHRoaXMuZ3JvdXBQbGF5ZXJzQnlQb3NpdGlvbihyb3N0ZXIpO1xuICAgIFxuICAgIC8vIFN0YXJ0IGJ1aWxkaW5nIG9wdGltYWwgbGluZXVwXG4gICAgY29uc3Qgb3B0aW1hbExpbmV1cDogUmVjb3JkPHN0cmluZywgYW55W10+ID0ge307XG4gICAgY29uc3QgdXNlZFBsYXllcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/CflI0gRmlsbGluZyByZXF1aXJlZCBwb3NpdGlvbnMuLi4nKTtcbiAgICBcbiAgICAvLyBGaWxsIHJlcXVpcmVkIHBvc2l0aW9ucyBmaXJzdCAoZXhjbHVkaW5nIHNwZWNpYWwgcG9zaXRpb25zKVxuICAgIE9iamVjdC5lbnRyaWVzKHJlcXVpcmVtZW50cykuZm9yRWFjaCgoW3Bvc2l0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvdGFsU3RhcnRlcnMnIHx8IHBvc2l0aW9uID09PSAnZmxleFBvc2l0aW9ucycgfHwgcG9zaXRpb24gPT09ICdzdXBlcmZsZXhQb3NpdGlvbnMnKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFByb2Nlc3NpbmcgcG9zaXRpb246ICR7cG9zaXRpb259LCBjb3VudDogJHtjb3VudH1gKTtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiBjb3VudCA9PT0gJ251bWJlcicgJiYgY291bnQgPiAwKSB7XG4gICAgICAgIG9wdGltYWxMaW5ldXBbcG9zaXRpb25dID0gW107XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgYmVzdCBwbGF5ZXJzIGZvciB0aGlzIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVBsYXllcnMgPSBwb3NpdGlvbkdyb3Vwc1twb3NpdGlvbl0gfHwgW107XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEF2YWlsYWJsZSBwbGF5ZXJzIGZvciAke3Bvc2l0aW9ufTpgLCBhdmFpbGFibGVQbGF5ZXJzKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNvcnRlZFBsYXllcnMgPSBhdmFpbGFibGVQbGF5ZXJzXG4gICAgICAgICAgLmZpbHRlcigocDogYW55KSA9PiAhdXNlZFBsYXllcnMuaGFzKHAucGxheWVySWQgfHwgcC5wbGF5ZXJOYW1lKSlcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gKGIucHJvamVjdGVkUG9pbnRzIHx8IDApIC0gKGEucHJvamVjdGVkUG9pbnRzIHx8IDApKVxuICAgICAgICAgIC5zbGljZSgwLCBjb3VudCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBTZWxlY3RlZCBwbGF5ZXJzIGZvciAke3Bvc2l0aW9ufTpgLCBzb3J0ZWRQbGF5ZXJzKTtcbiAgICAgICAgXG4gICAgICAgIG9wdGltYWxMaW5ldXBbcG9zaXRpb25dID0gc29ydGVkUGxheWVycztcbiAgICAgICAgc29ydGVkUGxheWVycy5mb3JFYWNoKChwOiBhbnkpID0+IHVzZWRQbGF5ZXJzLmFkZChwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBGTEVYIHBvc2l0aW9uXG4gICAgaWYgKHJlcXVpcmVtZW50cy5mbGV4UG9zaXRpb25zKSB7XG4gICAgICBjb25zdCBmbGV4UGxheWVycyA9IHJlcXVpcmVtZW50cy5mbGV4UG9zaXRpb25zLmZsYXRNYXAocG9zID0+IFxuICAgICAgICAocG9zaXRpb25Hcm91cHNbcG9zXSB8fCBbXSkuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGZsZXhQbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYmVzdEZsZXhQbGF5ZXIgPSBmbGV4UGxheWVyc1xuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiAoYi5wcm9qZWN0ZWRQb2ludHMgfHwgMCkgLSAoYS5wcm9qZWN0ZWRQb2ludHMgfHwgMCkpWzBdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGJlc3RGbGV4UGxheWVyKSB7XG4gICAgICAgICAgb3B0aW1hbExpbmV1cC5GTEVYID0gW2Jlc3RGbGV4UGxheWVyXTtcbiAgICAgICAgICB1c2VkUGxheWVycy5hZGQoYmVzdEZsZXhQbGF5ZXIucGxheWVySWQgfHwgYmVzdEZsZXhQbGF5ZXIucGxheWVyTmFtZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9nIHdoaWNoIHR5cGUgb2YgZmxleCB0aGlzIGlzXG4gICAgICAgICAgaWYgKGxlYWd1ZVR5cGUgPT09ICdzdXBlcmZsZXgnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+muCBTdXBlcmZsZXggRkxFWDogU2VsZWN0ZWQgJHtiZXN0RmxleFBsYXllci5wb3NpdGlvbn0gJHtiZXN0RmxleFBsYXllci5wbGF5ZXJOYW1lfSB3aXRoICR7YmVzdEZsZXhQbGF5ZXIucHJvamVjdGVkUG9pbnRzfSBwb2ludHNgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgU3RhbmRhcmQgRkxFWDogU2VsZWN0ZWQgJHtiZXN0RmxleFBsYXllci5wb3NpdGlvbn0gJHtiZXN0RmxleFBsYXllci5wbGF5ZXJOYW1lfSB3aXRoICR7YmVzdEZsZXhQbGF5ZXIucHJvamVjdGVkUG9pbnRzfSBwb2ludHNgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIDIgRkxFWCBwb3NpdGlvbnMgKGlmIGFwcGxpY2FibGUpXG4gICAgaWYgKChsZWFndWVUeXBlID09PSAnMmZsZXgnIHx8IGxlYWd1ZVR5cGUgPT09ICdyb2JzLWJ1bGxzaGl0JykgJiYgcmVxdWlyZW1lbnRzLkZMRVggPT09IDIpIHtcbiAgICAgIG9wdGltYWxMaW5ldXAuRkxFWCA9IFtdO1xuICAgICAgY29uc3QgYmVzdEZsZXhQbGF5ZXIxID0gdGhpcy5maW5kQmVzdEZsZXhQbGF5ZXIocG9zaXRpb25Hcm91cHMsIHVzZWRQbGF5ZXJzKTtcbiAgICAgIGlmIChiZXN0RmxleFBsYXllcjEpIHtcbiAgICAgICAgb3B0aW1hbExpbmV1cC5GTEVYLnB1c2goYmVzdEZsZXhQbGF5ZXIxKTtcbiAgICAgICAgdXNlZFBsYXllcnMuYWRkKGJlc3RGbGV4UGxheWVyMS5wbGF5ZXJJZCB8fCBiZXN0RmxleFBsYXllcjEucGxheWVyTmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIEZMRVggMTogU2VsZWN0ZWQgJHtiZXN0RmxleFBsYXllcjEucG9zaXRpb259ICR7YmVzdEZsZXhQbGF5ZXIxLnBsYXllck5hbWV9IHdpdGggJHtiZXN0RmxleFBsYXllcjEucHJvamVjdGVkUG9pbnRzfSBwb2ludHNgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJlc3RGbGV4UGxheWVyMiA9IHRoaXMuZmluZEJlc3RGbGV4UGxheWVyKHBvc2l0aW9uR3JvdXBzLCB1c2VkUGxheWVycyk7XG4gICAgICBpZiAoYmVzdEZsZXhQbGF5ZXIyKSB7XG4gICAgICAgIG9wdGltYWxMaW5ldXAuRkxFWC5wdXNoKGJlc3RGbGV4UGxheWVyMik7XG4gICAgICAgIHVzZWRQbGF5ZXJzLmFkZChiZXN0RmxleFBsYXllcjIucGxheWVySWQgfHwgYmVzdEZsZXhQbGF5ZXIyLnBsYXllck5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBGTEVYIDI6IFNlbGVjdGVkICR7YmVzdEZsZXhQbGF5ZXIyLnBvc2l0aW9ufSAke2Jlc3RGbGV4UGxheWVyMi5wbGF5ZXJOYW1lfSB3aXRoICR7YmVzdEZsZXhQbGF5ZXIyLnByb2plY3RlZFBvaW50c30gcG9pbnRzYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSBhbGwgcmVxdWlyZWQgcG9zaXRpb25zIGhhdmUgYXQgbGVhc3QgYW4gZW1wdHkgYXJyYXlcbiAgICBPYmplY3QuZW50cmllcyhyZXF1aXJlbWVudHMpLmZvckVhY2goKFtwb3NpdGlvbiwgY291bnRdKSA9PiB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICd0b3RhbFN0YXJ0ZXJzJyB8fCBwb3NpdGlvbiA9PT0gJ2ZsZXhQb3NpdGlvbnMnIHx8IHBvc2l0aW9uID09PSAnc3VwZXJmbGV4UG9zaXRpb25zJykgcmV0dXJuO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyAmJiBjb3VudCA+IDAgJiYgIW9wdGltYWxMaW5ldXBbcG9zaXRpb25dKSB7XG4gICAgICAgIG9wdGltYWxMaW5ldXBbcG9zaXRpb25dID0gW107XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIG9wdGltYWxMaW5ldXA7XG4gIH1cblxuICBwcml2YXRlIGZpbmRCZXN0U3VwZXJmbGV4UGxheWVyKHBvc2l0aW9uR3JvdXBzOiBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4sIHVzZWRQbGF5ZXJzOiBTZXQ8c3RyaW5nIHwgdW5rbm93bj4pIHtcbiAgICAvLyBHZXQgYWxsIGF2YWlsYWJsZSBzdXBlcmZsZXggZWxpZ2libGUgcGxheWVyc1xuICAgIGNvbnN0IGF2YWlsYWJsZVFCcyA9IChwb3NpdGlvbkdyb3Vwc1snUUInXSB8fCBbXSkuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKTtcbiAgICBjb25zdCBhdmFpbGFibGVSQnMgPSAocG9zaXRpb25Hcm91cHNbJ1JCJ10gfHwgW10pLmZpbHRlcigocDogYW55KSA9PiAhdXNlZFBsYXllcnMuaGFzKHAucGxheWVySWQgfHwgcC5wbGF5ZXJOYW1lKSk7XG4gICAgY29uc3QgYXZhaWxhYmxlV1JzID0gKHBvc2l0aW9uR3JvdXBzWydXUiddIHx8IFtdKS5maWx0ZXIoKHA6IGFueSkgPT4gIXVzZWRQbGF5ZXJzLmhhcyhwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSkpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVRFcyA9IChwb3NpdGlvbkdyb3Vwc1snVEUnXSB8fCBbXSkuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKTtcbiAgICBcbiAgICAvLyBJbiBzdXBlcmZsZXgsIFFCcyBhcmUgZXh0cmVtZWx5IHZhbHVhYmxlIC0gZ2l2ZSB0aGVtIHByaW9yaXR5XG4gICAgbGV0IGJlc3RTdXBlcmZsZXhQbGF5ZXIgPSBudWxsO1xuICAgIFxuICAgIC8vIEZpcnN0IHByaW9yaXR5OiBCZXN0IGF2YWlsYWJsZSBRQiAoUUJzIHNjb3JlIG11Y2ggaGlnaGVyIHRoYW4gb3RoZXIgcG9zaXRpb25zKVxuICAgIGlmIChhdmFpbGFibGVRQnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYmVzdFFCID0gYXZhaWxhYmxlUUJzLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiAoYi5wcm9qZWN0ZWRQb2ludHMgfHwgMCkgLSAoYS5wcm9qZWN0ZWRQb2ludHMgfHwgMCkpWzBdO1xuICAgICAgYmVzdFN1cGVyZmxleFBsYXllciA9IGJlc3RRQjtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gUUJzIGF2YWlsYWJsZSwgc2VsZWN0IGJlc3QgUkIvV1IvVEVcbiAgICBpZiAoIWJlc3RTdXBlcmZsZXhQbGF5ZXIpIHtcbiAgICAgIGNvbnN0IG90aGVyUGxheWVycyA9IFsuLi5hdmFpbGFibGVSQnMsIC4uLmF2YWlsYWJsZVdScywgLi4uYXZhaWxhYmxlVEVzXTtcbiAgICAgIGlmIChvdGhlclBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBiZXN0U3VwZXJmbGV4UGxheWVyID0gb3RoZXJQbGF5ZXJzLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiAoYi5wcm9qZWN0ZWRQb2ludHMgfHwgMCkgLSAoYS5wcm9qZWN0ZWRQb2ludHMgfHwgMCkpWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYmVzdFN1cGVyZmxleFBsYXllcjtcbiAgfVxuXG4gIHByaXZhdGUgZmluZEJlc3RGbGV4UGxheWVyKHBvc2l0aW9uR3JvdXBzOiBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4sIHVzZWRQbGF5ZXJzOiBTZXQ8c3RyaW5nIHwgdW5rbm93bj4pIHtcbiAgICAvLyBHZXQgYWxsIGF2YWlsYWJsZSBmbGV4IGVsaWdpYmxlIHBsYXllcnNcbiAgICBjb25zdCBhdmFpbGFibGVSQnMgPSAocG9zaXRpb25Hcm91cHNbJ1JCJ10gfHwgW10pLmZpbHRlcigocDogYW55KSA9PiAhdXNlZFBsYXllcnMuaGFzKHAucGxheWVySWQgfHwgcC5wbGF5ZXJOYW1lKSk7XG4gICAgY29uc3QgYXZhaWxhYmxlV1JzID0gKHBvc2l0aW9uR3JvdXBzWydXUiddIHx8IFtdKS5maWx0ZXIoKHA6IGFueSkgPT4gIXVzZWRQbGF5ZXJzLmhhcyhwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSkpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVRFcyA9IChwb3NpdGlvbkdyb3Vwc1snVEUnXSB8fCBbXSkuZmlsdGVyKChwOiBhbnkpID0+ICF1c2VkUGxheWVycy5oYXMocC5wbGF5ZXJJZCB8fCBwLnBsYXllck5hbWUpKTtcbiAgICBcbiAgICAvLyBJbiBmbGV4LCBSQi9XUi9URSBhcmUgYWxsIHZhbHVhYmxlIC0gZ2l2ZSB0aGVtIHByaW9yaXR5XG4gICAgbGV0IGJlc3RGbGV4UGxheWVyID0gbnVsbDtcbiAgICBcbiAgICAvLyBGaXJzdCBwcmlvcml0eTogQmVzdCBhdmFpbGFibGUgUkJcbiAgICBpZiAoYXZhaWxhYmxlUkJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJlc3RSQiA9IGF2YWlsYWJsZVJCcy5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gKGIucHJvamVjdGVkUG9pbnRzIHx8IDApIC0gKGEucHJvamVjdGVkUG9pbnRzIHx8IDApKVswXTtcbiAgICAgIGJlc3RGbGV4UGxheWVyID0gYmVzdFJCO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBubyBSQnMgYXZhaWxhYmxlLCBzZWxlY3QgYmVzdCBXUi9URVxuICAgIGlmICghYmVzdEZsZXhQbGF5ZXIpIHtcbiAgICAgIGNvbnN0IG90aGVyUGxheWVycyA9IFsuLi5hdmFpbGFibGVXUnMsIC4uLmF2YWlsYWJsZVRFc107XG4gICAgICBpZiAob3RoZXJQbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmVzdEZsZXhQbGF5ZXIgPSBvdGhlclBsYXllcnMuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IChiLnByb2plY3RlZFBvaW50cyB8fCAwKSAtIChhLnByb2plY3RlZFBvaW50cyB8fCAwKSlbMF07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBiZXN0RmxleFBsYXllcjtcbiAgfVxuXG4gIHByaXZhdGUgZ3JvdXBQbGF5ZXJzQnlQb3NpdGlvbihyb3N0ZXI6IGFueVtdKSB7XG4gICAgY29uc3QgZ3JvdXBzOiBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4gPSB7fTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+UjSBHcm91cGluZyBwbGF5ZXJzIGJ5IHBvc2l0aW9uLiBSb3N0ZXI6Jywgcm9zdGVyKTtcbiAgICBcbiAgICByb3N0ZXIuZm9yRWFjaCgocGxheWVyKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IChwbGF5ZXIucG9zaXRpb24gfHwgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBQbGF5ZXI6ICR7cGxheWVyLnBsYXllck5hbWV9LCBQb3NpdGlvbjogJHtwb3NpdGlvbn0sIFJhdyBwb3NpdGlvbjogJHtwbGF5ZXIucG9zaXRpb259YCk7XG4gICAgICBcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBTa2lwcGluZyBwbGF5ZXIgJHtwbGF5ZXIucGxheWVyTmFtZX0gLSBubyBwb3NpdGlvbmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghZ3JvdXBzW3Bvc2l0aW9uXSkge1xuICAgICAgICBncm91cHNbcG9zaXRpb25dID0gW107XG4gICAgICB9XG4gICAgICBncm91cHNbcG9zaXRpb25dLnB1c2gocGxheWVyKTtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+UjSBHcm91cGVkIHBsYXllcnM6JywgZ3JvdXBzKTtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG5cbiAgZ2V0QmVuY2hQbGF5ZXJzKHJvc3RlcjogYW55W10sIG9wdGltYWxMaW5ldXA6IFJlY29yZDxzdHJpbmcsIGFueVtdPik6IGFueVtdIHtcbiAgICBjb25zdCB1c2VkUGxheWVycyA9IG5ldyBTZXQoKTtcbiAgICBcbiAgICAvLyBDb2xsZWN0IGFsbCBwbGF5ZXJzIHVzZWQgaW4gb3B0aW1hbCBsaW5ldXBcbiAgICBPYmplY3QudmFsdWVzKG9wdGltYWxMaW5ldXApLmZvckVhY2goKHBsYXllcnM6IGFueVtdKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwbGF5ZXJzKSkge1xuICAgICAgICBwbGF5ZXJzLmZvckVhY2goKHA6IGFueSkgPT4ge1xuICAgICAgICAgIHVzZWRQbGF5ZXJzLmFkZChwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFJldHVybiBwbGF5ZXJzIG5vdCB1c2VkIGluIG9wdGltYWwgbGluZXVwXG4gICAgcmV0dXJuIHJvc3Rlci5maWx0ZXIoKHA6IGFueSkgPT4gIXVzZWRQbGF5ZXJzLmhhcyhwLnBsYXllcklkIHx8IHAucGxheWVyTmFtZSkpO1xuICB9XG5cbiAgY2FsY3VsYXRlVG90YWxQcm9qZWN0ZWRQb2ludHMocGxheWVyczogYW55W10gfCBSZWNvcmQ8c3RyaW5nLCBhbnlbXT4pOiBudW1iZXIge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBsYXllcnMpKSB7XG4gICAgICByZXR1cm4gcGxheWVycy5yZWR1Y2UoKHRvdGFsLCBwbGF5ZXIpID0+IHRvdGFsICsgKHBsYXllci5wcm9qZWN0ZWRQb2ludHMgfHwgMCksIDApO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgb2JqZWN0IGZvcm1hdFxuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgT2JqZWN0LnZhbHVlcyhwbGF5ZXJzKS5mb3JFYWNoKChwb3NpdGlvblBsYXllcnM6IGFueSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9zaXRpb25QbGF5ZXJzKSkge1xuICAgICAgICB0b3RhbCArPSBwb3NpdGlvblBsYXllcnMucmVkdWNlKChzdW06IG51bWJlciwgcDogYW55KSA9PiBzdW0gKyAocC5wcm9qZWN0ZWRQb2ludHMgfHwgMCksIDApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGFuYWx5emVMaW5ldXAob3B0aW1hbExpbmV1cDogUmVjb3JkPHN0cmluZywgYW55W10+LCBzZXR0aW5nczogTGVhZ3VlU2V0dGluZ3MgPSB7fSkge1xuICAgIGNvbnN0IGxlYWd1ZVR5cGUgPSBzZXR0aW5ncy5sZWFndWVUeXBlIHx8ICdzdGFuZGFyZCc7XG4gICAgY29uc3Qgc3VwZXJmbGV4U2xvdHMgPSBzZXR0aW5ncy5zdXBlcmZsZXhTbG90cyB8fCAwO1xuICAgIGNvbnN0IGFjdHVhbFRlYW1zID0gc2V0dGluZ3MudGVhbXMgfHwgMTI7XG4gICAgY29uc3QgYWN0dWFsUm91bmRzID0gMTY7IC8vIERlZmF1bHQgdG8gMTYgcm91bmRzIGZvciBkeW5hbWljIGNhbGN1bGF0aW9uXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gdGhpcy5nZXRSb3N0ZXJSZXF1aXJlbWVudHMobGVhZ3VlVHlwZSwgYWN0dWFsVGVhbXMsIGFjdHVhbFJvdW5kcyk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsU3RhcnRlcnM6IHJlcXVpcmVtZW50cy50b3RhbFN0YXJ0ZXJzLFxuICAgICAgbGVhZ3VlVHlwZSxcbiAgICAgIHN1cGVyZmxleFNsb3RzOiByZXF1aXJlbWVudHMuc3VwZXJmbGV4UG9zaXRpb25zID8gcmVxdWlyZW1lbnRzLnN1cGVyZmxleFBvc2l0aW9ucy5sZW5ndGggOiAwLFxuICAgICAgcmVxdWlyZW1lbnRzLFxuICAgICAgcG9zaXRpb25Db3VudHM6IE9iamVjdC5lbnRyaWVzKHJlcXVpcmVtZW50cylcbiAgICAgICAgLmZpbHRlcigoW2tleV0pID0+ICFbJ3RvdGFsU3RhcnRlcnMnLCAnZmxleFBvc2l0aW9ucycsICdzdXBlcmZsZXhQb3NpdGlvbnMnXS5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAucmVkdWNlKChhY2MsIFtwb3MsIGNvdW50XSkgPT4gKHsgLi4uYWNjLCBbcG9zXTogY291bnQgfSksIHt9KVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgcmVwbGFjZW1lbnQgYmFzZWxpbmVzIGZvciBWT1JQIGNhbGN1bGF0aW9uc1xuICBjYWxjdWxhdGVSZXBsYWNlbWVudEJhc2VsaW5lcyhzZXR0aW5nczogTGVhZ3VlU2V0dGluZ3MgPSB7fSkge1xuICAgIGNvbnN0IGxlYWd1ZVR5cGUgPSBzZXR0aW5ncy5sZWFndWVUeXBlIHx8ICdzdGFuZGFyZCc7XG4gICAgY29uc3Qgc3VwZXJmbGV4U2xvdHMgPSBzZXR0aW5ncy5zdXBlcmZsZXhTbG90cyB8fCAwO1xuICAgIGNvbnN0IGFjdHVhbFRlYW1zID0gc2V0dGluZ3MudGVhbXMgfHwgMTI7XG4gICAgY29uc3QgYWN0dWFsUm91bmRzID0gMTY7IC8vIERlZmF1bHQgdG8gMTYgcm91bmRzIGZvciBkeW5hbWljIGNhbGN1bGF0aW9uXG4gICAgXG4gICAgY29uc3QgYmFzZWxpbmVzID0ge1xuICAgICAgUUI6IGFjdHVhbFRlYW1zICogKDEgKyBzdXBlcmZsZXhTbG90cyksIC8vIFFCIGRlbWFuZCBpbmNyZWFzZXMgd2l0aCBzdXBlcmZsZXggc2xvdHNcbiAgICAgIFJCOiBhY3R1YWxUZWFtcyAqIDIsIC8vIFN0YW5kYXJkIFJCIGRlbWFuZFxuICAgICAgV1I6IGFjdHVhbFRlYW1zICogMiwgLy8gU3RhbmRhcmQgV1IgZGVtYW5kICBcbiAgICAgIFRFOiBhY3R1YWxUZWFtcyAqIDEsIC8vIFN0YW5kYXJkIFRFIGRlbWFuZFxuICAgICAgSzogYWN0dWFsVGVhbXMgKiAxLFxuICAgICAgREVGOiBhY3R1YWxUZWFtcyAqIDFcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBiYXNlbGluZXM7XG4gIH1cbn0gIl0sIm5hbWVzIjpbIk9wdGltYWxMaW5ldXBFbmdpbmUiLCJnZXRSb3N0ZXJSZXF1aXJlbWVudHMiLCJsZWFndWVUeXBlIiwiYWN0dWFsVGVhbXMiLCJhY3R1YWxSb3VuZHMiLCJiYXNlUmVxdWlyZW1lbnRzIiwic3RhbmRhcmQiLCJRQiIsIlJCIiwiV1IiLCJURSIsIkZMRVgiLCJERUYiLCJLIiwiZmxleFBvc2l0aW9ucyIsInN1cGVyZmxleFBvc2l0aW9ucyIsInN1cGVyZmxleCIsInJlcXVpcmVtZW50cyIsInRvdGFsU3RhcnRlcnMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyIiwia2V5IiwiaW5jbHVkZXMiLCJyZWR1Y2UiLCJzdW0iLCJfIiwiY291bnQiLCJfbWV0YWRhdGEiLCJjYWxjdWxhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjYWxjdWxhdGVPcHRpbWFsTGluZXVwIiwicm9zdGVyIiwic2V0dGluZ3MiLCJ0ZWFtcyIsInJvdW5kcyIsImNvbnNvbGUiLCJsb2ciLCJwb3NpdGlvbkdyb3VwcyIsImdyb3VwUGxheWVyc0J5UG9zaXRpb24iLCJvcHRpbWFsTGluZXVwIiwidXNlZFBsYXllcnMiLCJTZXQiLCJmb3JFYWNoIiwicG9zaXRpb24iLCJhdmFpbGFibGVQbGF5ZXJzIiwic29ydGVkUGxheWVycyIsInAiLCJoYXMiLCJwbGF5ZXJJZCIsInBsYXllck5hbWUiLCJzb3J0IiwiYSIsImIiLCJwcm9qZWN0ZWRQb2ludHMiLCJzbGljZSIsImFkZCIsImZsZXhQbGF5ZXJzIiwiZmxhdE1hcCIsInBvcyIsImxlbmd0aCIsImJlc3RGbGV4UGxheWVyIiwiYmVzdEZsZXhQbGF5ZXIxIiwiZmluZEJlc3RGbGV4UGxheWVyIiwicHVzaCIsImJlc3RGbGV4UGxheWVyMiIsImZpbmRCZXN0U3VwZXJmbGV4UGxheWVyIiwiYXZhaWxhYmxlUUJzIiwiYXZhaWxhYmxlUkJzIiwiYXZhaWxhYmxlV1JzIiwiYXZhaWxhYmxlVEVzIiwiYmVzdFN1cGVyZmxleFBsYXllciIsImJlc3RRQiIsIm90aGVyUGxheWVycyIsImJlc3RSQiIsImdyb3VwcyIsInBsYXllciIsInRvVXBwZXJDYXNlIiwiZ2V0QmVuY2hQbGF5ZXJzIiwidmFsdWVzIiwicGxheWVycyIsIkFycmF5IiwiaXNBcnJheSIsImNhbGN1bGF0ZVRvdGFsUHJvamVjdGVkUG9pbnRzIiwidG90YWwiLCJwb3NpdGlvblBsYXllcnMiLCJhbmFseXplTGluZXVwIiwic3VwZXJmbGV4U2xvdHMiLCJwb3NpdGlvbkNvdW50cyIsImFjYyIsImNhbGN1bGF0ZVJlcGxhY2VtZW50QmFzZWxpbmVzIiwiYmFzZWxpbmVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/lib/optimal-lineup-engine.ts\n");

/***/ }),

/***/ "(rsc)/./app/lib/position-grade-engine.ts":
/*!******************************************!*\
  !*** ./app/lib/position-grade-engine.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PositionGradeEngine)\n/* harmony export */ });\nclass PositionGradeEngine {\n    constructor(vorpArray = []){\n        this.vorpLookup = {};\n        this.leagueAverages = {};\n        this.leagueStdDevs = {};\n        vorpArray.forEach((p)=>{\n            const name = (p.playerName || \"\").toLowerCase();\n            const val = p.vorpScore ?? p.vorp_score ?? 0;\n            if (name) this.vorpLookup[name] = Number(val);\n        });\n    }\n    calculatePositionGrades(teams, settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const actualTeams = settings.teams || 12;\n        const actualRounds = settings.rounds || 16;\n        // Get dynamic position requirements based on actual draft data\n        const positionRequirements = this.getPositionRequirements(leagueType, actualTeams, actualRounds);\n        console.log(\"\\uD83D\\uDCCA Position grade calculation:\", {\n            leagueType,\n            actualTeams,\n            actualRounds,\n            positionRequirements: {\n                ...positionRequirements,\n                _metadata: positionRequirements._metadata\n            }\n        });\n        const teamsWithPositionGrades = teams.map((team)=>{\n            const rosterConstructionGrade = this.analyzeRosterConstruction(team, positionRequirements, leagueType);\n            return {\n                ...team,\n                positionGrades: rosterConstructionGrade\n            };\n        });\n        // Calculate overall team grades based on roster construction quality\n        const teamsWithOverallGrades = teamsWithPositionGrades.map((team)=>{\n            const overallGrade = this.calculateOverallRosterGrade(team.positionGrades);\n            return {\n                ...team,\n                overallGrade\n            };\n        });\n        return teamsWithOverallGrades;\n    }\n    analyzeRosterConstruction(team, requirements, leagueType) {\n        const analysis = {\n            positionalBalance: this.analyzePositionalBalance(team, requirements, leagueType),\n            depthStrategy: this.analyzeDepthStrategy(team, requirements),\n            startingLineupStrength: this.analyzeStartingLineupStrength(team, requirements),\n            adpValue: this.analyzeADPValue(team),\n            keeperValue: this.analyzeKeeperValue(team),\n            overallScore: 0,\n            grade: \"F\"\n        };\n        // Calculate overall score (weighted average)\n        const weights = {\n            positionalBalance: 0.30,\n            depthStrategy: 0.25,\n            startingLineupStrength: 0.25,\n            adpValue: 0.15,\n            keeperValue: 0.05 // Keeper advantage (if applicable)\n        };\n        analysis.overallScore = analysis.positionalBalance.score * weights.positionalBalance + analysis.depthStrategy.score * weights.depthStrategy + analysis.startingLineupStrength.score * weights.startingLineupStrength + analysis.adpValue.score * weights.adpValue + analysis.keeperValue.score * weights.keeperValue;\n        analysis.grade = this.scoreToGrade(analysis.overallScore);\n        return analysis;\n    }\n    analyzePositionalBalance(team, requirements, leagueType) {\n        const roster = team.roster || [];\n        const positionCounts = {};\n        const positionValues = {};\n        // Count players and collect projected points by position\n        roster.forEach((player)=>{\n            const pos = player.position || \"UNK\";\n            if (!positionCounts[pos]) {\n                positionCounts[pos] = 0;\n                positionValues[pos] = [];\n            }\n            positionCounts[pos]++;\n            positionValues[pos].push(player.projectedPoints || 0);\n        });\n        let balanceScore = 100;\n        let issues = [];\n        // Analyze each position against requirements\n        Object.entries(requirements).forEach(([pos, required])=>{\n            if ([\n                \"flexPositions\",\n                \"superflexPositions\",\n                \"totalStarters\",\n                \"_metadata\"\n            ].includes(pos)) return;\n            const actual = positionCounts[pos] || 0;\n            const requiredNum = required;\n            if (actual < requiredNum) {\n                // Position is underfilled\n                const deficit = requiredNum - actual;\n                balanceScore -= deficit * 15; // Major penalty for missing starters\n                issues.push(`${pos}: Missing ${deficit} starter(s)`);\n            } else if (actual > requiredNum + 2) {\n                // Position is overloaded (more than 2 extra)\n                const excess = actual - requiredNum - 2;\n                balanceScore -= excess * 8; // Penalty for overloading\n                issues.push(`${pos}: ${excess} too many players`);\n            }\n        });\n        // Check for critical position gaps\n        const criticalPositions = [\n            \"QB\",\n            \"RB\",\n            \"WR\",\n            \"TE\"\n        ];\n        criticalPositions.forEach((pos)=>{\n            if (!positionCounts[pos] || positionCounts[pos] === 0) {\n                balanceScore -= 25; // Critical penalty for missing entire position\n                issues.push(`${pos}: Position completely missing`);\n            }\n        });\n        // Special analysis for league types\n        if (leagueType === \"superflex\" && (!positionCounts[\"QB\"] || positionCounts[\"QB\"] < 2)) {\n            balanceScore -= 20; // Superflex needs QB depth\n            issues.push(\"Superflex: Insufficient QB depth\");\n        }\n        if (leagueType === \"2qb\" && (!positionCounts[\"QB\"] || positionCounts[\"QB\"] < 2)) {\n            balanceScore -= 30; // 2QB needs exactly 2 QBs\n            issues.push(\"2QB: Must have exactly 2 QBs\");\n        }\n        return {\n            score: Math.max(0, balanceScore),\n            issues,\n            positionCounts,\n            analysis: `Positional balance analysis: ${issues.length > 0 ? issues.join(\", \") : \"Well balanced\"}`\n        };\n    }\n    analyzeDepthStrategy(team, requirements) {\n        const roster = team.roster || [];\n        const starters = roster.slice(0, requirements.totalStarters || 9);\n        const bench = roster.slice(requirements.totalStarters || 9);\n        let depthScore = 100;\n        let analysis = [];\n        // Analyze bench quality\n        if (bench.length === 0) {\n            depthScore -= 30;\n            analysis.push(\"No bench players\");\n        } else {\n            // Check if bench has viable starters for bye weeks\n            const benchQuality = bench.map((p)=>p.projectedPoints || 0);\n            const avgBenchPoints = benchQuality.reduce((sum, pts)=>sum + pts, 0) / benchQuality.length;\n            if (avgBenchPoints < 80) {\n                depthScore -= 15;\n                analysis.push(\"Weak bench quality\");\n            } else if (avgBenchPoints > 120) {\n                depthScore += 10; // Bonus for strong bench\n                analysis.push(\"Strong bench quality\");\n            }\n            // Check position diversity on bench\n            const benchPositions = [\n                ...new Set(bench.map((p)=>p.position))\n            ];\n            if (benchPositions.length < 3) {\n                depthScore -= 10;\n                analysis.push(\"Limited bench position diversity\");\n            }\n        }\n        // Check for injury risk (players with low projected points as starters)\n        const weakStarters = starters.filter((p)=>(p.projectedPoints || 0) < 60);\n        if (weakStarters.length > 2) {\n            depthScore -= 20;\n            analysis.push(`${weakStarters.length} weak starters`);\n        }\n        return {\n            score: Math.max(0, depthScore),\n            analysis: analysis.length > 0 ? analysis.join(\", \") : \"Good depth strategy\",\n            benchSize: bench.length,\n            avgBenchPoints: bench.length > 0 ? bench.map((p)=>p.projectedPoints || 0).reduce((sum, pts)=>sum + pts, 0) / bench.length : 0\n        };\n    }\n    analyzeStartingLineupStrength(team, requirements) {\n        const roster = team.roster || [];\n        const starters = roster.slice(0, requirements.totalStarters || 9);\n        const bench = roster.slice(requirements.totalStarters || 9);\n        let strengthScore = 100;\n        let analysis = [];\n        // Calculate average projected points for starters\n        const avgStarterPoints = starters.map((p)=>p.projectedPoints || 0).reduce((sum, pts)=>sum + pts, 0) / starters.length;\n        // Check if starters are strong (e.g., average > 100)\n        if (avgStarterPoints < 100) {\n            strengthScore -= 20;\n            analysis.push(`Average starter points (${avgStarterPoints.toFixed(0)}) is below 100`);\n        }\n        // Check if starters are weak (e.g., average < 80)\n        if (avgStarterPoints > 120) {\n            strengthScore += 10;\n            analysis.push(`Average starter points (${avgStarterPoints.toFixed(0)}) is above 120`);\n        }\n        // Check for injury risk (players with low projected points as starters)\n        const weakStarters = starters.filter((p)=>(p.projectedPoints || 0) < 60);\n        if (weakStarters.length > 2) {\n            strengthScore -= 20;\n            analysis.push(`${weakStarters.length} weak starters`);\n        }\n        return {\n            score: Math.max(0, strengthScore),\n            analysis: analysis.length > 0 ? analysis.join(\", \") : \"Strong starting lineup\",\n            avgStarterPoints: starters.length > 0 ? starters.map((p)=>p.projectedPoints || 0).reduce((sum, pts)=>sum + pts, 0) / starters.length : 0\n        };\n    }\n    analyzeADPValue(team) {\n        const roster = team.roster || [];\n        let adpScore = 100;\n        let steals = [];\n        let reaches = [];\n        let analysis = [];\n        roster.forEach((player)=>{\n            const adp = player.adpValue || 0;\n            const round = player.round || 0;\n            const projectedPoints = player.projectedPoints || 0;\n            if (adp > 0 && round > 0) {\n                const adpRound = Math.ceil(adp / 12); // Convert ADP to approximate round\n                const roundDiff = adpRound - round;\n                if (roundDiff > 2) {\n                    // Player drafted much earlier than ADP (reach)\n                    adpScore -= 8;\n                    reaches.push(`${player.playerName} (Round ${round}, ADP ~${adpRound})`);\n                } else if (roundDiff < -2) {\n                    // Player drafted much later than ADP (steal)\n                    adpScore += 5;\n                    steals.push(`${player.playerName} (Round ${round}, ADP ~${adpRound})`);\n                }\n            }\n        });\n        // Bonus for overall draft value\n        if (steals.length > reaches.length) {\n            adpScore += 10;\n            analysis.push(`More steals (${steals.length}) than reaches (${reaches.length})`);\n        } else if (reaches.length > steals.length) {\n            adpScore -= 10;\n            analysis.push(`More reaches (${reaches.length}) than steals (${steals.length})`);\n        }\n        return {\n            score: Math.max(0, Math.min(100, adpScore)),\n            steals,\n            reaches,\n            analysis: analysis.length > 0 ? analysis.join(\", \") : \"Balanced ADP strategy\",\n            stealCount: steals.length,\n            reachCount: reaches.length\n        };\n    }\n    analyzeKeeperValue(team) {\n        // For now, assume no keepers - this can be enhanced later\n        // Keeper analysis would look at:\n        // - How many keepers they have\n        // - What round value those keepers represent\n        // - How much of an advantage they provide\n        return {\n            score: 100,\n            analysis: \"No keeper analysis available\",\n            keepers: [],\n            keeperAdvantage: 0\n        };\n    }\n    calculateOverallRosterGrade(positionGrades) {\n        const score = positionGrades.overallScore;\n        return {\n            score: Math.round(score * 100) / 100,\n            grade: positionGrades.grade,\n            summary: this.generateRosterSummary(positionGrades),\n            breakdown: {\n                positionalBalance: positionGrades.positionalBalance,\n                depthStrategy: positionGrades.depthStrategy,\n                adpValue: positionGrades.adpValue,\n                keeperValue: positionGrades.keeperValue\n            }\n        };\n    }\n    generateRosterSummary(positionGrades) {\n        const { positionalBalance, depthStrategy, startingLineupStrength, adpValue } = positionGrades;\n        let summary = `Overall Roster Grade: ${positionGrades.grade} (${Math.round(positionGrades.overallScore * 100) / 100}/100)\\n\\n`;\n        // Positional Balance Summary\n        summary += `Positional Balance: ${positionalBalance.score}/100\\n`;\n        if (positionalBalance.issues.length > 0) {\n            summary += `Issues: ${positionalBalance.issues.join(\", \")}\\n`;\n        }\n        // Starting Lineup Strength Summary\n        summary += `\\nStarting Lineup Strength: ${startingLineupStrength.score}/100\\n`;\n        summary += `Average Starter Points: ${startingLineupStrength.avgStarterPoints.toFixed(1)}\\n`;\n        summary += `Analysis: ${startingLineupStrength.analysis}\\n`;\n        // Depth Strategy Summary\n        summary += `\\nDepth Strategy: ${depthStrategy.score}/100\\n`;\n        summary += `Bench Size: ${depthStrategy.benchSize} players\\n`;\n        summary += `Analysis: ${depthStrategy.analysis}\\n`;\n        // ADP Value Summary\n        summary += `\\nDraft Value: ${adpValue.score}/100\\n`;\n        summary += `Steals: ${adpValue.stealCount}, Reaches: ${adpValue.reachCount}\\n`;\n        summary += `Analysis: ${adpValue.analysis}`;\n        return summary;\n    }\n    scoreToGrade(score) {\n        if (score >= 90) return \"A+\";\n        if (score >= 85) return \"A\";\n        if (score >= 80) return \"A-\";\n        if (score >= 75) return \"B+\";\n        if (score >= 70) return \"B\";\n        if (score >= 65) return \"B-\";\n        if (score >= 60) return \"C+\";\n        if (score >= 55) return \"C\";\n        if (score >= 50) return \"C-\";\n        if (score >= 45) return \"D+\";\n        if (score >= 40) return \"D\";\n        if (score >= 35) return \"D-\";\n        return \"F\";\n    }\n    calculateLeagueStats(teams, positionRequirements) {\n        const positionStats = {};\n        // Initialize position stats\n        positionRequirements.forEach((pos)=>{\n            positionStats[pos] = {\n                points: [],\n                vorp: []\n            };\n        });\n        // Collect all player stats across teams\n        teams.forEach((team)=>{\n            (team.roster || []).forEach((player)=>{\n                const pos = (player.position || \"\").toUpperCase();\n                if (!pos || !positionStats[pos]) return;\n                const points = player.projectedPoints || 0;\n                const vorp = this.getPlayerVorp(player.playerName || player.name || \"\");\n                positionStats[pos].points.push(points);\n                positionStats[pos].vorp.push(vorp);\n            });\n        });\n        // Calculate averages and standard deviations\n        Object.keys(positionStats).forEach((pos)=>{\n            const points = positionStats[pos].points.filter((p)=>p > 0);\n            const vorp = positionStats[pos].vorp.filter((v)=>v !== 0);\n            if (points.length > 0) {\n                this.leagueAverages[pos] = points.reduce((sum, p)=>sum + p, 0) / points.length;\n                this.leagueStdDevs[pos] = this.calculateStdDev(points, this.leagueAverages[pos]);\n            }\n            if (vorp.length > 0) {\n                this.leagueAverages[`${pos}_VORP`] = vorp.reduce((sum, v)=>sum + v, 0) / vorp.length;\n                this.leagueStdDevs[`${pos}_VORP`] = this.calculateStdDev(vorp, this.leagueAverages[`${pos}_VORP`]);\n            }\n        });\n    }\n    calculateStdDev(values, mean) {\n        if (values.length <= 1) return 0;\n        const variance = values.reduce((sum, val)=>sum + Math.pow(val - mean, 2), 0) / values.length;\n        return Math.sqrt(variance);\n    }\n    getPlayerVorp(playerName) {\n        if (!playerName) return 0;\n        const normalizedName = playerName.toLowerCase();\n        return this.vorpLookup[normalizedName] || 0;\n    }\n    getPositionRequirements(leagueType = \"standard\", actualTeams = 12, actualRounds = 16) {\n        // Fixed starter requirements - bench size scales with rounds, not starters\n        const baseRequirements = {\n            standard: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            superflex: {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"QB\",\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2qb\": {\n                QB: 2,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 1,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"2flex\": {\n                QB: 1,\n                RB: 2,\n                WR: 2,\n                TE: 1,\n                FLEX: 2,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            },\n            \"robs-bullshit\": {\n                QB: 2,\n                RB: 2,\n                WR: 3,\n                TE: 1,\n                FLEX: 2,\n                DEF: 1,\n                K: 1,\n                flexPositions: [\n                    \"RB\",\n                    \"WR\",\n                    \"TE\"\n                ],\n                superflexPositions: []\n            }\n        };\n        const requirements = baseRequirements[leagueType] || baseRequirements.standard;\n        // Calculate total starters (fixed, doesn't change with rounds)\n        const totalStarters = Object.entries(requirements).filter(([key])=>![\n                \"flexPositions\",\n                \"superflexPositions\"\n            ].includes(key)).reduce((sum, [_, count])=>sum + (typeof count === \"number\" ? count : 0), 0);\n        return {\n            ...requirements,\n            totalStarters,\n            _metadata: {\n                actualTeams,\n                actualRounds,\n                leagueType,\n                calculatedAt: new Date().toISOString()\n            }\n        };\n    }\n    // Calculate replacement baselines for VORP calculations\n    calculateReplacementBaselines(settings = {}) {\n        const leagueType = settings.leagueType || \"standard\";\n        const superflexSlots = settings.superflexSlots || 0;\n        const teams = settings.teams || 12;\n        const baselines = {\n            QB: teams * (1 + superflexSlots),\n            RB: teams * 2,\n            WR: teams * 2,\n            TE: teams * 1,\n            K: teams * 1,\n            DEF: teams * 1\n        };\n        return baselines;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvbGliL3Bvc2l0aW9uLWdyYWRlLWVuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBUWUsTUFBTUE7SUFLbkJDLFlBQVlDLFlBQXFGLEVBQUUsQ0FBRTthQUo3RkMsYUFBcUMsQ0FBQzthQUN0Q0MsaUJBQXlDLENBQUM7YUFDMUNDLGdCQUF3QyxDQUFDO1FBRy9DSCxVQUFVSSxPQUFPLENBQUMsQ0FBQ0M7WUFDakIsTUFBTUMsT0FBTyxDQUFDRCxFQUFFRSxVQUFVLElBQUksRUFBQyxFQUFHQyxXQUFXO1lBQzdDLE1BQU1DLE1BQU0sRUFBV0MsU0FBUyxJQUFJTCxFQUFFTSxVQUFVLElBQUk7WUFDcEQsSUFBSUwsTUFBTSxJQUFJLENBQUNMLFVBQVUsQ0FBQ0ssS0FBSyxHQUFHTSxPQUFPSDtRQUMzQztJQUNGO0lBRUFJLHdCQUF3QkMsS0FBWSxFQUFFQyxXQUEyQixDQUFDLENBQUMsRUFBRTtRQUNuRSxNQUFNQyxhQUFhRCxTQUFTQyxVQUFVLElBQUk7UUFDMUMsTUFBTUMsY0FBY0YsU0FBU0QsS0FBSyxJQUFJO1FBQ3RDLE1BQU1JLGVBQWVILFNBQVNJLE1BQU0sSUFBSTtRQUV4QywrREFBK0Q7UUFDL0QsTUFBTUMsdUJBQXVCLElBQUksQ0FBQ0MsdUJBQXVCLENBQUNMLFlBQVlDLGFBQWFDO1FBRW5GSSxRQUFRQyxHQUFHLENBQUMsNENBQWtDO1lBQzVDUDtZQUNBQztZQUNBQztZQUNBRSxzQkFBc0I7Z0JBQ3BCLEdBQUdBLG9CQUFvQjtnQkFDdkJJLFdBQVdKLHFCQUFxQkksU0FBUztZQUMzQztRQUNGO1FBRUEsTUFBTUMsMEJBQTBCWCxNQUFNWSxHQUFHLENBQUNDLENBQUFBO1lBQ3hDLE1BQU1DLDBCQUEwQixJQUFJLENBQUNDLHlCQUF5QixDQUFDRixNQUFNUCxzQkFBc0JKO1lBQzNGLE9BQU87Z0JBQ0wsR0FBR1csSUFBSTtnQkFDUEcsZ0JBQWdCRjtZQUNsQjtRQUNGO1FBRUEscUVBQXFFO1FBQ3JFLE1BQU1HLHlCQUF5Qk4sd0JB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QkFBTTtvQkFBTTtpQkFBSztnQkFDakNDLG9CQUFvQixFQUFFO1lBQ3hCO1FBQ0Y7UUFFQSxNQUFNbkcsZUFBZXlGLGdCQUFnQixDQUFDM0csV0FBNEMsSUFBSTJHLGlCQUFpQkMsUUFBUTtRQUUvRywrREFBK0Q7UUFDL0QsTUFBTWhELGdCQUFnQmYsT0FBT0MsT0FBTyxDQUFDNUIsY0FDbENxRCxNQUFNLENBQUMsQ0FBQyxDQUFDZ0QsSUFBSSxHQUFLLENBQUM7Z0JBQUM7Z0JBQWlCO2FBQXFCLENBQUN2RSxRQUFRLENBQUN1RSxNQUNwRXRELE1BQU0sQ0FBQyxDQUFDQyxLQUFLLENBQUNzRCxHQUFHQyxNQUFNLEdBQUt2RCxNQUFPLFFBQU91RCxVQUFVLFdBQVdBLFFBQVEsSUFBSTtRQUU5RSxPQUFPO1lBQ0wsR0FBR3ZHLFlBQVk7WUFDZjBDO1lBQ0FwRCxXQUFXO2dCQUNUUDtnQkFDQUM7Z0JBQ0FGO2dCQUNBMEgsY0FBYyxJQUFJQyxPQUFPQyxXQUFXO1lBQ3RDO1FBQ0Y7SUFDRjtJQUVBLHdEQUF3RDtJQUN4REMsOEJBQThCOUgsV0FBMkIsQ0FBQyxDQUFDLEVBQUU7UUFDM0QsTUFBTUMsYUFBYUQsU0FBU0MsVUFBVSxJQUFJO1FBQzFDLE1BQU04SCxpQkFBaUIvSCxTQUFTK0gsY0FBYyxJQUFJO1FBQ2xELE1BQU1oSSxRQUFRQyxTQUFTRCxLQUFLLElBQUk7UUFFaEMsTUFBTWlJLFlBQVk7WUFDaEJsQixJQUFJL0csUUFBUyxLQUFJZ0ksY0FBYTtZQUM5QmhCLElBQUloSCxRQUFRO1lBQ1ppSCxJQUFJakgsUUFBUTtZQUNaa0gsSUFBSWxILFFBQVE7WUFDWnFILEdBQUdySCxRQUFRO1lBQ1hvSCxLQUFLcEgsUUFBUTtRQUNmO1FBRUEsT0FBT2lJO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2ZmX2FwaV9za2VsZXRvbi8uL2FwcC9saWIvcG9zaXRpb24tZ3JhZGUtZW5naW5lLnRzPzJhYjEiXSwic291cmNlc0NvbnRlbnQiOlsidHlwZSBMZWFndWVTZXR0aW5ncyA9IHtcbiAgc2NvcmluZz86IHN0cmluZztcbiAgbGVhZ3VlVHlwZT86IHN0cmluZztcbiAgc3VwZXJmbGV4U2xvdHM/OiBudW1iZXI7XG4gIHRlYW1zPzogbnVtYmVyO1xuICByb3VuZHM/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbkdyYWRlRW5naW5lIHtcbiAgcHJpdmF0ZSB2b3JwTG9va3VwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gIHByaXZhdGUgbGVhZ3VlQXZlcmFnZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgcHJpdmF0ZSBsZWFndWVTdGREZXZzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG5cbiAgY29uc3RydWN0b3Iodm9ycEFycmF5OiBBcnJheTx7IHBsYXllck5hbWU/OiBzdHJpbmc7IHZvcnBfc2NvcmU/OiBudW1iZXI7IHZvcnBTY29yZT86IG51bWJlciB9PiA9IFtdKSB7XG4gICAgdm9ycEFycmF5LmZvckVhY2goKHApID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSAocC5wbGF5ZXJOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgdmFsID0gKHAgYXMgYW55KS52b3JwU2NvcmUgPz8gcC52b3JwX3Njb3JlID8/IDA7XG4gICAgICBpZiAobmFtZSkgdGhpcy52b3JwTG9va3VwW25hbWVdID0gTnVtYmVyKHZhbCk7XG4gICAgfSk7XG4gIH1cblxuICBjYWxjdWxhdGVQb3NpdGlvbkdyYWRlcyh0ZWFtczogYW55W10sIHNldHRpbmdzOiBMZWFndWVTZXR0aW5ncyA9IHt9KSB7XG4gICAgY29uc3QgbGVhZ3VlVHlwZSA9IHNldHRpbmdzLmxlYWd1ZVR5cGUgfHwgJ3N0YW5kYXJkJztcbiAgICBjb25zdCBhY3R1YWxUZWFtcyA9IHNldHRpbmdzLnRlYW1zIHx8IDEyO1xuICAgIGNvbnN0IGFjdHVhbFJvdW5kcyA9IHNldHRpbmdzLnJvdW5kcyB8fCAxNjtcbiAgICBcbiAgICAvLyBHZXQgZHluYW1pYyBwb3NpdGlvbiByZXF1aXJlbWVudHMgYmFzZWQgb24gYWN0dWFsIGRyYWZ0IGRhdGFcbiAgICBjb25zdCBwb3NpdGlvblJlcXVpcmVtZW50cyA9IHRoaXMuZ2V0UG9zaXRpb25SZXF1aXJlbWVudHMobGVhZ3VlVHlwZSwgYWN0dWFsVGVhbXMsIGFjdHVhbFJvdW5kcyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ/Cfk4ogUG9zaXRpb24gZ3JhZGUgY2FsY3VsYXRpb246Jywge1xuICAgICAgbGVhZ3VlVHlwZSxcbiAgICAgIGFjdHVhbFRlYW1zLFxuICAgICAgYWN0dWFsUm91bmRzLFxuICAgICAgcG9zaXRpb25SZXF1aXJlbWVudHM6IHtcbiAgICAgICAgLi4ucG9zaXRpb25SZXF1aXJlbWVudHMsXG4gICAgICAgIF9tZXRhZGF0YTogcG9zaXRpb25SZXF1aXJlbWVudHMuX21ldGFkYXRhXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB0ZWFtc1dpdGhQb3NpdGlvbkdyYWRlcyA9IHRlYW1zLm1hcCh0ZWFtID0+IHtcbiAgICAgIGNvbnN0IHJvc3RlckNvbnN0cnVjdGlvbkdyYWRlID0gdGhpcy5hbmFseXplUm9zdGVyQ29uc3RydWN0aW9uKHRlYW0sIHBvc2l0aW9uUmVxdWlyZW1lbnRzLCBsZWFndWVUeXBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRlYW0sXG4gICAgICAgIHBvc2l0aW9uR3JhZGVzOiByb3N0ZXJDb25zdHJ1Y3Rpb25HcmFkZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIENhbGN1bGF0ZSBvdmVyYWxsIHRlYW0gZ3JhZGVzIGJhc2VkIG9uIHJvc3RlciBjb25zdHJ1Y3Rpb24gcXVhbGl0eVxuICAgIGNvbnN0IHRlYW1zV2l0aE92ZXJhbGxHcmFkZXMgPSB0ZWFtc1dpdGhQb3NpdGlvbkdyYWRlcy5tYXAodGVhbSA9PiB7XG4gICAgICBjb25zdCBvdmVyYWxsR3JhZGUgPSB0aGlzLmNhbGN1bGF0ZU92ZXJhbGxSb3N0ZXJHcmFkZSh0ZWFtLnBvc2l0aW9uR3JhZGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRlYW0sXG4gICAgICAgIG92ZXJhbGxHcmFkZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0ZWFtc1dpdGhPdmVyYWxsR3JhZGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBhbmFseXplUm9zdGVyQ29uc3RydWN0aW9uKHRlYW06IGFueSwgcmVxdWlyZW1lbnRzOiBhbnksIGxlYWd1ZVR5cGU6IHN0cmluZykge1xuICAgIGNvbnN0IGFuYWx5c2lzID0ge1xuICAgICAgcG9zaXRpb25hbEJhbGFuY2U6IHRoaXMuYW5hbHl6ZVBvc2l0aW9uYWxCYWxhbmNlKHRlYW0sIHJlcXVpcmVtZW50cywgbGVhZ3VlVHlwZSksXG4gICAgICBkZXB0aFN0cmF0ZWd5OiB0aGlzLmFuYWx5emVEZXB0aFN0cmF0ZWd5KHRlYW0sIHJlcXVpcmVtZW50cyksXG4gICAgICBzdGFydGluZ0xpbmV1cFN0cmVuZ3RoOiB0aGlzLmFuYWx5emVTdGFydGluZ0xpbmV1cFN0cmVuZ3RoKHRlYW0sIHJlcXVpcmVtZW50cyksXG4gICAgICBhZHBWYWx1ZTogdGhpcy5hbmFseXplQURQVmFsdWUodGVhbSksXG4gICAgICBrZWVwZXJWYWx1ZTogdGhpcy5hbmFseXplS2VlcGVyVmFsdWUodGVhbSksXG4gICAgICBvdmVyYWxsU2NvcmU6IDAsXG4gICAgICBncmFkZTogJ0YnXG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSBvdmVyYWxsIHNjb3JlICh3ZWlnaHRlZCBhdmVyYWdlKVxuICAgIGNvbnN0IHdlaWdodHMgPSB7XG4gICAgICBwb3NpdGlvbmFsQmFsYW5jZTogMC4zMCwgICAgLy8gUm9zdGVyIGNvbnN0cnVjdGlvblxuICAgICAgZGVwdGhTdHJhdGVneTogMC4yNSwgICAgICAgICAvLyBEZXB0aCBhbmQgYmVuY2ggcXVhbGl0eVxuICAgICAgc3RhcnRpbmdMaW5ldXBTdHJlbmd0aDogMC4yNSwgLy8gU3RhcnRpbmcgbGluZXVwIHF1YWxpdHlcbiAgICAgIGFkcFZhbHVlOiAwLjE1LCAgICAgICAgICAgICAvLyBEcmFmdCB2YWx1ZSBhbmQgc3RlYWxzXG4gICAgICBrZWVwZXJWYWx1ZTogMC4wNSAgICAgICAgICAgIC8vIEtlZXBlciBhZHZhbnRhZ2UgKGlmIGFwcGxpY2FibGUpXG4gICAgfTtcblxuICAgIGFuYWx5c2lzLm92ZXJhbGxTY29yZSA9IFxuICAgICAgKGFuYWx5c2lzLnBvc2l0aW9uYWxCYWxhbmNlLnNjb3JlICogd2VpZ2h0cy5wb3NpdGlvbmFsQmFsYW5jZSkgK1xuICAgICAgKGFuYWx5c2lzLmRlcHRoU3RyYXRlZ3kuc2NvcmUgKiB3ZWlnaHRzLmRlcHRoU3RyYXRlZ3kpICtcbiAgICAgIChhbmFseXNpcy5zdGFydGluZ0xpbmV1cFN0cmVuZ3RoLnNjb3JlICogd2VpZ2h0cy5zdGFydGluZ0xpbmV1cFN0cmVuZ3RoKSArXG4gICAgICAoYW5hbHlzaXMuYWRwVmFsdWUuc2NvcmUgKiB3ZWlnaHRzLmFkcFZhbHVlKSArXG4gICAgICAoYW5hbHlzaXMua2VlcGVyVmFsdWUuc2NvcmUgKiB3ZWlnaHRzLmtlZXBlclZhbHVlKTtcblxuICAgIGFuYWx5c2lzLmdyYWRlID0gdGhpcy5zY29yZVRvR3JhZGUoYW5hbHlzaXMub3ZlcmFsbFNjb3JlKTtcbiAgICBcbiAgICByZXR1cm4gYW5hbHlzaXM7XG4gIH1cblxuICBwcml2YXRlIGFuYWx5emVQb3NpdGlvbmFsQmFsYW5jZSh0ZWFtOiBhbnksIHJlcXVpcmVtZW50czogYW55LCBsZWFndWVUeXBlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByb3N0ZXIgPSB0ZWFtLnJvc3RlciB8fCBbXTtcbiAgICBjb25zdCBwb3NpdGlvbkNvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIGNvbnN0IHBvc2l0aW9uVmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXJbXT4gPSB7fTtcbiAgICBcbiAgICAvLyBDb3VudCBwbGF5ZXJzIGFuZCBjb2xsZWN0IHByb2plY3RlZCBwb2ludHMgYnkgcG9zaXRpb25cbiAgICByb3N0ZXIuZm9yRWFjaCgocGxheWVyOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IHBsYXllci5wb3NpdGlvbiB8fCAnVU5LJztcbiAgICAgIGlmICghcG9zaXRpb25Db3VudHNbcG9zXSkge1xuICAgICAgICBwb3NpdGlvbkNvdW50c1twb3NdID0gMDtcbiAgICAgICAgcG9zaXRpb25WYWx1ZXNbcG9zXSA9IFtdO1xuICAgICAgfVxuICAgICAgcG9zaXRpb25Db3VudHNbcG9zXSsrO1xuICAgICAgcG9zaXRpb25WYWx1ZXNbcG9zXS5wdXNoKHBsYXllci5wcm9qZWN0ZWRQb2ludHMgfHwgMCk7XG4gICAgfSk7XG5cbiAgICBsZXQgYmFsYW5jZVNjb3JlID0gMTAwO1xuICAgIGxldCBpc3N1ZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBBbmFseXplIGVhY2ggcG9zaXRpb24gYWdhaW5zdCByZXF1aXJlbWVudHNcbiAgICBPYmplY3QuZW50cmllcyhyZXF1aXJlbWVudHMpLmZvckVhY2goKFtwb3MsIHJlcXVpcmVkXSkgPT4ge1xuICAgICAgaWYgKFsnZmxleFBvc2l0aW9ucycsICdzdXBlcmZsZXhQb3NpdGlvbnMnLCAndG90YWxTdGFydGVycycsICdfbWV0YWRhdGEnXS5pbmNsdWRlcyhwb3MpKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGFjdHVhbCA9IHBvc2l0aW9uQ291bnRzW3Bvc10gfHwgMDtcbiAgICAgIGNvbnN0IHJlcXVpcmVkTnVtID0gcmVxdWlyZWQgYXMgbnVtYmVyO1xuICAgICAgXG4gICAgICBpZiAoYWN0dWFsIDwgcmVxdWlyZWROdW0pIHtcbiAgICAgICAgLy8gUG9zaXRpb24gaXMgdW5kZXJmaWxsZWRcbiAgICAgICAgY29uc3QgZGVmaWNpdCA9IHJlcXVpcmVkTnVtIC0gYWN0dWFsO1xuICAgICAgICBiYWxhbmNlU2NvcmUgLT0gKGRlZmljaXQgKiAxNSk7IC8vIE1ham9yIHBlbmFsdHkgZm9yIG1pc3Npbmcgc3RhcnRlcnNcbiAgICAgICAgaXNzdWVzLnB1c2goYCR7cG9zfTogTWlzc2luZyAke2RlZmljaXR9IHN0YXJ0ZXIocylgKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0dWFsID4gcmVxdWlyZWROdW0gKyAyKSB7XG4gICAgICAgIC8vIFBvc2l0aW9uIGlzIG92ZXJsb2FkZWQgKG1vcmUgdGhhbiAyIGV4dHJhKVxuICAgICAgICBjb25zdCBleGNlc3MgPSBhY3R1YWwgLSByZXF1aXJlZE51bSAtIDI7XG4gICAgICAgIGJhbGFuY2VTY29yZSAtPSAoZXhjZXNzICogOCk7IC8vIFBlbmFsdHkgZm9yIG92ZXJsb2FkaW5nXG4gICAgICAgIGlzc3Vlcy5wdXNoKGAke3Bvc306ICR7ZXhjZXNzfSB0b28gbWFueSBwbGF5ZXJzYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBmb3IgY3JpdGljYWwgcG9zaXRpb24gZ2Fwc1xuICAgIGNvbnN0IGNyaXRpY2FsUG9zaXRpb25zID0gWydRQicsICdSQicsICdXUicsICdURSddO1xuICAgIGNyaXRpY2FsUG9zaXRpb25zLmZvckVhY2gocG9zID0+IHtcbiAgICAgIGlmICghcG9zaXRpb25Db3VudHNbcG9zXSB8fCBwb3NpdGlvbkNvdW50c1twb3NdID09PSAwKSB7XG4gICAgICAgIGJhbGFuY2VTY29yZSAtPSAyNTsgLy8gQ3JpdGljYWwgcGVuYWx0eSBmb3IgbWlzc2luZyBlbnRpcmUgcG9zaXRpb25cbiAgICAgICAgaXNzdWVzLnB1c2goYCR7cG9zfTogUG9zaXRpb24gY29tcGxldGVseSBtaXNzaW5nYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTcGVjaWFsIGFuYWx5c2lzIGZvciBsZWFndWUgdHlwZXNcbiAgICBpZiAobGVhZ3VlVHlwZSA9PT0gJ3N1cGVyZmxleCcgJiYgKCFwb3NpdGlvbkNvdW50c1snUUInXSB8fCBwb3NpdGlvbkNvdW50c1snUUInXSA8IDIpKSB7XG4gICAgICBiYWxhbmNlU2NvcmUgLT0gMjA7IC8vIFN1cGVyZmxleCBuZWVkcyBRQiBkZXB0aFxuICAgICAgaXNzdWVzLnB1c2goJ1N1cGVyZmxleDogSW5zdWZmaWNpZW50IFFCIGRlcHRoJyk7XG4gICAgfVxuXG4gICAgaWYgKGxlYWd1ZVR5cGUgPT09ICcycWInICYmICghcG9zaXRpb25Db3VudHNbJ1FCJ10gfHwgcG9zaXRpb25Db3VudHNbJ1FCJ10gPCAyKSkge1xuICAgICAgYmFsYW5jZVNjb3JlIC09IDMwOyAvLyAyUUIgbmVlZHMgZXhhY3RseSAyIFFCc1xuICAgICAgaXNzdWVzLnB1c2goJzJRQjogTXVzdCBoYXZlIGV4YWN0bHkgMiBRQnMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NvcmU6IE1hdGgubWF4KDAsIGJhbGFuY2VTY29yZSksXG4gICAgICBpc3N1ZXMsXG4gICAgICBwb3NpdGlvbkNvdW50cyxcbiAgICAgIGFuYWx5c2lzOiBgUG9zaXRpb25hbCBiYWxhbmNlIGFuYWx5c2lzOiAke2lzc3Vlcy5sZW5ndGggPiAwID8gaXNzdWVzLmpvaW4oJywgJykgOiAnV2VsbCBiYWxhbmNlZCd9YFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFuYWx5emVEZXB0aFN0cmF0ZWd5KHRlYW06IGFueSwgcmVxdWlyZW1lbnRzOiBhbnkpIHtcbiAgICBjb25zdCByb3N0ZXIgPSB0ZWFtLnJvc3RlciB8fCBbXTtcbiAgICBjb25zdCBzdGFydGVycyA9IHJvc3Rlci5zbGljZSgwLCByZXF1aXJlbWVudHMudG90YWxTdGFydGVycyB8fCA5KTtcbiAgICBjb25zdCBiZW5jaCA9IHJvc3Rlci5zbGljZShyZXF1aXJlbWVudHMudG90YWxTdGFydGVycyB8fCA5KTtcbiAgICBcbiAgICBsZXQgZGVwdGhTY29yZSA9IDEwMDtcbiAgICBsZXQgYW5hbHlzaXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAvLyBBbmFseXplIGJlbmNoIHF1YWxpdHlcbiAgICBpZiAoYmVuY2gubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZXB0aFNjb3JlIC09IDMwO1xuICAgICAgYW5hbHlzaXMucHVzaCgnTm8gYmVuY2ggcGxheWVycycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayBpZiBiZW5jaCBoYXMgdmlhYmxlIHN0YXJ0ZXJzIGZvciBieWUgd2Vla3NcbiAgICAgIGNvbnN0IGJlbmNoUXVhbGl0eSA9IGJlbmNoLm1hcCgocDogYW55KSA9PiBwLnByb2plY3RlZFBvaW50cyB8fCAwKTtcbiAgICAgIGNvbnN0IGF2Z0JlbmNoUG9pbnRzID0gYmVuY2hRdWFsaXR5LnJlZHVjZSgoc3VtOiBudW1iZXIsIHB0czogbnVtYmVyKSA9PiBzdW0gKyBwdHMsIDApIC8gYmVuY2hRdWFsaXR5Lmxlbmd0aDtcbiAgICAgIFxuICAgICAgaWYgKGF2Z0JlbmNoUG9pbnRzIDwgODApIHtcbiAgICAgICAgZGVwdGhTY29yZSAtPSAxNTtcbiAgICAgICAgYW5hbHlzaXMucHVzaCgnV2VhayBiZW5jaCBxdWFsaXR5Jyk7XG4gICAgICB9IGVsc2UgaWYgKGF2Z0JlbmNoUG9pbnRzID4gMTIwKSB7XG4gICAgICAgIGRlcHRoU2NvcmUgKz0gMTA7IC8vIEJvbnVzIGZvciBzdHJvbmcgYmVuY2hcbiAgICAgICAgYW5hbHlzaXMucHVzaCgnU3Ryb25nIGJlbmNoIHF1YWxpdHknKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgcG9zaXRpb24gZGl2ZXJzaXR5IG9uIGJlbmNoXG4gICAgICBjb25zdCBiZW5jaFBvc2l0aW9ucyA9IFsuLi5uZXcgU2V0KGJlbmNoLm1hcCgocDogYW55KSA9PiBwLnBvc2l0aW9uKSldO1xuICAgICAgaWYgKGJlbmNoUG9zaXRpb25zLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgZGVwdGhTY29yZSAtPSAxMDtcbiAgICAgICAgYW5hbHlzaXMucHVzaCgnTGltaXRlZCBiZW5jaCBwb3NpdGlvbiBkaXZlcnNpdHknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgaW5qdXJ5IHJpc2sgKHBsYXllcnMgd2l0aCBsb3cgcHJvamVjdGVkIHBvaW50cyBhcyBzdGFydGVycylcbiAgICBjb25zdCB3ZWFrU3RhcnRlcnMgPSBzdGFydGVycy5maWx0ZXIoKHA6IGFueSkgPT4gKHAucHJvamVjdGVkUG9pbnRzIHx8IDApIDwgNjApO1xuICAgIGlmICh3ZWFrU3RhcnRlcnMubGVuZ3RoID4gMikge1xuICAgICAgZGVwdGhTY29yZSAtPSAyMDtcbiAgICAgIGFuYWx5c2lzLnB1c2goYCR7d2Vha1N0YXJ0ZXJzLmxlbmd0aH0gd2VhayBzdGFydGVyc2ApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzY29yZTogTWF0aC5tYXgoMCwgZGVwdGhTY29yZSksXG4gICAgICBhbmFseXNpczogYW5hbHlzaXMubGVuZ3RoID4gMCA/IGFuYWx5c2lzLmpvaW4oJywgJykgOiAnR29vZCBkZXB0aCBzdHJhdGVneScsXG4gICAgICBiZW5jaFNpemU6IGJlbmNoLmxlbmd0aCxcbiAgICAgIGF2Z0JlbmNoUG9pbnRzOiBiZW5jaC5sZW5ndGggPiAwID8gYmVuY2gubWFwKChwOiBhbnkpID0+IHAucHJvamVjdGVkUG9pbnRzIHx8IDApLnJlZHVjZSgoc3VtOiBudW1iZXIsIHB0czogbnVtYmVyKSA9PiBzdW0gKyBwdHMsIDApIC8gYmVuY2gubGVuZ3RoIDogMFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFuYWx5emVTdGFydGluZ0xpbmV1cFN0cmVuZ3RoKHRlYW06IGFueSwgcmVxdWlyZW1lbnRzOiBhbnkpIHtcbiAgICBjb25zdCByb3N0ZXIgPSB0ZWFtLnJvc3RlciB8fCBbXTtcbiAgICBjb25zdCBzdGFydGVycyA9IHJvc3Rlci5zbGljZSgwLCByZXF1aXJlbWVudHMudG90YWxTdGFydGVycyB8fCA5KTtcbiAgICBjb25zdCBiZW5jaCA9IHJvc3Rlci5zbGljZShyZXF1aXJlbWVudHMudG90YWxTdGFydGVycyB8fCA5KTtcblxuICAgIGxldCBzdHJlbmd0aFNjb3JlID0gMTAwO1xuICAgIGxldCBhbmFseXNpczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHByb2plY3RlZCBwb2ludHMgZm9yIHN0YXJ0ZXJzXG4gICAgY29uc3QgYXZnU3RhcnRlclBvaW50cyA9IHN0YXJ0ZXJzLm1hcCgocDogYW55KSA9PiBwLnByb2plY3RlZFBvaW50cyB8fCAwKS5yZWR1Y2UoKHN1bTogbnVtYmVyLCBwdHM6IG51bWJlcikgPT4gc3VtICsgcHRzLCAwKSAvIHN0YXJ0ZXJzLmxlbmd0aDtcblxuICAgIC8vIENoZWNrIGlmIHN0YXJ0ZXJzIGFyZSBzdHJvbmcgKGUuZy4sIGF2ZXJhZ2UgPiAxMDApXG4gICAgaWYgKGF2Z1N0YXJ0ZXJQb2ludHMgPCAxMDApIHtcbiAgICAgIHN0cmVuZ3RoU2NvcmUgLT0gMjA7XG4gICAgICBhbmFseXNpcy5wdXNoKGBBdmVyYWdlIHN0YXJ0ZXIgcG9pbnRzICgke2F2Z1N0YXJ0ZXJQb2ludHMudG9GaXhlZCgwKX0pIGlzIGJlbG93IDEwMGApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHN0YXJ0ZXJzIGFyZSB3ZWFrIChlLmcuLCBhdmVyYWdlIDwgODApXG4gICAgaWYgKGF2Z1N0YXJ0ZXJQb2ludHMgPiAxMjApIHtcbiAgICAgIHN0cmVuZ3RoU2NvcmUgKz0gMTA7XG4gICAgICBhbmFseXNpcy5wdXNoKGBBdmVyYWdlIHN0YXJ0ZXIgcG9pbnRzICgke2F2Z1N0YXJ0ZXJQb2ludHMudG9GaXhlZCgwKX0pIGlzIGFib3ZlIDEyMGApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBpbmp1cnkgcmlzayAocGxheWVycyB3aXRoIGxvdyBwcm9qZWN0ZWQgcG9pbnRzIGFzIHN0YXJ0ZXJzKVxuICAgIGNvbnN0IHdlYWtTdGFydGVycyA9IHN0YXJ0ZXJzLmZpbHRlcigocDogYW55KSA9PiAocC5wcm9qZWN0ZWRQb2ludHMgfHwgMCkgPCA2MCk7XG4gICAgaWYgKHdlYWtTdGFydGVycy5sZW5ndGggPiAyKSB7XG4gICAgICBzdHJlbmd0aFNjb3JlIC09IDIwO1xuICAgICAgYW5hbHlzaXMucHVzaChgJHt3ZWFrU3RhcnRlcnMubGVuZ3RofSB3ZWFrIHN0YXJ0ZXJzYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3JlOiBNYXRoLm1heCgwLCBzdHJlbmd0aFNjb3JlKSxcbiAgICAgIGFuYWx5c2lzOiBhbmFseXNpcy5sZW5ndGggPiAwID8gYW5hbHlzaXMuam9pbignLCAnKSA6ICdTdHJvbmcgc3RhcnRpbmcgbGluZXVwJyxcbiAgICAgIGF2Z1N0YXJ0ZXJQb2ludHM6IHN0YXJ0ZXJzLmxlbmd0aCA+IDAgPyBzdGFydGVycy5tYXAoKHA6IGFueSkgPT4gcC5wcm9qZWN0ZWRQb2ludHMgfHwgMCkucmVkdWNlKChzdW06IG51bWJlciwgcHRzOiBudW1iZXIpID0+IHN1bSArIHB0cywgMCkgLyBzdGFydGVycy5sZW5ndGggOiAwXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYW5hbHl6ZUFEUFZhbHVlKHRlYW06IGFueSkge1xuICAgIGNvbnN0IHJvc3RlciA9IHRlYW0ucm9zdGVyIHx8IFtdO1xuICAgIGxldCBhZHBTY29yZSA9IDEwMDtcbiAgICBsZXQgc3RlYWxzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCByZWFjaGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCBhbmFseXNpczogc3RyaW5nW10gPSBbXTtcblxuICAgIHJvc3Rlci5mb3JFYWNoKChwbGF5ZXI6IGFueSkgPT4ge1xuICAgICAgY29uc3QgYWRwID0gcGxheWVyLmFkcFZhbHVlIHx8IDA7XG4gICAgICBjb25zdCByb3VuZCA9IHBsYXllci5yb3VuZCB8fCAwO1xuICAgICAgY29uc3QgcHJvamVjdGVkUG9pbnRzID0gcGxheWVyLnByb2plY3RlZFBvaW50cyB8fCAwO1xuICAgICAgXG4gICAgICBpZiAoYWRwID4gMCAmJiByb3VuZCA+IDApIHtcbiAgICAgICAgY29uc3QgYWRwUm91bmQgPSBNYXRoLmNlaWwoYWRwIC8gMTIpOyAvLyBDb252ZXJ0IEFEUCB0byBhcHByb3hpbWF0ZSByb3VuZFxuICAgICAgICBjb25zdCByb3VuZERpZmYgPSBhZHBSb3VuZCAtIHJvdW5kO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJvdW5kRGlmZiA+IDIpIHtcbiAgICAgICAgICAvLyBQbGF5ZXIgZHJhZnRlZCBtdWNoIGVhcmxpZXIgdGhhbiBBRFAgKHJlYWNoKVxuICAgICAgICAgIGFkcFNjb3JlIC09IDg7XG4gICAgICAgICAgcmVhY2hlcy5wdXNoKGAke3BsYXllci5wbGF5ZXJOYW1lfSAoUm91bmQgJHtyb3VuZH0sIEFEUCB+JHthZHBSb3VuZH0pYCk7XG4gICAgICAgIH0gZWxzZSBpZiAocm91bmREaWZmIDwgLTIpIHtcbiAgICAgICAgICAvLyBQbGF5ZXIgZHJhZnRlZCBtdWNoIGxhdGVyIHRoYW4gQURQIChzdGVhbClcbiAgICAgICAgICBhZHBTY29yZSArPSA1O1xuICAgICAgICAgIHN0ZWFscy5wdXNoKGAke3BsYXllci5wbGF5ZXJOYW1lfSAoUm91bmQgJHtyb3VuZH0sIEFEUCB+JHthZHBSb3VuZH0pYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEJvbnVzIGZvciBvdmVyYWxsIGRyYWZ0IHZhbHVlXG4gICAgaWYgKHN0ZWFscy5sZW5ndGggPiByZWFjaGVzLmxlbmd0aCkge1xuICAgICAgYWRwU2NvcmUgKz0gMTA7XG4gICAgICBhbmFseXNpcy5wdXNoKGBNb3JlIHN0ZWFscyAoJHtzdGVhbHMubGVuZ3RofSkgdGhhbiByZWFjaGVzICgke3JlYWNoZXMubGVuZ3RofSlgKTtcbiAgICB9IGVsc2UgaWYgKHJlYWNoZXMubGVuZ3RoID4gc3RlYWxzLmxlbmd0aCkge1xuICAgICAgYWRwU2NvcmUgLT0gMTA7XG4gICAgICBhbmFseXNpcy5wdXNoKGBNb3JlIHJlYWNoZXMgKCR7cmVhY2hlcy5sZW5ndGh9KSB0aGFuIHN0ZWFscyAoJHtzdGVhbHMubGVuZ3RofSlgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NvcmU6IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgYWRwU2NvcmUpKSxcbiAgICAgIHN0ZWFscyxcbiAgICAgIHJlYWNoZXMsXG4gICAgICBhbmFseXNpczogYW5hbHlzaXMubGVuZ3RoID4gMCA/IGFuYWx5c2lzLmpvaW4oJywgJykgOiAnQmFsYW5jZWQgQURQIHN0cmF0ZWd5JyxcbiAgICAgIHN0ZWFsQ291bnQ6IHN0ZWFscy5sZW5ndGgsXG4gICAgICByZWFjaENvdW50OiByZWFjaGVzLmxlbmd0aFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFuYWx5emVLZWVwZXJWYWx1ZSh0ZWFtOiBhbnkpIHtcbiAgICAvLyBGb3Igbm93LCBhc3N1bWUgbm8ga2VlcGVycyAtIHRoaXMgY2FuIGJlIGVuaGFuY2VkIGxhdGVyXG4gICAgLy8gS2VlcGVyIGFuYWx5c2lzIHdvdWxkIGxvb2sgYXQ6XG4gICAgLy8gLSBIb3cgbWFueSBrZWVwZXJzIHRoZXkgaGF2ZVxuICAgIC8vIC0gV2hhdCByb3VuZCB2YWx1ZSB0aG9zZSBrZWVwZXJzIHJlcHJlc2VudFxuICAgIC8vIC0gSG93IG11Y2ggb2YgYW4gYWR2YW50YWdlIHRoZXkgcHJvdmlkZVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzY29yZTogMTAwLCAvLyBOZXV0cmFsIHNjb3JlIGZvciBub3dcbiAgICAgIGFuYWx5c2lzOiAnTm8ga2VlcGVyIGFuYWx5c2lzIGF2YWlsYWJsZScsXG4gICAgICBrZWVwZXJzOiBbXSxcbiAgICAgIGtlZXBlckFkdmFudGFnZTogMFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU92ZXJhbGxSb3N0ZXJHcmFkZShwb3NpdGlvbkdyYWRlczogYW55KSB7XG4gICAgY29uc3Qgc2NvcmUgPSBwb3NpdGlvbkdyYWRlcy5vdmVyYWxsU2NvcmU7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3JlOiBNYXRoLnJvdW5kKHNjb3JlICogMTAwKSAvIDEwMCxcbiAgICAgIGdyYWRlOiBwb3NpdGlvbkdyYWRlcy5ncmFkZSxcbiAgICAgIHN1bW1hcnk6IHRoaXMuZ2VuZXJhdGVSb3N0ZXJTdW1tYXJ5KHBvc2l0aW9uR3JhZGVzKSxcbiAgICAgIGJyZWFrZG93bjoge1xuICAgICAgICBwb3NpdGlvbmFsQmFsYW5jZTogcG9zaXRpb25HcmFkZXMucG9zaXRpb25hbEJhbGFuY2UsXG4gICAgICAgIGRlcHRoU3RyYXRlZ3k6IHBvc2l0aW9uR3JhZGVzLmRlcHRoU3RyYXRlZ3ksXG4gICAgICAgIGFkcFZhbHVlOiBwb3NpdGlvbkdyYWRlcy5hZHBWYWx1ZSxcbiAgICAgICAga2VlcGVyVmFsdWU6IHBvc2l0aW9uR3JhZGVzLmtlZXBlclZhbHVlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVSb3N0ZXJTdW1tYXJ5KHBvc2l0aW9uR3JhZGVzOiBhbnkpIHtcbiAgICBjb25zdCB7IHBvc2l0aW9uYWxCYWxhbmNlLCBkZXB0aFN0cmF0ZWd5LCBzdGFydGluZ0xpbmV1cFN0cmVuZ3RoLCBhZHBWYWx1ZSB9ID0gcG9zaXRpb25HcmFkZXM7XG4gICAgXG4gICAgbGV0IHN1bW1hcnkgPSBgT3ZlcmFsbCBSb3N0ZXIgR3JhZGU6ICR7cG9zaXRpb25HcmFkZXMuZ3JhZGV9ICgke01hdGgucm91bmQocG9zaXRpb25HcmFkZXMub3ZlcmFsbFNjb3JlICogMTAwKSAvIDEwMH0vMTAwKVxcblxcbmA7XG4gICAgXG4gICAgLy8gUG9zaXRpb25hbCBCYWxhbmNlIFN1bW1hcnlcbiAgICBzdW1tYXJ5ICs9IGBQb3NpdGlvbmFsIEJhbGFuY2U6ICR7cG9zaXRpb25hbEJhbGFuY2Uuc2NvcmV9LzEwMFxcbmA7XG4gICAgaWYgKHBvc2l0aW9uYWxCYWxhbmNlLmlzc3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdW1tYXJ5ICs9IGBJc3N1ZXM6ICR7cG9zaXRpb25hbEJhbGFuY2UuaXNzdWVzLmpvaW4oJywgJyl9XFxuYDtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RhcnRpbmcgTGluZXVwIFN0cmVuZ3RoIFN1bW1hcnlcbiAgICBzdW1tYXJ5ICs9IGBcXG5TdGFydGluZyBMaW5ldXAgU3RyZW5ndGg6ICR7c3RhcnRpbmdMaW5ldXBTdHJlbmd0aC5zY29yZX0vMTAwXFxuYDtcbiAgICBzdW1tYXJ5ICs9IGBBdmVyYWdlIFN0YXJ0ZXIgUG9pbnRzOiAke3N0YXJ0aW5nTGluZXVwU3RyZW5ndGguYXZnU3RhcnRlclBvaW50cy50b0ZpeGVkKDEpfVxcbmA7XG4gICAgc3VtbWFyeSArPSBgQW5hbHlzaXM6ICR7c3RhcnRpbmdMaW5ldXBTdHJlbmd0aC5hbmFseXNpc31cXG5gO1xuICAgIFxuICAgIC8vIERlcHRoIFN0cmF0ZWd5IFN1bW1hcnlcbiAgICBzdW1tYXJ5ICs9IGBcXG5EZXB0aCBTdHJhdGVneTogJHtkZXB0aFN0cmF0ZWd5LnNjb3JlfS8xMDBcXG5gO1xuICAgIHN1bW1hcnkgKz0gYEJlbmNoIFNpemU6ICR7ZGVwdGhTdHJhdGVneS5iZW5jaFNpemV9IHBsYXllcnNcXG5gO1xuICAgIHN1bW1hcnkgKz0gYEFuYWx5c2lzOiAke2RlcHRoU3RyYXRlZ3kuYW5hbHlzaXN9XFxuYDtcbiAgICBcbiAgICAvLyBBRFAgVmFsdWUgU3VtbWFyeVxuICAgIHN1bW1hcnkgKz0gYFxcbkRyYWZ0IFZhbHVlOiAke2FkcFZhbHVlLnNjb3JlfS8xMDBcXG5gO1xuICAgIHN1bW1hcnkgKz0gYFN0ZWFsczogJHthZHBWYWx1ZS5zdGVhbENvdW50fSwgUmVhY2hlczogJHthZHBWYWx1ZS5yZWFjaENvdW50fVxcbmA7XG4gICAgc3VtbWFyeSArPSBgQW5hbHlzaXM6ICR7YWRwVmFsdWUuYW5hbHlzaXN9YDtcbiAgICBcbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgfVxuXG4gIHByaXZhdGUgc2NvcmVUb0dyYWRlKHNjb3JlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmIChzY29yZSA+PSA5MCkgcmV0dXJuICdBKyc7XG4gICAgaWYgKHNjb3JlID49IDg1KSByZXR1cm4gJ0EnO1xuICAgIGlmIChzY29yZSA+PSA4MCkgcmV0dXJuICdBLSc7XG4gICAgaWYgKHNjb3JlID49IDc1KSByZXR1cm4gJ0IrJztcbiAgICBpZiAoc2NvcmUgPj0gNzApIHJldHVybiAnQic7XG4gICAgaWYgKHNjb3JlID49IDY1KSByZXR1cm4gJ0ItJztcbiAgICBpZiAoc2NvcmUgPj0gNjApIHJldHVybiAnQysnO1xuICAgIGlmIChzY29yZSA+PSA1NSkgcmV0dXJuICdDJztcbiAgICBpZiAoc2NvcmUgPj0gNTApIHJldHVybiAnQy0nO1xuICAgIGlmIChzY29yZSA+PSA0NSkgcmV0dXJuICdEKyc7XG4gICAgaWYgKHNjb3JlID49IDQwKSByZXR1cm4gJ0QnO1xuICAgIGlmIChzY29yZSA+PSAzNSkgcmV0dXJuICdELSc7XG4gICAgcmV0dXJuICdGJztcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlTGVhZ3VlU3RhdHModGVhbXM6IGFueVtdLCBwb3NpdGlvblJlcXVpcmVtZW50czogc3RyaW5nW10pIHtcbiAgICBjb25zdCBwb3NpdGlvblN0YXRzOiBSZWNvcmQ8c3RyaW5nLCB7IHBvaW50czogbnVtYmVyW10sIHZvcnA6IG51bWJlcltdIH0+ID0ge307XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBwb3NpdGlvbiBzdGF0c1xuICAgIHBvc2l0aW9uUmVxdWlyZW1lbnRzLmZvckVhY2gocG9zID0+IHtcbiAgICAgIHBvc2l0aW9uU3RhdHNbcG9zXSA9IHsgcG9pbnRzOiBbXSwgdm9ycDogW10gfTtcbiAgICB9KTtcblxuICAgIC8vIENvbGxlY3QgYWxsIHBsYXllciBzdGF0cyBhY3Jvc3MgdGVhbXNcbiAgICB0ZWFtcy5mb3JFYWNoKHRlYW0gPT4ge1xuICAgICAgKHRlYW0ucm9zdGVyIHx8IFtdKS5mb3JFYWNoKChwbGF5ZXI6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSAocGxheWVyLnBvc2l0aW9uIHx8ICcnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoIXBvcyB8fCAhcG9zaXRpb25TdGF0c1twb3NdKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwb2ludHMgPSBwbGF5ZXIucHJvamVjdGVkUG9pbnRzIHx8IDA7XG4gICAgICAgIGNvbnN0IHZvcnAgPSB0aGlzLmdldFBsYXllclZvcnAocGxheWVyLnBsYXllck5hbWUgfHwgcGxheWVyLm5hbWUgfHwgJycpO1xuICAgICAgICBcbiAgICAgICAgcG9zaXRpb25TdGF0c1twb3NdLnBvaW50cy5wdXNoKHBvaW50cyk7XG4gICAgICAgIHBvc2l0aW9uU3RhdHNbcG9zXS52b3JwLnB1c2godm9ycCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlcyBhbmQgc3RhbmRhcmQgZGV2aWF0aW9uc1xuICAgIE9iamVjdC5rZXlzKHBvc2l0aW9uU3RhdHMpLmZvckVhY2gocG9zID0+IHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IHBvc2l0aW9uU3RhdHNbcG9zXS5wb2ludHMuZmlsdGVyKHAgPT4gcCA+IDApO1xuICAgICAgY29uc3Qgdm9ycCA9IHBvc2l0aW9uU3RhdHNbcG9zXS52b3JwLmZpbHRlcih2ID0+IHYgIT09IDApO1xuICAgICAgXG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5sZWFndWVBdmVyYWdlc1twb3NdID0gcG9pbnRzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLCAwKSAvIHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHRoaXMubGVhZ3VlU3RkRGV2c1twb3NdID0gdGhpcy5jYWxjdWxhdGVTdGREZXYocG9pbnRzLCB0aGlzLmxlYWd1ZUF2ZXJhZ2VzW3Bvc10pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodm9ycC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMubGVhZ3VlQXZlcmFnZXNbYCR7cG9zfV9WT1JQYF0gPSB2b3JwLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyB2LCAwKSAvIHZvcnAubGVuZ3RoO1xuICAgICAgICB0aGlzLmxlYWd1ZVN0ZERldnNbYCR7cG9zfV9WT1JQYF0gPSB0aGlzLmNhbGN1bGF0ZVN0ZERldih2b3JwLCB0aGlzLmxlYWd1ZUF2ZXJhZ2VzW2Ake3Bvc31fVk9SUGBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlU3RkRGV2KHZhbHVlczogbnVtYmVyW10sIG1lYW46IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPD0gMSkgcmV0dXJuIDA7XG4gICAgY29uc3QgdmFyaWFuY2UgPSB2YWx1ZXMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgTWF0aC5wb3codmFsIC0gbWVhbiwgMiksIDApIC8gdmFsdWVzLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGxheWVyVm9ycChwbGF5ZXJOYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGlmICghcGxheWVyTmFtZSkgcmV0dXJuIDA7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBwbGF5ZXJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHRoaXMudm9ycExvb2t1cFtub3JtYWxpemVkTmFtZV0gfHwgMDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UG9zaXRpb25SZXF1aXJlbWVudHMobGVhZ3VlVHlwZTogc3RyaW5nID0gJ3N0YW5kYXJkJywgYWN0dWFsVGVhbXM6IG51bWJlciA9IDEyLCBhY3R1YWxSb3VuZHM6IG51bWJlciA9IDE2KSB7XG4gICAgLy8gRml4ZWQgc3RhcnRlciByZXF1aXJlbWVudHMgLSBiZW5jaCBzaXplIHNjYWxlcyB3aXRoIHJvdW5kcywgbm90IHN0YXJ0ZXJzXG4gICAgY29uc3QgYmFzZVJlcXVpcmVtZW50cyA9IHtcbiAgICAgIHN0YW5kYXJkOiB7XG4gICAgICAgIFFCOiAxLCBSQjogMiwgV1I6IDIsIFRFOiAxLCBGTEVYOiAxLCBERUY6IDEsIEs6IDEsIC8vIDkgc3RhcnRlcnNcbiAgICAgICAgZmxleFBvc2l0aW9uczogWydSQicsICdXUicsICdURSddLFxuICAgICAgICBzdXBlcmZsZXhQb3NpdGlvbnM6IFtdXG4gICAgICB9LFxuICAgICAgc3VwZXJmbGV4OiB7XG4gICAgICAgIFFCOiAxLCBSQjogMiwgV1I6IDIsIFRFOiAxLCBGTEVYOiAxLCBERUY6IDEsIEs6IDEsIC8vIDkgc3RhcnRlcnMgKFFCIGVsaWdpYmxlIGluIGZsZXgpXG4gICAgICAgIGZsZXhQb3NpdGlvbnM6IFsnUUInLCAnUkInLCAnV1InLCAnVEUnXSxcbiAgICAgICAgc3VwZXJmbGV4UG9zaXRpb25zOiBbXVxuICAgICAgfSxcbiAgICAgICcycWInOiB7XG4gICAgICAgIFFCOiAyLCBSQjogMiwgV1I6IDIsIFRFOiAxLCBGTEVYOiAxLCBERUY6IDEsIEs6IDEsIC8vIDEwIHN0YXJ0ZXJzXG4gICAgICAgIGZsZXhQb3NpdGlvbnM6IFsnUkInLCAnV1InLCAnVEUnXSxcbiAgICAgICAgc3VwZXJmbGV4UG9zaXRpb25zOiBbXVxuICAgICAgfSxcbiAgICAgICcyZmxleCc6IHtcbiAgICAgICAgUUI6IDEsIFJCOiAyLCBXUjogMiwgVEU6IDEsIEZMRVg6IDIsIERFRjogMSwgSzogMSwgLy8gMTAgc3RhcnRlcnNcbiAgICAgICAgZmxleFBvc2l0aW9uczogWydSQicsICdXUicsICdURSddLFxuICAgICAgICBzdXBlcmZsZXhQb3NpdGlvbnM6IFtdXG4gICAgICB9LFxuICAgICAgJ3JvYnMtYnVsbHNoaXQnOiB7XG4gICAgICAgIFFCOiAyLCBSQjogMiwgV1I6IDMsIFRFOiAxLCBGTEVYOiAyLCBERUY6IDEsIEs6IDEsIC8vIDEyIHN0YXJ0ZXJzIChUSEUgQkVBU1QhKVxuICAgICAgICBmbGV4UG9zaXRpb25zOiBbJ1JCJywgJ1dSJywgJ1RFJ10sXG4gICAgICAgIHN1cGVyZmxleFBvc2l0aW9uczogW11cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gYmFzZVJlcXVpcmVtZW50c1tsZWFndWVUeXBlIGFzIGtleW9mIHR5cGVvZiBiYXNlUmVxdWlyZW1lbnRzXSB8fCBiYXNlUmVxdWlyZW1lbnRzLnN0YW5kYXJkO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBzdGFydGVycyAoZml4ZWQsIGRvZXNuJ3QgY2hhbmdlIHdpdGggcm91bmRzKVxuICAgIGNvbnN0IHRvdGFsU3RhcnRlcnMgPSBPYmplY3QuZW50cmllcyhyZXF1aXJlbWVudHMpXG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4gIVsnZmxleFBvc2l0aW9ucycsICdzdXBlcmZsZXhQb3NpdGlvbnMnXS5pbmNsdWRlcyhrZXkpKVxuICAgICAgLnJlZHVjZSgoc3VtLCBbXywgY291bnRdKSA9PiBzdW0gKyAodHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyA/IGNvdW50IDogMCksIDApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlcXVpcmVtZW50cyxcbiAgICAgIHRvdGFsU3RhcnRlcnMsXG4gICAgICBfbWV0YWRhdGE6IHtcbiAgICAgICAgYWN0dWFsVGVhbXMsXG4gICAgICAgIGFjdHVhbFJvdW5kcyxcbiAgICAgICAgbGVhZ3VlVHlwZSxcbiAgICAgICAgY2FsY3VsYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHJlcGxhY2VtZW50IGJhc2VsaW5lcyBmb3IgVk9SUCBjYWxjdWxhdGlvbnNcbiAgY2FsY3VsYXRlUmVwbGFjZW1lbnRCYXNlbGluZXMoc2V0dGluZ3M6IExlYWd1ZVNldHRpbmdzID0ge30pIHtcbiAgICBjb25zdCBsZWFndWVUeXBlID0gc2V0dGluZ3MubGVhZ3VlVHlwZSB8fCAnc3RhbmRhcmQnO1xuICAgIGNvbnN0IHN1cGVyZmxleFNsb3RzID0gc2V0dGluZ3Muc3VwZXJmbGV4U2xvdHMgfHwgMDtcbiAgICBjb25zdCB0ZWFtcyA9IHNldHRpbmdzLnRlYW1zIHx8IDEyO1xuICAgIFxuICAgIGNvbnN0IGJhc2VsaW5lcyA9IHtcbiAgICAgIFFCOiB0ZWFtcyAqICgxICsgc3VwZXJmbGV4U2xvdHMpLCAvLyBRQiBkZW1hbmQgaW5jcmVhc2VzIHdpdGggc3VwZXJmbGV4IHNsb3RzXG4gICAgICBSQjogdGVhbXMgKiAyLCAvLyBTdGFuZGFyZCBSQiBkZW1hbmRcbiAgICAgIFdSOiB0ZWFtcyAqIDIsIC8vIFN0YW5kYXJkIFdSIGRlbWFuZCAgXG4gICAgICBURTogdGVhbXMgKiAxLCAvLyBTdGFuZGFyZCBURSBkZW1hbmRcbiAgICAgIEs6IHRlYW1zICogMSxcbiAgICAgIERFRjogdGVhbXMgKiAxXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gYmFzZWxpbmVzO1xuICB9XG59ICJdLCJuYW1lcyI6WyJQb3NpdGlvbkdyYWRlRW5naW5lIiwiY29uc3RydWN0b3IiLCJ2b3JwQXJyYXkiLCJ2b3JwTG9va3VwIiwibGVhZ3VlQXZlcmFnZXMiLCJsZWFndWVTdGREZXZzIiwiZm9yRWFjaCIsInAiLCJuYW1lIiwicGxheWVyTmFtZSIsInRvTG93ZXJDYXNlIiwidmFsIiwidm9ycFNjb3JlIiwidm9ycF9zY29yZSIsIk51bWJlciIsImNhbGN1bGF0ZVBvc2l0aW9uR3JhZGVzIiwidGVhbXMiLCJzZXR0aW5ncyIsImxlYWd1ZVR5cGUiLCJhY3R1YWxUZWFtcyIsImFjdHVhbFJvdW5kcyIsInJvdW5kcyIsInBvc2l0aW9uUmVxdWlyZW1lbnRzIiwiZ2V0UG9zaXRpb25SZXF1aXJlbWVudHMiLCJjb25zb2xlIiwibG9nIiwiX21ldGFkYXRhIiwidGVhbXNXaXRoUG9zaXRpb25HcmFkZXMiLCJtYXAiLCJ0ZWFtIiwicm9zdGVyQ29uc3RydWN0aW9uR3JhZGUiLCJhbmFseXplUm9zdGVyQ29uc3RydWN0aW9uIiwicG9zaXRpb25HcmFkZXMiLCJ0ZWFtc1dpdGhPdmVyYWxsR3JhZGVzIiwib3ZlcmFsbEdyYWRlIiwiY2FsY3VsYXRlT3ZlcmFsbFJvc3RlckdyYWRlIiwicmVxdWlyZW1lbnRzIiwiYW5hbHlzaXMiLCJwb3NpdGlvbmFsQmFsYW5jZSIsImFuYWx5emVQb3NpdGlvbmFsQmFsYW5jZSIsImRlcHRoU3RyYXRlZ3kiLCJhbmFseXplRGVwdGhTdHJhdGVneSIsInN0YXJ0aW5nTGluZXVwU3RyZW5ndGgiLCJhbmFseXplU3RhcnRpbmdMaW5ldXBTdHJlbmd0aCIsImFkcFZhbHVlIiwiYW5hbHl6ZUFEUFZhbHVlIiwia2VlcGVyVmFsdWUiLCJhbmFseXplS2VlcGVyVmFsdWUiLCJvdmVyYWxsU2NvcmUiLCJncmFkZSIsIndlaWdodHMiLCJzY29yZSIsInNjb3JlVG9HcmFkZSIsInJvc3RlciIsInBvc2l0aW9uQ291bnRzIiwicG9zaXRpb25WYWx1ZXMiLCJwbGF5ZXIiLCJwb3MiLCJwb3NpdGlvbiIsInB1c2giLCJwcm9qZWN0ZWRQb2ludHMiLCJiYWxhbmNlU2NvcmUiLCJpc3N1ZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwicmVxdWlyZWQiLCJpbmNsdWRlcyIsImFjdHVhbCIsInJlcXVpcmVkTnVtIiwiZGVmaWNpdCIsImV4Y2VzcyIsImNyaXRpY2FsUG9zaXRpb25zIiwiTWF0aCIsIm1heCIsImxlbmd0aCIsImpvaW4iLCJzdGFydGVycyIsInNsaWNlIiwidG90YWxTdGFydGVycyIsImJlbmNoIiwiZGVwdGhTY29yZSIsImJlbmNoUXVhbGl0eSIsImF2Z0JlbmNoUG9pbnRzIiwicmVkdWNlIiwic3VtIiwicHRzIiwiYmVuY2hQb3NpdGlvbnMiLCJTZXQiLCJ3ZWFrU3RhcnRlcnMiLCJmaWx0ZXIiLCJiZW5jaFNpemUiLCJzdHJlbmd0aFNjb3JlIiwiYXZnU3RhcnRlclBvaW50cyIsInRvRml4ZWQiLCJhZHBTY29yZSIsInN0ZWFscyIsInJlYWNoZXMiLCJhZHAiLCJyb3VuZCIsImFkcFJvdW5kIiwiY2VpbCIsInJvdW5kRGlmZiIsIm1pbiIsInN0ZWFsQ291bnQiLCJyZWFjaENvdW50Iiwia2VlcGVycyIsImtlZXBlckFkdmFudGFnZSIsInN1bW1hcnkiLCJnZW5lcmF0ZVJvc3RlclN1bW1hcnkiLCJicmVha2Rvd24iLCJjYWxjdWxhdGVMZWFndWVTdGF0cyIsInBvc2l0aW9uU3RhdHMiLCJwb2ludHMiLCJ2b3JwIiwidG9VcHBlckNhc2UiLCJnZXRQbGF5ZXJWb3JwIiwia2V5cyIsInYiLCJjYWxjdWxhdGVTdGREZXYiLCJ2YWx1ZXMiLCJtZWFuIiwidmFyaWFuY2UiLCJwb3ciLCJzcXJ0Iiwibm9ybWFsaXplZE5hbWUiLCJiYXNlUmVxdWlyZW1lbnRzIiwic3RhbmRhcmQiLCJRQiIsIlJCIiwiV1IiLCJURSIsIkZMRVgiLCJERUYiLCJLIiwiZmxleFBvc2l0aW9ucyIsInN1cGVyZmxleFBvc2l0aW9ucyIsInN1cGVyZmxleCIsImtleSIsIl8iLCJjb3VudCIsImNhbGN1bGF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNhbGN1bGF0ZVJlcGxhY2VtZW50QmFzZWxpbmVzIiwic3VwZXJmbGV4U2xvdHMiLCJiYXNlbGluZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/lib/position-grade-engine.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fanalyze-draft%2Froute&page=%2Fapi%2Fanalyze-draft%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fanalyze-draft%2Froute.ts&appDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fkanikameister%2FDocuments%2Fff_api_skeleton&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();